# FSD-012d: IBKR Live Data Feed

**TrendEdge -- AI-Powered Futures Trading Platform**

| Field | Value |
|---|---|
| FSD ID | FSD-012d |
| Source | PRD-012 (Completion Sweep, CS-4) |
| Title | IBKR Live Data Feed |
| Version | 1.0 |
| Status | Draft |
| Author | Generated by Claude |
| Created | 2026-02-12 |

---

## Table of Contents

1. [Introduction](#1-introduction)
2. [System Context](#2-system-context)
3. [Connection Lifecycle](#3-connection-lifecycle)
4. [Candle Aggregation](#4-candle-aggregation)
5. [Data Source Priority Chain](#5-data-source-priority-chain)
6. [Circuit Breaker](#6-circuit-breaker)
7. [Contract Symbol Mapping](#7-contract-symbol-mapping)
8. [Health Check Integration](#8-health-check-integration)
9. [Error Handling](#9-error-handling)
10. [Configuration](#10-configuration)
11. [Testing Specifications](#11-testing-specifications)
12. [Edge Cases](#12-edge-cases)

---

## 1. Introduction

### 1.1 Purpose

This sub-FSD specifies the IBKR live market data feed subsystem of the TrendEdge platform. It covers real-time streaming of 5-second bars from Interactive Brokers via `ib_async`, aggregation into 4H OHLCV candles, insertion into the existing `candles` table, and automatic triggering of the trendline detection pipeline on candle close.

This is the final piece of the market data ingestion layer. The existing pipeline (FSD-002 Section 3.1) uses Celery Beat scheduled tasks to poll yfinance for daily candles. This FSD replaces that polling model with a streaming model for users who have an active IBKR broker connection, reducing detection latency from minutes to seconds after candle close.

### 1.2 Scope

This document covers:

- **IBKR Connection Management**: Worker-level connection to IB Gateway/TWS via `ib_async`, including connection parameters, client ID assignment, reconnection, and graceful shutdown.
- **Real-Time Bar Subscription**: Subscribing to 5-second real-time bars via `reqRealTimeBars` and historical bars with `keepUpToDate=True` via `reqHistoricalData`.
- **Candle Aggregation**: Aggregating 5-second bars into 4H OHLCV candles with market-hours-aware boundary detection.
- **Data Source Priority Chain**: Tiered fallback from IBKR live stream to IBKR historical poll to Tradovate to yfinance.
- **Circuit Breaker**: Connection-level circuit breaker with 3-failure threshold and 15-minute cooldown.
- **Contract Symbol Mapping**: Resolving continuous symbols (e.g., "ES") to IBKR `Contract` objects using the existing `contract_calendar` and `contract_specifications` tables.
- **Health Check Integration**: Exposing IBKR feed status in the `/health/detailed` endpoint.

### 1.3 Out of Scope

- Order submission and execution via IBKR [see FSD-003c]
- Account data retrieval (balances, positions) via IBKR [see FSD-003c]
- Tradovate WebSocket data feed implementation (Priority 3 in the chain) [deferred to a future FSD]
- ML-based data quality scoring [see FSD-009]
- Notification delivery for feed health events [see FSD-010]
- Broker credential encryption and storage [see FSD-003c, already implemented]

### 1.4 Relationship to Other FSDs

| Related FSD | Relationship |
|---|---|
| FSD-002: Trendline Detection Engine | Hard dependency (downstream). Live candles feed into the detection pipeline defined in FSD-002 Section 3.1.2. On 4H candle close, this subsystem dispatches `detect_trendlines_incremental(instrument_id)`. |
| FSD-003c: Broker Adapters | Shared infrastructure. The IBKR connection uses the same `broker_connections` table and credential decryption logic. The live feed runs on a separate `ib_async.IB()` instance with a distinct client ID from the execution adapter. |
| FSD-001: Platform Foundation | Hard dependency. Provides PostgreSQL, Redis, Celery infrastructure, health check framework, and structured logging. |

### 1.5 Glossary

| Term | Definition |
|---|---|
| IB Gateway | Interactive Brokers' headless API server that exposes a TWS API socket on a configurable port. |
| TWS | Trader Workstation -- IB's desktop application that also exposes the TWS API socket. |
| ib_async | Python async library for communicating with IB Gateway/TWS via the TWS API protocol. |
| Real-Time Bar | A 5-second OHLCV bar streamed continuously by IBKR for subscribed contracts. |
| keepUpToDate | An `ib_async` parameter on `reqHistoricalData` that causes the API to stream new bars as they complete, in addition to returning historical data. |
| Front Month | The nearest expiring actively-traded futures contract, determined by the `contract_calendar` table's `is_front_month` flag and `rollover_date`. |
| Continuous Symbol | A platform-internal symbol (e.g., "ES", "NQ") that always maps to the current front-month contract. |
| CME Maintenance Halt | The daily 16:00-17:00 CT (22:00-23:00 UTC) trading halt on CME Group exchanges. |

---

## 2. System Context

### 2.1 Data Flow Overview

```
+------------------+     +-------------------+     +------------------+
| IBKR TWS/Gateway |     | Tradovate API     |     | yfinance         |
| (TCP Socket)     |     | (WebSocket)       |     | (HTTP REST)      |
+--------+---------+     +--------+----------+     +--------+---------+
         |                         |                          |
    5s bars (stream)          candle poll                 daily OHLCV
         |                         |                          |
+--------v-------------------------v--------------------------v--------+
|                         IBKRFeedManager                              |
|     (Celery worker, market_data queue, one per worker process)       |
|                                                                      |
|  +----------------+   +------------------+   +-------------------+   |
|  | ib_async.IB()  |   | CandleAggregator |   | FallbackRouter    |   |
|  | (connection)   +-->| (per instrument) +-->| (priority chain)  |   |
|  +----------------+   +------------------+   +-------------------+   |
|                                                                      |
|  +----------------+   +------------------+                           |
|  | CircuitBreaker |   | ContractMapper   |                           |
|  | (Redis-backed) |   | (calendar lookup)|                           |
|  +----------------+   +------------------+                           |
+----------------------------+-----------------------------------------+
                             |
                     4H candle INSERT
                             |
+----------------------------v-----------------------------------------+
|                    PostgreSQL: candles table                          |
|           (instrument_id, timestamp, OHLCV, source='ibkr')           |
+----------------------------+-----------------------------------------+
                             |
                   Celery task dispatch
                             |
+----------------------------v-----------------------------------------+
|            detect_trendlines_incremental(instrument_id)               |
|                    (detection queue)                                  |
+----------------------------------------------------------------------+
```

### 2.2 External Dependencies

| Dependency | Type | Description |
|---|---|---|
| IB Gateway / TWS | Hard (IBKR users) | TWS API socket server. Must be running and accepting API connections on the configured host:port. |
| ib_async | Hard | Python async client library for the TWS API. Version >=1.0.0. |
| PostgreSQL | Hard | Primary data store for candles, instruments, contract_calendar, contract_specifications, broker_connections. |
| Redis | Hard | Circuit breaker state, feed health metadata, Celery broker. |
| Celery | Hard | Worker process hosting the feed manager; task dispatch for trendline detection. |

### 2.3 Existing Infrastructure Used

| Component | Location | Usage |
|---|---|---|
| `candles` table | `backend/app/db/models/candle.py` | Insert aggregated 4H candles. Schema: `id`, `instrument_id`, `timestamp`, `timeframe`, `open`, `high`, `low`, `close`, `volume`, `source`, `atr_14`. |
| `instruments` table | `backend/app/db/models/instrument.py` | Lookup active instruments, their symbols, exchanges, `current_contract`, and `roll_date`. |
| `contract_calendar` table | `backend/app/db/models/contract_calendar.py` | Determine front-month contract via `is_front_month`, `rollover_date`, `contract_symbol`. |
| `contract_specifications` table | `backend/app/db/models/contract_specification.py` | Lookup exchange mapping for IBKR `Contract` construction. |
| `broker_connections` table | `backend/app/db/models/broker_connection.py` | Determine if user has an active IBKR connection; retrieve encrypted host/port credentials. |
| `MarketDataService` | `backend/app/services/market_data_service.py` | Existing yfinance-based ingestion; remains as Priority 4 fallback. |
| `ingest_candles` task | `backend/app/tasks/trendline_tasks.py` | Existing Celery Beat task for scheduled ingestion; continues to run as safety net alongside the live feed. |
| `detect_trendlines_incremental` | `backend/app/tasks/trendline_tasks.py` | Downstream detection task dispatched on candle insert. |
| Health endpoint | `backend/app/api/v1/health.py` | `/health/detailed` endpoint to extend with IBKR feed status. |

---

## 3. Connection Lifecycle

### 3.1 Worker Startup

On Celery worker startup (within the `market_data` queue worker), the feed manager initializes the IBKR connection if an active IBKR broker connection exists.

**Startup sequence:**

1. Worker process starts and registers a `worker_init` signal handler.
2. The handler queries `broker_connections` for rows where `broker_type = 'ibkr'` AND `status = 'active'`.
3. If zero rows are found: log at INFO level `"No active IBKR connections found. Live feed disabled. Using scheduled ingestion."` and exit the handler. The existing Celery Beat `ingest_candles` task handles data ingestion.
4. If one or more rows are found: select the first active connection (multi-user shared feed is deferred; single-connection model for MVP).
5. Decrypt broker credentials using the existing AES-256-GCM decryption utility (from FSD-003c).
6. Extract `host` (default: `127.0.0.1`) and `port` (default: `4002` for paper, `4001` for live) from decrypted credentials JSON.
7. Assign a client ID: `200 + worker_index` (client IDs 100-199 are reserved for execution adapters per FSD-003c; 200+ are for data feeds).
8. Attempt connection via `ib_async.IB().connectAsync(host, port, clientId, timeout=30)`.
9. On success: update `broker_connections.last_connected_at = NOW()`, set `status = 'active'`, log at INFO `"IBKR data feed connected: host={host}, port={port}, clientId={client_id}"`.
10. Subscribe to real-time bars for all active instruments (see Section 3.3).
11. Store the connection state in Redis: `ibkr_feed:state` = `{"connected": true, "connected_since": "<ISO timestamp>", "client_id": <id>, "user_id": "<uuid>"}` with TTL 3600 (refreshed every 60 seconds by heartbeat).
12. On failure: log at WARNING, increment circuit breaker failure count, fall back to scheduled ingestion.

### 3.2 Connection Parameters

| Parameter | Value | Source | Notes |
|---|---|---|---|
| `host` | From `broker_connections.credentials` → `host` | Decrypted credential JSON | Default: `127.0.0.1` |
| `port` | From `broker_connections.credentials` → `port` | Decrypted credential JSON | 4001 (live TWS), 4002 (paper TWS), 7496 (live Gateway), 7497 (paper Gateway) |
| `clientId` | `200 + worker_index` | Computed at startup | Avoids collision with execution adapters (100-range) and other TWS API clients |
| `timeout` | 30 seconds | Hardcoded | Connection establishment timeout |
| `readonly` | `True` | Hardcoded | Data feed connection does not submit orders; read-only prevents accidental order placement |
| `account` | From `broker_connections.account_id` | Database | Empty string if not set (IB auto-selects) |

### 3.3 Subscription Management

After successful connection, the feed manager subscribes to real-time bars for each active instrument.

**Subscription process per instrument:**

1. Resolve the instrument's continuous symbol to an IBKR `Contract` object (see Section 7).
2. Call `ib.reqRealTimeBars(contract, barSize=5, whatToShow='TRADES', useRTH=False)`.
   - `barSize=5` requests 5-second bars (the only supported real-time bar size for futures).
   - `useRTH=False` includes extended trading hours data.
3. Register a callback on the returned `RealTimeBarList` to receive bar updates.
4. Simultaneously, request historical data with `keepUpToDate=True` as a secondary stream:
   ```python
   ib.reqHistoricalData(
       contract,
       endDateTime='',
       durationStr='2 D',
       barSizeSetting='5 secs',
       whatToShow='TRADES',
       useRTH=False,
       keepUpToDate=True,
   )
   ```
   This provides a gap-fill mechanism: if real-time bars are missed, the historical stream backfills them.
5. Track each subscription in an in-memory dictionary: `subscriptions: dict[str, SubscriptionState]` keyed by instrument symbol.

**SubscriptionState fields:**

| Field | Type | Description |
|---|---|---|
| `instrument_id` | `uuid.UUID` | Database instrument ID |
| `symbol` | `str` | Continuous symbol (e.g., "ES") |
| `ibkr_contract` | `ib_async.Contract` | Resolved IBKR contract object |
| `realtime_bars` | `RealTimeBarList` | Handle for the real-time bar subscription |
| `historical_bars` | `BarDataList` | Handle for the keepUpToDate historical subscription |
| `aggregator` | `CandleAggregator` | In-memory 4H candle aggregation state |
| `subscribed_at` | `datetime` | UTC timestamp of subscription start |
| `last_bar_received` | `datetime` | UTC timestamp of most recent bar callback |
| `bars_received_count` | `int` | Running count of bars received since subscription |

### 3.4 Reconnection Strategy

The feed manager implements automatic reconnection with exponential backoff.

**Reconnection parameters:**

| Parameter | Value |
|---|---|
| Initial delay | 5 seconds |
| Backoff multiplier | 2x |
| Maximum delay | 60 seconds |
| Maximum retries before circuit breaker | 10 |
| Jitter | +/- 20% of computed delay (prevents thundering herd) |

**Reconnection sequence:**

1. Detect disconnection via `ib_async`'s `disconnectedEvent` callback.
2. Log at WARNING: `"IBKR data feed disconnected. Attempting reconnect in {delay}s."`.
3. Wait `delay` seconds.
4. Attempt `ib.connectAsync(host, port, clientId, timeout=30)`.
5. On success: resubscribe to all instruments, reset retry counter, log at INFO: `"IBKR data feed reconnected after {elapsed}s."`.
6. On failure: increment retry counter, double the delay (capped at 60s), increment circuit breaker failure counter.
7. After 10 consecutive failures: stop reconnection attempts, trip the circuit breaker (see Section 6), fall back to lower-priority data sources.
8. During reconnection attempts, the `ingest_candles` Beat task continues to provide data via yfinance.

### 3.5 Worker Shutdown

On Celery worker shutdown (`worker_shutdown` signal), the feed manager performs graceful cleanup:

1. Cancel all real-time bar subscriptions: `ib.cancelRealTimeBars(bars)` for each subscription.
2. Cancel all historical data subscriptions: `ib.cancelHistoricalData(bars)` for each subscription.
3. Flush any partially aggregated candles to a Redis key `ibkr_feed:partial_candles:{instrument_symbol}` so that a restarting worker can resume aggregation without data loss.
4. Disconnect: `ib.disconnect()`.
5. Remove the feed state from Redis: `DEL ibkr_feed:state`.
6. Log at INFO: `"IBKR data feed shut down gracefully. {n} subscriptions cancelled, {m} partial candles saved."`.

---

## 4. Candle Aggregation

### 4.1 Overview

IBKR real-time bars arrive as 5-second OHLCV snapshots. The `CandleAggregator` accumulates these into 4-hour OHLCV candles aligned to CME market session boundaries.

### 4.2 4H Candle Boundaries

CME futures trade nearly 24 hours, from Sunday 17:00 CT to Friday 16:00 CT, with a daily maintenance halt from 16:00-17:00 CT. The 4H candle boundaries are fixed at the following UTC times:

| Boundary (UTC) | Boundary (CT) | Session |
|---|---|---|
| 23:00 | 17:00 | Session open (evening) |
| 03:00 | 21:00 | Evening session |
| 07:00 | 01:00 | Overnight session |
| 11:00 | 05:00 | Asian overlap |
| 15:00 | 09:00 | US morning (includes RTH open) |
| 19:00 | 13:00 | US afternoon |
| 22:00 | 16:00 | Session close (maintenance halt begins) |

The 22:00-23:00 UTC gap corresponds to the CME daily maintenance halt. No candle spans this gap. The candle closing at 22:00 UTC covers 19:00-22:00 UTC (3 hours). The candle opening at 23:00 UTC is a standard 4-hour candle.

**DST handling:** The boundaries above are in UTC and do not shift with US daylight saving time. However, the CT equivalents shift by one hour during DST (CDT = UTC-5 instead of CST = UTC-6). The aggregator uses UTC exclusively for boundary detection.

### 4.3 Aggregation Algorithm

The `CandleAggregator` maintains per-instrument state in memory:

**CandleAggregator state:**

| Field | Type | Description |
|---|---|---|
| `instrument_id` | `uuid.UUID` | Database instrument ID |
| `current_boundary_start` | `datetime` | UTC start of the current 4H window |
| `current_boundary_end` | `datetime` | UTC end of the current 4H window |
| `open_price` | `Decimal | None` | Open price of the current candle (first bar's open) |
| `high_price` | `Decimal` | Running high |
| `low_price` | `Decimal` | Running low |
| `close_price` | `Decimal` | Most recent bar's close |
| `volume` | `int` | Accumulated volume |
| `bar_count` | `int` | Number of 5-second bars aggregated |

**On each incoming 5-second bar:**

1. Parse the bar timestamp (UTC).
2. Determine which 4H boundary window the bar belongs to by finding the latest boundary start <= bar timestamp.
3. If `current_boundary_start` is `None` (first bar) or the bar belongs to the current window:
   a. If `open_price` is `None`: set `open_price = bar.open`.
   b. Update `high_price = max(high_price, bar.high)`.
   c. Update `low_price = min(low_price, bar.low)`.
   d. Set `close_price = bar.close`.
   e. Accumulate `volume += bar.volume`.
   f. Increment `bar_count`.
4. If the bar belongs to a **new** boundary window (bar timestamp >= `current_boundary_end`):
   a. Flush the completed candle (see Section 4.4).
   b. Reset aggregator state for the new window.
   c. Process the bar as the first bar of the new window (step 3).

### 4.4 Candle Flush (Insert)

When a 4H boundary is crossed, the completed candle is inserted into PostgreSQL.

**Flush process:**

1. Validate the aggregated candle:
   - All OHLCV fields must be non-null.
   - `high >= low`, `high >= open`, `high >= close`, `low <= open`, `low <= close`.
   - `volume >= 0`.
   - `bar_count > 0` (at least one 5-second bar was received).
2. Construct a `Candle` record:
   ```python
   {
       "instrument_id": aggregator.instrument_id,
       "timestamp": aggregator.current_boundary_start,
       "timeframe": "4H",
       "open": aggregator.open_price,
       "high": aggregator.high_price,
       "low": aggregator.low_price,
       "close": aggregator.close_price,
       "volume": aggregator.volume,
       "source": "ibkr",
   }
   ```
3. Execute an upsert (INSERT ... ON CONFLICT DO NOTHING) on the unique index `(instrument_id, timestamp, timeframe)`. If the candle already exists (e.g., from a concurrent yfinance ingestion), the insert is silently skipped.
4. If the insert was successful (row was created, not skipped):
   a. Dispatch the trendline detection task: `detect_trendlines_incremental.delay(str(instrument_id))` on the `detection` queue.
   b. Log at INFO: `"4H candle inserted via IBKR live feed: symbol={symbol}, timestamp={ts}, OHLCV=({o},{h},{l},{c},{v}), bars_aggregated={bar_count}"`.
5. If the insert was skipped (duplicate):
   a. Log at DEBUG: `"4H candle already exists: symbol={symbol}, timestamp={ts}. Skipping IBKR insert."`.
   b. Do NOT dispatch the detection task (it was already dispatched by whatever inserted the existing candle).

### 4.5 Incomplete Candle Handling

If the worker shuts down or the IBKR connection drops mid-candle:

1. The partially aggregated candle state is serialized to JSON and stored in Redis:
   ```
   Key:   ibkr_feed:partial_candles:{instrument_symbol}
   Value: {"instrument_id": "...", "boundary_start": "...", "boundary_end": "...",
           "open": ..., "high": ..., "low": ..., "close": ..., "volume": ...,
           "bar_count": ..., "saved_at": "..."}
   TTL:   14400 (4 hours — one full candle period)
   ```
2. On worker restart or reconnection, the feed manager checks Redis for partial candle state for each instrument before creating a new aggregator.
3. If a partial candle exists and `boundary_end` has not yet passed (the candle period is still open): restore the aggregator state from Redis and continue aggregation.
4. If a partial candle exists but `boundary_end` has passed: the candle period closed while the feed was down. Discard the partial state. The gap-fill mechanism (FSD-002 Section 3.1.3) or the `ingest_candles` Beat task will provide the missing candle from an alternative source.

### 4.6 Schema Compatibility

The inserted candle must match the existing `candles` table schema exactly:

| Column | Type | Live Feed Value |
|---|---|---|
| `id` | UUID | Server-generated (`gen_random_uuid()`) |
| `instrument_id` | UUID (FK → instruments.id) | From instrument lookup |
| `timestamp` | TIMESTAMPTZ | 4H boundary start time (UTC) |
| `timeframe` | VARCHAR(5) | `"4H"` |
| `open` | NUMERIC(12,4) | First bar's open price |
| `high` | NUMERIC(12,4) | Max high across all bars in window |
| `low` | NUMERIC(12,4) | Min low across all bars in window |
| `close` | NUMERIC(12,4) | Last bar's close price |
| `volume` | BIGINT | Sum of all bar volumes in window |
| `source` | VARCHAR(20) | `"ibkr"` |
| `atr_14` | NUMERIC(12,4) | `NULL` (computed post-insert by the detection pipeline) |

---

## 5. Data Source Priority Chain

### 5.1 Priority Levels

| Priority | Source | Condition | Expected Latency | Timeframe Support |
|---|---|---|---|---|
| 1 | IBKR live stream | Active IBKR connection, real-time bars flowing | <5 seconds after candle close | 4H (aggregated from 5s bars) |
| 2 | IBKR historical poll | IBKR connected but real-time stream interrupted | <30 seconds (poll-based) | 4H (direct from IBKR historical API) |
| 3 | Tradovate WebSocket | Active Tradovate connection, no IBKR available | <15 seconds | 4H (deferred implementation; stub in priority chain) |
| 4 | yfinance | No broker connections, or all broker feeds failed | <60 seconds (delayed data) | 1D only (no intraday from free tier) |

### 5.2 Automatic Fallback Logic

The `FallbackRouter` manages transitions between data sources.

**Source selection on each candle period:**

1. Check if Priority 1 (IBKR live) is active:
   - IBKR feed connected AND circuit breaker is CLOSED AND bars received within the last 60 seconds.
   - If yes: use Priority 1. No action needed — the `CandleAggregator` handles candle completion automatically.
2. If Priority 1 is unavailable, check Priority 2 (IBKR historical poll):
   - IBKR connection exists (may be degraded) AND circuit breaker is NOT OPEN AND the last connection was within the last 15 minutes.
   - If yes: poll `ib.reqHistoricalData(contract, endDateTime='', durationStr='300 S', barSizeSetting='5 secs', whatToShow='TRADES', useRTH=False)` to fetch the most recent completed candle.
   - Aggregate the returned 5-second bars into a 4H candle using the same algorithm as the live aggregator.
3. If Priority 2 is unavailable, check Priority 3 (Tradovate):
   - Active Tradovate broker connection exists with `status = 'active'`.
   - If yes: request candle data via Tradovate REST API (implementation deferred; this FSD defines the interface point).
   - For MVP: Priority 3 is a pass-through that always falls through to Priority 4.
4. If Priority 3 is unavailable, use Priority 4 (yfinance):
   - Always available (no broker connection needed).
   - The existing `ingest_candles` Celery Beat task provides this path. It runs at the 4H candle boundaries regardless of live feed status.
   - Limitation: yfinance free tier provides daily candles only, not 4H. When falling back to yfinance, trendline detection runs on 1D timeframe data.

### 5.3 Source Recovery

When a higher-priority source recovers, the system switches back automatically:

1. The feed manager runs a 60-second health check loop (`_health_tick`).
2. On each tick, if the current active source is not Priority 1:
   a. Check if the circuit breaker is CLOSED or HALF_OPEN.
   b. If HALF_OPEN: attempt a single IBKR reconnection (see Section 6.4).
   c. If reconnection succeeds: resubscribe to all instruments, set active source to Priority 1.
3. Source transitions are logged at INFO level:
   ```
   "Data source changed: {old_source} -> {new_source}, reason={reason}"
   ```
   where `reason` is one of: `connection_lost`, `circuit_breaker_tripped`, `stream_stale`, `connection_recovered`, `circuit_breaker_closed`.

### 5.4 Concurrent Safety

The live feed and the Beat-scheduled `ingest_candles` task may both attempt to insert the same candle. This is handled safely:

- The `candles` table has a unique index on `(instrument_id, timestamp, timeframe)`.
- Both code paths use `INSERT ... ON CONFLICT DO NOTHING`.
- The first writer wins. The second silently skips.
- Only the first writer dispatches `detect_trendlines_incremental`.
- When the IBKR live feed is active and producing candles, the Beat task's inserts will be no-ops. This is expected and correct.

---

## 6. Circuit Breaker

### 6.1 State Machine

```
         success
    +------+------+
    |             |
    v             |
+-------+   +----+----+   +----------+
| CLOSED|-->|  OPEN   |-->| HALF_OPEN|
+---+---+   +---------+   +-----+----+
    ^        (15 min TTL)        |
    |                            |
    +------- success ------------+
    |
    +------- failure --> OPEN (re-open)
```

**States:**

| State | Behavior | Transition |
|---|---|---|
| CLOSED | Normal operation. IBKR connection active, bars flowing. Failure counter tracks consecutive failures. | 3 consecutive failures → OPEN |
| OPEN | IBKR connection halted. System uses next available data source in priority chain. Timer starts (15 minutes). | 15-minute TTL expires → HALF_OPEN |
| HALF_OPEN | Single reconnection probe. One attempt to connect to IBKR and subscribe to one instrument. | Success → CLOSED; Failure → OPEN (reset 15-min timer) |

### 6.2 Failure Counting

A "failure" is any of the following events:

| Event | Failure Type |
|---|---|
| `ib.connectAsync()` raises `ConnectionRefusedError` | Connection failure |
| `ib.connectAsync()` times out (>30 seconds) | Connection timeout |
| `ib.reqRealTimeBars()` raises an error | Subscription failure |
| No bars received for >120 seconds on any subscribed instrument during market hours | Stream stale |
| IBKR `errorEvent` with code 1100 (connectivity lost) or 2110 (connectivity restored, data lost) | Connection event |

Successes reset the failure counter to 0:
- Successful connection establishment.
- Successful bar reception after a reconnection.

### 6.3 Redis State Storage

Circuit breaker state is stored in Redis with the following key structure:

```
Key:    circuit_breaker:ibkr_feed:{user_id}
Type:   HASH
Fields:
  state              : "closed" | "open" | "half_open"
  consecutive_failures: integer (0-10)
  last_failure_at     : ISO 8601 timestamp
  last_success_at     : ISO 8601 timestamp
  opened_at           : ISO 8601 timestamp (when state changed to OPEN)
  transition_reason   : string (last failure description)
TTL:    86400 (24 hours; auto-cleanup for inactive users)
```

**State transitions with Redis operations:**

1. **Record failure** (CLOSED state):
   ```
   HINCRBY circuit_breaker:ibkr_feed:{user_id} consecutive_failures 1
   HSET circuit_breaker:ibkr_feed:{user_id} last_failure_at {now} transition_reason {reason}
   # If consecutive_failures >= 3:
   HSET circuit_breaker:ibkr_feed:{user_id} state open opened_at {now}
   ```

2. **Cooldown expiry check** (OPEN state):
   ```
   HGET circuit_breaker:ibkr_feed:{user_id} opened_at
   # If now - opened_at >= 15 minutes:
   HSET circuit_breaker:ibkr_feed:{user_id} state half_open
   ```

3. **Probe success** (HALF_OPEN state):
   ```
   HSET circuit_breaker:ibkr_feed:{user_id} state closed consecutive_failures 0 last_success_at {now}
   ```

4. **Probe failure** (HALF_OPEN state):
   ```
   HSET circuit_breaker:ibkr_feed:{user_id} state open opened_at {now} consecutive_failures 1 last_failure_at {now} transition_reason {reason}
   ```

### 6.4 Half-Open Probe

When the 15-minute cooldown expires and the circuit enters HALF_OPEN:

1. The `_health_tick` loop detects the HALF_OPEN state.
2. Attempt `ib.connectAsync(host, port, clientId, timeout=30)`.
3. If connection succeeds: subscribe to one instrument (the first in the active list) and wait up to 30 seconds for a bar.
4. If a bar is received: transition to CLOSED, resubscribe to all instruments, log at INFO: `"IBKR circuit breaker closed. Live feed restored."`.
5. If connection fails or no bar received within 30 seconds: transition back to OPEN, log at WARNING: `"IBKR circuit breaker probe failed. Re-opening for another 15 minutes."`.

---

## 7. Contract Symbol Mapping

### 7.1 Continuous-to-Specific Mapping

The platform uses continuous symbols (e.g., "ES", "NQ") internally. IBKR requires specific contract month identifiers. The mapping uses the existing `contract_calendar` and `contract_specifications` tables.

**Mapping process:**

1. Look up the instrument's `symbol` in the `instruments` table to get the `exchange`.
2. Look up the exchange in `contract_specifications` to confirm the IBKR-compatible exchange name.
3. Query `contract_calendar` for the current front-month contract:
   ```sql
   SELECT contract_symbol, month_code, year, rollover_date
   FROM contract_calendar
   WHERE instrument_family = :symbol
     AND is_front_month = true
   ORDER BY year, month_code
   LIMIT 1;
   ```
4. Construct the IBKR `Contract` object:
   ```python
   from ib_async import Future

   contract = Future(
       symbol=symbol,                    # e.g., "ES"
       lastTradeDateOrContractMonth=f"{year}{month_code_to_number}",  # e.g., "202603"
       exchange=exchange,                # e.g., "CME"
       currency="USD",
   )
   ```
5. Qualify the contract with IBKR: `await ib.qualifyContractsAsync(contract)`. This call validates the contract exists on IBKR's servers and fills in missing fields (conId, multiplier, etc.).
6. If qualification fails (contract not found on IBKR): log at ERROR, skip this instrument, try again on next cycle.

### 7.2 Exchange Mapping

| Platform Symbol | IBKR Symbol | Exchange | Currency |
|---|---|---|---|
| ES | ES | CME | USD |
| NQ | NQ | CME | USD |
| YM | YM | CBOT | USD |
| CL | CL | NYMEX | USD |
| GC | GC | COMEX | USD |
| PL | PL | NYMEX | USD |
| MES | MES | CME | USD |
| MNQ | MNQ | CME | USD |
| SI | SI | COMEX | USD |
| HG | HG | COMEX | USD |
| NG | NG | NYMEX | USD |
| ZB | ZB | CBOT | USD |

### 7.3 Month Code Conversion

The `contract_calendar.month_code` uses CME single-character codes. These must be converted to IBKR's numeric format (`YYYYMM`):

| Month Code | Month Number | Month Name |
|---|---|---|
| F | 01 | January |
| G | 02 | February |
| H | 03 | March |
| J | 04 | April |
| K | 05 | May |
| M | 06 | June |
| N | 07 | July |
| Q | 08 | August |
| U | 09 | September |
| V | 10 | October |
| X | 11 | November |
| Z | 12 | December |

### 7.4 Roll Handling

The feed manager checks for upcoming contract rolls on each `_health_tick` (every 60 seconds):

1. For each subscribed instrument, check if `contract_calendar.rollover_date` is within 3 business days of today.
2. If a roll is imminent:
   a. Query the next front-month contract from `contract_calendar`:
      ```sql
      SELECT contract_symbol, month_code, year
      FROM contract_calendar
      WHERE instrument_family = :symbol
        AND rollover_date > :current_rollover_date
      ORDER BY rollover_date ASC
      LIMIT 1;
      ```
   b. Log at INFO: `"Contract roll approaching for {symbol}: {current_contract} -> {next_contract}, rollover_date={rollover_date}"`.
3. On the rollover date:
   a. Cancel the existing real-time bar subscription for the old contract.
   b. Construct and qualify the new IBKR `Contract` for the next front-month.
   c. Subscribe to real-time bars for the new contract.
   d. Update the `instruments` table: `current_contract = new_contract_symbol`, `roll_date = next_rollover_date`.
   e. Update `contract_calendar`: set `is_front_month = false` on the old row, `is_front_month = true` on the new row.
   f. Flush any partially aggregated candle for the old contract (the candle straddles the roll; mark it with `source = 'ibkr_roll'` for traceability).
   g. Log at INFO: `"Contract roll completed for {symbol}: now subscribed to {new_contract}"`.

### 7.5 Roll Schedule

The roll occurs at the time specified by the following logic:

- **Roll trigger**: `rollover_date` from `contract_calendar` (pre-populated per TD-FR-100 through TD-FR-103).
- **Roll time**: 17:00 CT (23:00 UTC) on the rollover date — at the start of the new session.
- **Pre-roll notification**: 3 business days before rollover, a WARNING-level log is emitted. No user notification for MVP (future: alert via notification system).

---

## 8. Health Check Integration

### 8.1 Addition to /health/detailed

The existing `/health/detailed` endpoint (in `backend/app/api/v1/health.py`) is extended with an `ibkr_feed` section.

**Response addition:**

```json
{
  "ibkr_feed": {
    "status": "ok",
    "connected_since": "2026-02-12T14:00:00Z",
    "instruments_subscribed": 6,
    "last_bar_received": "2026-02-12T18:00:05Z",
    "latency_ms": 45,
    "source_priority": 1,
    "circuit_breaker_state": "closed",
    "active_source": "ibkr_live",
    "partial_candles": 3
  }
}
```

### 8.2 Status Values

| Status | Condition |
|---|---|
| `ok` | Connected to IBKR, bars received within the last 60 seconds, circuit breaker CLOSED. |
| `degraded` | Connected but data delayed >60 seconds, or on fallback source (Priority 2-4), or circuit breaker HALF_OPEN. |
| `error` | Disconnected, all retries exhausted, circuit breaker OPEN. |
| `not_configured` | No IBKR broker connection exists in the database. |

### 8.3 Health Check Fields

| Field | Type | Description |
|---|---|---|
| `status` | string | One of: `ok`, `degraded`, `error`, `not_configured`. |
| `connected_since` | ISO 8601 string or null | Timestamp when the current IBKR connection was established. Null if not connected. |
| `instruments_subscribed` | integer | Number of instruments with active real-time bar subscriptions. |
| `last_bar_received` | ISO 8601 string or null | Timestamp of the most recent 5-second bar received from any instrument. |
| `latency_ms` | integer or null | Time in milliseconds between the bar's timestamp and when it was received by the worker. |
| `source_priority` | integer | Current active data source priority level (1-4). |
| `circuit_breaker_state` | string | Current circuit breaker state: `closed`, `open`, `half_open`. |
| `active_source` | string | Current active data source: `ibkr_live`, `ibkr_historical`, `tradovate`, `yfinance`. |
| `partial_candles` | integer | Number of instruments with in-progress (not yet flushed) candle aggregation. |

### 8.4 Data Source for Health Response

Health check data is read from Redis (not by connecting to IBKR):

- Feed state: `ibkr_feed:state` (HASH, updated every 60 seconds by the worker's `_health_tick`).
- Circuit breaker state: `circuit_breaker:ibkr_feed:{user_id}` (HASH).
- Subscription details: `ibkr_feed:subscriptions` (HASH, instrument count and last-bar timestamps).

This ensures the health endpoint responds quickly (<50ms) without depending on the IBKR connection being healthy.

---

## 9. Error Handling

### 9.1 Connection Errors

| Error | IBKR Error Code | Log Level | Behavior | User Impact |
|---|---|---|---|---|
| Connection refused (TWS not running) | N/A (socket error) | WARNING | Increment failure counter. Reconnect with backoff. | Falls back to yfinance; detection continues on scheduled cadence. |
| Authentication failure (wrong client ID or max connections) | 326, 501 | ERROR | Do not retry with same client ID. Try next client ID (201, 202, ...). After 3 IDs exhausted, trip circuit breaker. | Falls back to yfinance. |
| Connection timeout (>30s) | N/A (timeout) | WARNING | Increment failure counter. Reconnect with backoff. | Temporary; auto-recovers. |
| Market data farm connection lost | 1100 | WARNING | IBKR is reconnecting internally. Wait up to 5 minutes for code 1102 (data restored). If not restored, increment failure counter. | Bars may be delayed; gap-fill covers missing data. |
| Market data farm connection restored (data lost) | 2110 | INFO | Resubscribe to all instruments. Request historical bars to fill any gaps. | Momentary; auto-recovers. |
| Market data farm connection restored (data maintained) | 1102 | INFO | No action needed; bars resume automatically. | No impact. |

### 9.2 Subscription Errors

| Error | IBKR Error Code | Log Level | Behavior | User Impact |
|---|---|---|---|---|
| Invalid contract | 200 | ERROR | Skip this instrument. Log the symbol and attempted contract details. Do not retry until next roll check. | This instrument falls back to yfinance. Other instruments unaffected. |
| Pacing violation (too many historical data requests) | 162 | WARNING | Back off for 10 seconds, then retry. IBKR limits historical data to 60 requests per 10 minutes. | Temporary delay in gap-fill. Live bars unaffected. |
| No market data permissions | 354 | ERROR | Skip this instrument permanently until user updates their IBKR market data subscriptions. Mark the instrument's IBKR status as `no_permissions` in Redis. | This instrument uses yfinance. |
| Max number of market data lines | 101 | WARNING | Unsubscribe from the lowest-priority instrument (by user watchlist order) and retry. | One instrument loses live data; uses yfinance instead. |
| Duplicate ticker ID | 102 | WARNING | Cancel the old subscription and resubscribe with a new request ID. | No impact; handled transparently. |

### 9.3 Data Integrity Errors

| Error | Log Level | Behavior |
|---|---|---|
| Bar with `high < low` | WARNING | Discard the bar. Log the raw bar data. Do not aggregate. |
| Bar with negative price | WARNING | Discard the bar. Log the raw bar data. |
| Bar with zero volume during market hours | DEBUG | Accept the bar (some instruments have zero-volume 5s bars during low-liquidity periods). |
| Duplicate bar timestamp | DEBUG | Ignore (idempotent; aggregator state already reflects this bar). |
| Gap in 5-second bar sequence (>10 seconds between bars during market hours) | INFO | Log the gap. The aggregator handles gaps gracefully — the candle OHLCV is still correct based on received bars. If the gap exceeds 5 minutes, request historical backfill for the gap period. |

---

## 10. Configuration

### 10.1 Environment Variables

| Variable | Default | Required | Description |
|---|---|---|---|
| `IBKR_FEED_ENABLED` | `true` | No | Master toggle for the IBKR live feed. Set to `false` to disable even if broker connections exist. |
| `IBKR_FEED_CLIENT_ID_BASE` | `200` | No | Base client ID for data feed connections. Actual ID = base + worker_index. |
| `IBKR_FEED_RECONNECT_MAX_RETRIES` | `10` | No | Maximum reconnection attempts before circuit breaker trips. |
| `IBKR_FEED_RECONNECT_MAX_DELAY` | `60` | No | Maximum delay (seconds) between reconnection attempts. |
| `IBKR_FEED_STALE_BAR_THRESHOLD` | `120` | No | Seconds of no-bar silence before marking stream as stale. |
| `IBKR_FEED_CIRCUIT_BREAKER_THRESHOLD` | `3` | No | Consecutive failures to trip the circuit breaker. |
| `IBKR_FEED_CIRCUIT_BREAKER_COOLDOWN` | `900` | No | Cooldown period in seconds (default: 15 minutes). |
| `IBKR_FEED_HEALTH_TICK_INTERVAL` | `60` | No | Interval in seconds for the health check / housekeeping loop. |

### 10.2 Celery Worker Configuration

The IBKR feed runs within the existing `market_data` Celery worker.

**Queue assignment:**
- Worker queue: `market_data` (already defined in `celery_app.py`).
- Concurrency: 1 (single-threaded; `ib_async` is not thread-safe). The `market_data` worker MUST run with `--concurrency=1` when IBKR feed is enabled.
- Pool: `solo` (no prefork; required for `ib_async`'s asyncio event loop).

**Worker startup command:**
```bash
celery -A app.tasks.celery_app worker --queues=market_data --concurrency=1 --pool=solo --loglevel=info
```

The `worker_init` signal handler (Celery signal, not OS signal) initializes the IBKR feed manager. The `worker_shutdown` signal handler performs graceful cleanup.

### 10.3 Per-User vs. Shared Connection Model

**MVP (this FSD): Single-connection model.**

- One IBKR connection per worker process.
- The worker connects using the first active IBKR broker connection found in the database.
- All instrument subscriptions use this single connection.
- Multi-user support (multiple IBKR connections for different users) is deferred. When multiple users have IBKR connections, only the first is used for the shared instrument feed.

**Rationale:** IBKR imposes a maximum of 32 simultaneous API connections per account, and market data subscriptions are per-account (not per-connection). A single connection can subscribe to all instruments needed by all users.

**Future (multi-user):** Separate worker processes per user, each with its own IBKR connection. This requires per-user queue routing and is out of scope for this FSD.

---

## 11. Testing Specifications

### 11.1 Connection Tests (CS-TEST-030)

| Test ID | Test Case | Setup | Expected Outcome | Type |
|---|---|---|---|---|
| FEED-T-001 | Successful connection | Mock `ib_async.IB` with successful `connectAsync()` | Feed manager state shows connected, subscriptions initiated, Redis state set | Unit |
| FEED-T-002 | Connection refused | Mock `connectAsync()` to raise `ConnectionRefusedError` | Failure counter incremented, fallback to yfinance logged, circuit breaker state updated in Redis | Unit |
| FEED-T-003 | Connection timeout | Mock `connectAsync()` to hang for >30s | `asyncio.TimeoutError` caught, failure counter incremented, backoff delay applied | Unit |
| FEED-T-004 | Reconnection with backoff | Simulate disconnect after successful connection | Reconnection attempts at 5s, 10s, 20s, 40s delays (with jitter) | Unit |
| FEED-T-005 | Max retries exhausted | Simulate 10 consecutive connection failures | Circuit breaker trips, feed manager stops reconnection, logs CRITICAL | Unit |
| FEED-T-006 | Client ID conflict | Mock error code 326 (client ID in use) | Feed manager tries next client ID (201, 202, ...) | Unit |
| FEED-T-007 | Read-only connection | Verify `readonly=True` is passed | Connection established with read-only flag | Unit |
| FEED-T-008 | Graceful shutdown | Call worker shutdown handler | All subscriptions cancelled, partial candles saved to Redis, connection closed | Unit |
| FEED-T-009 | Integration: Paper TWS connection | IBKR Paper TWS running on port 4002 | Connection established, instruments subscribed, bars received within 30 seconds | Integration |

### 11.2 Data Integrity Tests (CS-TEST-031)

| Test ID | Test Case | Setup | Expected Outcome | Type |
|---|---|---|---|---|
| FEED-T-010 | 4H candle aggregation correctness | Feed 100 mock 5-second bars spanning one 4H boundary | Aggregated candle: open=first bar open, high=max high, low=min low, close=last bar close, volume=sum | Unit |
| FEED-T-011 | Boundary crossing detection | Feed bars from 14:59:55 to 15:00:05 UTC | Candle flushed at 15:00:00 boundary, new candle started | Unit |
| FEED-T-012 | Duplicate candle prevention | Insert a candle via yfinance, then attempt IBKR insert for same (instrument, timestamp, timeframe) | IBKR insert returns no-op (ON CONFLICT DO NOTHING), detection task NOT dispatched | Unit |
| FEED-T-013 | No duplicate candles over 24 hours | Subscribe and collect candles for 24 hours (simulated with time mocking) | Each `(instrument_id, timestamp)` pair appears exactly once in the candles table | Integration |
| FEED-T-014 | Invalid bar rejection | Feed a bar with `high < low` | Bar discarded, aggregator state unchanged, warning logged | Unit |
| FEED-T-015 | Partial candle recovery | Save partial candle to Redis, restart feed manager | Aggregator resumes from saved state, completed candle has correct OHLCV | Unit |
| FEED-T-016 | Expired partial candle discard | Save partial candle for a boundary that has already passed, restart feed manager | Partial candle discarded, aggregator starts fresh | Unit |
| FEED-T-017 | Trendline detection triggered | Insert a new candle via IBKR feed | `detect_trendlines_incremental` task dispatched on `detection` queue within 1 second | Integration |
| FEED-T-018 | CME maintenance halt | Feed bars during 22:00-23:00 UTC | No bars expected; aggregator does not create a candle for the halt period | Unit |
| FEED-T-019 | Volume accumulation | Feed 720 5-second bars (1 hour) with known volumes | Accumulated volume matches the sum of all bar volumes | Unit |

### 11.3 Circuit Breaker Tests

| Test ID | Test Case | Setup | Expected Outcome | Type |
|---|---|---|---|---|
| FEED-T-020 | Circuit trips after 3 failures | Simulate 3 consecutive connection failures | Redis state: `state=open`, `consecutive_failures=3` | Unit |
| FEED-T-021 | Circuit does not trip on 2 failures | Simulate 2 failures then 1 success | Redis state: `state=closed`, `consecutive_failures=0` | Unit |
| FEED-T-022 | Cooldown period | Trip the circuit, advance clock 14 minutes | State remains OPEN | Unit |
| FEED-T-023 | Half-open transition | Trip the circuit, advance clock 16 minutes | State transitions to HALF_OPEN | Unit |
| FEED-T-024 | Half-open probe success | Enter HALF_OPEN, mock successful connection + bar received | State transitions to CLOSED, all instruments resubscribed | Unit |
| FEED-T-025 | Half-open probe failure | Enter HALF_OPEN, mock connection failure | State transitions back to OPEN, 15-min timer restarted | Unit |
| FEED-T-026 | Redis state persistence | Trip circuit, restart worker process | Worker reads circuit state from Redis, does not attempt IBKR connection (OPEN state) | Integration |

### 11.4 Contract Roll Tests

| Test ID | Test Case | Setup | Expected Outcome | Type |
|---|---|---|---|---|
| FEED-T-030 | Roll detection | Set `contract_calendar.rollover_date` to 2 business days from now | Log message: "Contract roll approaching..." | Unit |
| FEED-T-031 | Roll execution | Set `rollover_date` to today, trigger `_health_tick` | Old subscription cancelled, new subscription created, `instruments.current_contract` updated | Unit |
| FEED-T-032 | Partial candle on roll | Partially aggregated candle exists when roll occurs | Partial candle flushed with `source='ibkr_roll'`, new aggregation starts for new contract | Unit |
| FEED-T-033 | Contract qualification failure | Mock `qualifyContractsAsync` to return empty list | Instrument skipped with ERROR log, fallback to yfinance for that instrument | Unit |
| FEED-T-034 | Month code conversion | All 12 month codes (F, G, H, J, K, M, N, Q, U, V, X, Z) | Each maps to correct numeric month (01-12) | Unit |

### 11.5 Health Check Tests

| Test ID | Test Case | Setup | Expected Outcome | Type |
|---|---|---|---|---|
| FEED-T-040 | Health status: ok | Feed connected, bars flowing, circuit closed | `/health/detailed` returns `ibkr_feed.status = "ok"` | Integration |
| FEED-T-041 | Health status: degraded | Feed connected but no bars for 90 seconds | `/health/detailed` returns `ibkr_feed.status = "degraded"` | Integration |
| FEED-T-042 | Health status: error | Circuit breaker OPEN | `/health/detailed` returns `ibkr_feed.status = "error"` | Integration |
| FEED-T-043 | Health status: not_configured | No IBKR broker connection in database | `/health/detailed` returns `ibkr_feed.status = "not_configured"` | Integration |
| FEED-T-044 | Health endpoint latency | Feed in any state | `/health/detailed` responds within 50ms (reads from Redis, not IBKR) | Integration |

---

## 12. Edge Cases

### 12.1 TWS Restarts

IB TWS and Gateway require periodic restarts (TWS restarts daily by default at a configurable time).

**Behavior:**
1. The `ib_async` `disconnectedEvent` fires.
2. The feed manager enters reconnection mode with exponential backoff.
3. TWS typically restarts within 30-90 seconds.
4. On reconnection, all subscriptions are re-established.
5. Any bars missed during the restart are backfilled via `reqHistoricalData`.
6. If TWS does not restart within the backoff window (10 retries), circuit breaker trips. It will recover in HALF_OPEN after 15 minutes.

**Mitigation:** Configure TWS to restart outside market hours (e.g., during CME maintenance halt at 16:00-17:00 CT) so no bars are missed.

### 12.2 Network Partition

A network partition between the worker and IB Gateway causes bars to stop arriving without an explicit disconnect event.

**Detection:** The `_health_tick` loop checks `last_bar_received` for each subscription. If no bar has been received for >120 seconds during market hours, the stream is marked as stale.

**Behavior:**
1. After 120 seconds of silence: log WARNING, increment failure counter, mark source as DEGRADED.
2. Attempt to send a heartbeat: `ib.reqCurrentTime()`.
3. If heartbeat succeeds: the connection is alive but bars are delayed (possible IBKR server-side issue). Wait up to 5 more minutes.
4. If heartbeat fails: the connection is broken. Trigger disconnect + reconnection sequence.
5. During the detection period, the Beat-scheduled `ingest_candles` task provides gap coverage.

### 12.3 Daylight Saving Time Transitions

US DST transitions occur twice per year (March, November). Because all candle boundaries are defined in UTC, DST does not affect boundary detection.

**Impact:**
- The CT-equivalent of each UTC boundary shifts by one hour during DST.
- The CME maintenance halt shifts from 22:00-23:00 UTC (CST) to 21:00-22:00 UTC (CDT).
- The `CandleAggregator` boundary table must account for both DST states.

**Implementation:**
- The aggregator uses a `market_calendar` utility that computes 4H boundaries based on the current US/Eastern timezone offset.
- On DST transition days, the boundary schedule is recalculated at 00:00 UTC.
- The transition itself occurs at 02:00 local time (either springing forward or falling back). Since this falls within a 4H candle window, the candle simply spans more or fewer wall-clock minutes than usual, but the UTC boundaries remain consistent.

### 12.4 Market Holidays

On CME holidays (e.g., Christmas, New Year's, Independence Day), the exchange is closed and no bars are produced.

**Behavior:**
1. The feed manager remains connected but receives no bars.
2. After `IBKR_FEED_STALE_BAR_THRESHOLD` seconds (120s), the stale detection fires.
3. Before incrementing the failure counter, the manager checks if today is a market holiday by querying a market calendar:
   - If today is a holiday: log at DEBUG `"No bars expected — market holiday."` and suppress the stale warning.
   - If today is not a holiday: proceed with stale detection as normal.
4. Holiday detection uses the `exchange_calendars` Python library (or a static holiday list in the `contract_specifications.metadata_` JSONB field).

### 12.5 Contract Expiry During Active Subscription

If a contract expires while actively subscribed (the rollover was missed):

1. IBKR returns error code 200 (No security definition has been found for the request) on the expired contract.
2. The feed manager detects this error in the `errorEvent` callback.
3. Immediately trigger the roll sequence (Section 7.4), even though the scheduled roll was missed.
4. Query `contract_calendar` for the next valid front-month contract.
5. Subscribe to the new contract.
6. Log at WARNING: `"Emergency contract roll for {symbol}: expired contract {old} replaced with {new}."`.
7. Gap-fill any missing candles between the expiry and the new subscription via `reqHistoricalData`.

### 12.6 Worker Crash (Unclean Shutdown)

If the worker process crashes without executing the shutdown handler:

1. Partial candle state is NOT saved to Redis (only saved during graceful shutdown).
2. On worker restart, no partial candle state exists in Redis.
3. The aggregator starts fresh. The incomplete candle data is lost.
4. The `ingest_candles` Beat task or the next live stream bars will fill the gap.
5. The `gap_detection_and_fill` task (FSD-002 Section 3.1.3) runs after each ingestion cycle to detect and fill missing candles.

**Mitigation:** The `CandleAggregator` periodically checkpoints its state to Redis every 5 minutes (not just on shutdown). This limits data loss to at most 5 minutes of aggregation.

### 12.7 Multiple Workers on Same Queue

If multiple `market_data` workers are running (e.g., during deployment rollover):

1. Each worker attempts to connect to IBKR with a unique client ID (200 + worker_index).
2. IBKR may accept both connections, but duplicate bar subscriptions waste bandwidth.
3. The distributed lock mechanism prevents duplicate feeds:
   ```
   Key:   lock:ibkr_feed_manager
   Value: worker_id
   TTL:   300 (5 minutes, refreshed every 60 seconds)
   ```
4. Only the worker that holds the lock runs the active feed. Other workers detect the lock and skip IBKR initialization, relying on the scheduled Beat task for data ingestion.
5. If the lock-holding worker crashes, the lock expires after 5 minutes, and another worker acquires it.

---

*This document is FSD-012d of the TrendEdge platform. It specifies the IBKR live data feed subsystem as part of the PRD-012 completion sweep. Implementation requires the existing infrastructure from PRD-001 (platform), PRD-002 (trendline detection), and PRD-008 (broker connections).*
