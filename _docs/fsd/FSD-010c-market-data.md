# FSD-010c: Market Data & TradingView

**TrendEdge — AI-Powered Futures Trading Platform**

| Field | Value |
|---|---|
| FSD ID | FSD-010c |
| Source FSD | FSD-010 (Notifications & Integrations) |
| Title | Market Data & TradingView |
| Version | 1.0 |
| Status | Draft |
| Author | Generated by Claude |
| Created | 2026-02-12 |

---

## 1. Introduction

### 1.1 Purpose

This sub-FSD specifies the market data ingestion layer and TradingView webhook receiver for TrendEdge. It covers all behaviors, data flows, validation rules, and edge cases a developer needs to implement: (1) historical OHLCV fetching via yfinance with gap detection, (2) real-time broker data with 1-second update frequency, (3) a 3-tier caching strategy (hot/warm/cold), (4) the contract calendar with automatic rollover, (5) the SymbolResolver service, and (6) the TradingView webhook receiver including its 10-step validation pipeline, symbol mapping, front-month resolution, and activity log.

### 1.2 Scope

**In Scope:**
- Historical OHLCV data ingestion from yfinance (daily fetch schedule, gap detection, backfill)
- Real-time market data from broker APIs (IBKR, Tradovate) with fallback behavior
- 3-tier caching strategy: hot (Redis 5s), warm (Redis 5min), cold (PostgreSQL permanent)
- Contract calendar management with automatic rollover
- SymbolResolver service (4 input formats, broker-specific output)
- TradingView webhook receiver: unique URL/API key generation, 10-step payload validation, symbol mapping, front-month resolution, activity log
- Custom symbol mappings (user-defined overrides)
- Related data models, API endpoints, and test scenarios

**Out of Scope:**
- Notification engine dispatch, routing, templates, retry logic, quiet hours [see FSD-010a]
- Telegram Bot, Discord Webhook, Email (SendGrid/Resend), In-App Notification Center [see FSD-010b]
- Notification preferences UI [see FSD-010a]
- Trade execution logic downstream of signal acceptance [see FSD-003]
- Trendline detection algorithms consuming market data [see FSD-002]

### 1.3 Cross-References

| Document | Relationship |
|---|---|
| FSD-010a | Notification Engine & Preferences: receives `webhook.received` and `webhook.error` events from the TradingView receiver; dispatches rollover notifications |
| FSD-010b | Channel Integrations: Telegram `/trade` command uses SymbolResolver; notification templates reference symbol mapping display names |
| FSD-001 | Infrastructure: PostgreSQL, Redis, Celery Beat scheduling |
| FSD-002 | Trendline Detection: reads from warm/cold cache layers for scheduled scans and historical analysis |
| FSD-003 | Trade Execution: receives validated signals from TradingView webhook; uses SymbolResolver for order construction |
| FSD-008 | Authentication & Authorization: API key management, RLS policies on user-scoped data |
| FSD-009 | Billing & Subscriptions: no tier gating on market data; TradingView webhook available to all tiers |

---

## 2. System Context

### 2.1 Architecture Position

The Market Data & TradingView module serves two roles: (1) an **inbound data pipeline** that ingests historical and real-time price data from external sources and makes it available to the trendline engine, dashboard, and analytics modules via a tiered cache; and (2) an **inbound signal gateway** that accepts TradingView webhook alerts, validates them, maps symbols to broker contracts, and queues them for the execution engine.

### 2.2 Component Overview

```
                INBOUND SOURCES                    INTERNAL CONSUMERS

  yfinance ──────────┐                             Trendline Engine
  (daily OHLCV)      │                               (reads warm/cold cache)
                      ▼                                     ▲
              ┌──────────────────────┐                      │
              │   Market Data        │──── Cold Cache ──────┘
  Broker APIs │   Ingestion Layer    │     (PostgreSQL)
  (IBKR /     │                      │
   Tradovate) ├──── Hot Cache ───────┼──── Dashboard (1s price updates)
              │     (Redis 5s)       │
              │                      │──── Warm Cache ────── Analytics
              │   Contract Calendar  │     (Redis 5min)
              │   + SymbolResolver   │
              └──────────────────────┘
                        ▲
                        │
              ┌──────────────────────┐
  TradingView │   Webhook Receiver   │──── Validated Signal ──── Execution Engine
  Alerts ─────│   (10-step pipeline) │                           (FSD-003)
              │                      │──── webhook.received ──── Notification Engine
              │   Activity Log       │     webhook.error          (FSD-010a)
              └──────────────────────┘
```

### 2.3 External Systems

| System | Direction | Protocol | Purpose |
|---|---|---|---|
| yfinance | Outbound | Python library (HTTP) | Fetch historical daily OHLCV |
| Databento API | Outbound | HTTPS REST | Fetch intraday data (Phase 2) |
| Nasdaq Data Link | Outbound | HTTPS REST | Fetch continuous contract metadata |
| IBKR TWS API | Bidirectional | TCP/WebSocket via `ib_async` | Real-time Level 1 market data |
| Tradovate API | Bidirectional | WebSocket | Real-time quotes, DOM, time & sales |
| TradingView | Inbound | HTTPS Webhook | Receive trading signal alerts |

---

## 3. Market Data Integration

### 3.1 Historical OHLCV (yfinance)

**Source:** NT-FR-086 through NT-FR-090

#### 3.1.1 Supported Instruments

| Instrument | yfinance Ticker | Description |
|---|---|---|
| E-mini S&P 500 | `ES=F` | Front-month continuous |
| Micro E-mini S&P | `MES=F` | Front-month continuous |
| E-mini Nasdaq 100 | `NQ=F` | Front-month continuous |
| Micro E-mini Nasdaq | `MNQ=F` | Front-month continuous |
| E-mini Dow | `YM=F` | Front-month continuous |
| Crude Oil | `CL=F` | Front-month continuous |
| Gold | `GC=F` | Front-month continuous |
| Platinum | `PL=F` | Front-month continuous |
| Silver | `SI=F` | Front-month continuous |

#### 3.1.2 Fetch Schedule

- **Initial fetch:** On instrument activation, fetch maximum available history (~2 years daily OHLCV).
- **Daily update:** Celery Beat task at **18:30 ET** fetches the latest day's OHLCV and upserts into `market_data_daily`.
- **Gap detection:** After each daily fetch, check for missing trading dates (excluding weekends and known US market holidays). If gaps are found, backfill automatically by requesting the missing date range from yfinance.

#### 3.1.3 Error Handling

| Condition | Response |
|---|---|
| yfinance returns empty data | Log warning: `"No data returned from yfinance for {ticker} on {date}"`. Retry in 1 hour. |
| yfinance returns stale data (last date >2 trading days old) | Log warning. Continue serving cached data. Alert operations team. |
| yfinance library exception | Catch exception, log with traceback. Retry in 30 minutes (max 3 retries per daily run). |

### 3.2 Real-Time Data

**Source:** NT-FR-091 through NT-FR-093

#### 3.2.1 Data Sources

| Broker | Library/Protocol | Data Provided |
|---|---|---|
| IBKR | `ib_async` (TCP/WebSocket) | Level 1: bid, ask, last, volume, OHLC bar streaming |
| Tradovate | WebSocket | Quotes, DOM (depth of market), time & sales |

#### 3.2.2 Usage

- **Dashboard price display:** Updated every **1 second** for active instruments.
- **Unrealized P&L:** Recalculated on every price tick for open positions.
- **Trendline proximity alerts:** Price approaching a qualifying trendline triggers an evaluation check.
- **MAE/MFE tracking:** Maximum Adverse/Favorable Excursion updated on each tick for open trades.

#### 3.2.3 Fallback (No Broker Connected or Connection Down)

- Display delayed data (15-minute delay) from yfinance or the most recent cached price.
- Show `"Delayed"` badge next to the price in the UI.
- Tooltip on delayed badge: `"Real-time data unavailable. Connect a broker for live prices."`

### 3.3 Caching Strategy

**Source:** NT-FR-094 through NT-FR-096

#### 3.3.1 Three-Tier Cache Architecture

| Layer | Technology | TTL | Data Stored | Invalidation Strategy |
|---|---|---|---|---|
| **Hot** | Redis | 5 seconds | Current bid/ask/last per instrument | Overwritten on every tick from broker feed |
| **Warm** | Redis | 5 minutes | Recent 4H bars, daily bars, computed indicators | Rebuilt on 4H bar close or daily settlement |
| **Cold** | PostgreSQL | Permanent | Full historical OHLCV (all daily data) | Append-only via daily yfinance fetch job |

#### 3.3.2 Cache Access Rules

| Consumer | Cache Layer Read | Rationale |
|---|---|---|
| Dashboard price display | Hot | Needs sub-second freshness |
| Unrealized P&L, MAE/MFE | Hot | Needs tick-level accuracy |
| Trendline engine (scheduled 4H scans) | Warm | Reads recent bars; does not need tick data |
| Trendline engine (historical analysis / backtest) | Cold | Needs full history |
| Analytics module | Warm + Cold | Recent summaries from warm; historical from cold |

**Critical rule:** Neither the trendline engine nor analytics reads directly from external data APIs during scan or computation execution. All data access goes through the cache layers.

### 3.4 Contract Calendar and Rollover

**Source:** NT-FR-097 through NT-FR-099

#### 3.4.1 `contract_calendar` Table

| Field | Type | Constraints | Description |
|---|---|---|---|
| `symbol` | VARCHAR(10) | NOT NULL | Base instrument (e.g., `ES`) |
| `contract_month` | CHAR(6) | NOT NULL, PK | Contract code (e.g., `ESH26`) |
| `first_trade_date` | DATE | NOT NULL | First trading date for this contract |
| `last_trade_date` | DATE | NOT NULL | Expiration / last trading date |
| `rollover_date` | DATE | NOT NULL | Recommended rollover date (default: 7 days before `last_trade_date`) |
| `is_active` | BOOLEAN | NOT NULL | `true` if this is the current front-month contract |

#### 3.4.2 Automatic Rollover Behavior

A daily **Celery Beat task at 00:00 UTC** checks whether any instrument's `rollover_date` has been reached:

1. Query: `SELECT * FROM contract_calendar WHERE is_active = true AND rollover_date <= CURRENT_DATE`.
2. For each matched contract:
   - Set `is_active = false` on the expiring contract.
   - Set `is_active = true` on the next contract (determined by `first_trade_date` ordering for the same `symbol`).
3. Send a notification to all affected users via the notification engine [FSD-010a]: `"Contract rollover: {symbol} rolled from {old_contract} to {new_contract}. Active positions in the old contract are unaffected."`

**Edge Cases:**
- No next contract found in the calendar: Log critical error `"No successor contract for {symbol} after {old_contract}"`. Alert operations. Do NOT set `is_active = false` on the current contract (leave it active to avoid breaking downstream systems).
- Multiple contracts with `is_active = true` for the same symbol: Should never happen. On detection, log error, keep only the one with the latest `first_trade_date`, set others to `false`.

#### 3.4.3 Calendar Seeding

- The `contract_calendar` table is seeded during Phase 1 deployment with the current year's futures expiration dates for all supported instruments.
- Rollover dates default to 7 days before expiration and are configurable per instrument by an admin.

### 3.5 SymbolResolver Service

**Source:** NT-FR-097 through NT-FR-099

#### 3.5.1 Input Formats

The SymbolResolver accepts four input formats and normalizes them to a broker-specific contract symbol:

| Input Format | Example | Description |
|---|---|---|
| TradingView continuous | `ES1!` | Continuous contract notation from TradingView alerts |
| yfinance continuous | `ES=F` | Yahoo Finance futures ticker |
| Specific contract | `ESH26` | Explicit contract month + year |
| Base symbol | `ES` | Just the root instrument name |

#### 3.5.2 Resolution Logic

```
1. NORMALIZE INPUT
   Strip whitespace, convert to uppercase.

2. MATCH INPUT FORMAT
   IF input matches pattern `{BASE}1!` → TradingView continuous.
     Extract base symbol by removing trailing `1!`.
   ELIF input matches pattern `{BASE}=F` → yfinance continuous.
     Extract base symbol by removing trailing `=F`.
   ELIF input matches pattern `{BASE}{MONTH_CODE}{YEAR}` (e.g., ESH26) → Specific contract.
     Extract base symbol and contract details.
   ELSE → Treat as base symbol.

3. CHECK CUSTOM MAPPINGS FIRST
   Query `symbol_mappings` WHERE user_id = current_user AND source_symbol = input.
   IF found → use the custom mapping's base_symbol.

4. CHECK SYSTEM DEFAULT MAPPINGS
   Query `symbol_mappings` WHERE user_id IS NULL AND source_symbol = input.
   IF found → use the system mapping's base_symbol.

5. RESOLVE TO FRONT-MONTH CONTRACT
   IF input was a specific contract → use it directly.
   ELSE → Query `contract_calendar` WHERE symbol = base_symbol AND is_active = true.
   Return the active contract's `contract_month`.

6. FORMAT FOR BROKER
   Given the user's connected broker:
   - IBKR: Return `{base_symbol}` + IBKR expiry code format.
   - Tradovate: Return `{base_symbol}` + Tradovate month + year format.

7. IF resolution fails at any step → Return None.
   Caller is responsible for handling the None case appropriately.
```

#### 3.5.3 Symbol Mapping Tables

**Default Symbol Mapping (TradingView to Base):**

| TradingView | Base Symbol | IBKR Pattern | Tradovate Pattern |
|---|---|---|---|
| `ES1!` | ES | `ES` + expiry code | `ES` + month + year |
| `MES1!` | MES | `MES` + expiry code | `MES` + month + year |
| `NQ1!` | NQ | `NQ` + expiry code | `NQ` + month + year |
| `MNQ1!` | MNQ | `MNQ` + expiry code | `MNQ` + month + year |
| `YM1!` | YM | `YM` + expiry code | `YM` + month + year |
| `MYM1!` | MYM | `MYM` + expiry code | `MYM` + month + year |
| `CL1!` | CL | `CL` + expiry code | `CL` + month + year |
| `MCL1!` | MCL | `MCL` + expiry code | `MCL` + month + year |
| `GC1!` | GC | `GC` + expiry code | `GC` + month + year |
| `MGC1!` | MGC | `MGC` + expiry code | `MGC` + month + year |
| `PL1!` | PL | `PL` + expiry code | `PL` + month + year |
| `SI1!` | SI | `SI` + expiry code | `SI` + month + year |

**Symbol Mapping Quick Reference (Concrete Examples for March 2026):**

| TradingView | yfinance | Base | IBKR | Tradovate |
|---|---|---|---|---|
| `ES1!` | `ES=F` | ES | ES + expiry | ESH6 |
| `MES1!` | `MES=F` | MES | MES + expiry | MESH6 |
| `NQ1!` | `NQ=F` | NQ | NQ + expiry | NQH6 |
| `MNQ1!` | `MNQ=F` | MNQ | MNQ + expiry | MNQH6 |
| `YM1!` | `YM=F` | YM | YM + expiry | YMH6 |
| `CL1!` | `CL=F` | CL | CL + expiry | CLJ6 |
| `GC1!` | `GC=F` | GC | GC + expiry | GCJ6 |
| `PL1!` | `PL=F` | PL | PL + expiry | PLJ6 |
| `SI1!` | `SI=F` | SI | SI + expiry | SIH6 |

---

## 4. TradingView Webhook Receiver

### 4.1 Unique URL and API Key Generation

**Source:** NT-FR-062 through NT-FR-064

#### 4.1.1 Webhook URL

**Format:** `https://api.trendedge.com/webhooks/tv/{user_webhook_id}`

- `user_webhook_id`: URL-safe Base62-encoded UUID (22 characters). This is NOT the user's account ID.
- Generated automatically on account creation.
- Stored in `user_integrations` table with `channel = 'tradingview'`.

#### 4.1.2 API Key

**Format:** `te_wh_` + 32-character hex string (e.g., `te_wh_a1b2c3d4e5f6789012345678abcdef01`)

- Generated using `secrets.token_hex(32)` (256 bits of entropy).
- Stored as **bcrypt hash** (`cost=12`) in the database. Plaintext is shown exactly once at creation time.
- Settings page display after generation: `"Your API key has been generated. Copy it now — it will not be shown again."` followed by the key in a copy-to-clipboard field.

#### 4.1.3 Key Regeneration

1. User clicks "Regenerate" button.
2. Confirmation dialog: `"Are you sure? Your current API key will be immediately invalidated. Any TradingView alerts using the old key will fail."`
3. On confirm: Generate new key, hash and store, invalidate old key immediately.
4. Display new key (one-time view).

#### 4.1.4 Sample TradingView Alert JSON (Shown in Settings UI)

```json
{
  "api_key": "YOUR_API_KEY",
  "ticker": "{{ticker}}",
  "action": "{{strategy.order.action}}",
  "price": "{{close}}",
  "quantity": "{{strategy.order.contracts}}",
  "stop_loss": "{{plot_0}}",
  "take_profit": "{{plot_1}}",
  "message": "{{strategy.order.comment}}"
}
```

### 4.2 Payload Validation Pipeline

**Source:** NT-FR-065 through NT-FR-067

The webhook endpoint executes a **strict 10-step validation pipeline**. Steps are executed in order; the first failure terminates processing and returns the corresponding error response.

| Step | Check | Failure Response | HTTP Status |
|---|---|---|---|
| 1 | **URL validation:** `user_webhook_id` exists and is active in `user_integrations` | `{"error": "unknown_endpoint"}` | 404 |
| 2 | **Rate limit:** 60 requests/hour, burst 10 requests/minute per user | `{"error": "rate_limited"}` + `Retry-After` header | 429 |
| 3 | **Content-Type:** Must be `application/json` | `{"error": "unsupported_media_type"}` | 415 |
| 4 | **Body size:** Must be <= 10KB | `{"error": "payload_too_large"}` | 413 |
| 5 | **JSON parsing:** Must be valid JSON | `{"error": "invalid_json"}` | 400 |
| 6 | **API key:** `api_key` field must be present and match the user's stored bcrypt hash | `{"error": "invalid_api_key"}` | 401 |
| 7 | **HMAC (optional):** If user has enabled HMAC signing, `X-TrendEdge-Signature` header must be valid | `{"error": "invalid_signature"}` | 401 |
| 8 | **Required fields:** `ticker` and `action` must be present in payload | `{"error": "missing_required_fields", "fields": [...]}` | 422 |
| 9 | **Action validation:** `action` must be one of: `buy`, `sell`, `close`, `close_long`, `close_short` (case-insensitive) | `{"error": "invalid_action", "value": "..."}` | 422 |
| 10 | **Replay check:** If same `correlation_id` seen within 5 minutes (checked via Redis set) | `{"error": "duplicate_request"}` | 409 |

**Success Response (all 10 steps pass):**

```json
{
  "status": "accepted",
  "signal_id": "sig_abc123def456",
  "message": "Signal accepted and queued for processing"
}
```

HTTP status: **200 OK**.

#### 4.2.1 Response Time Requirement

The endpoint SHALL respond within **500ms (p99)**. All downstream processing (risk checks, order construction, execution) happens asynchronously via Celery task queue.

#### 4.2.2 Security Rules

- Invalid `user_webhook_id` returns generic 404 (NOT "user not found") to prevent enumeration.
- Invalid `api_key` returns generic 401 (NOT "key does not match user X") to prevent information leakage.
- Internal errors return 500 with `{"error": "internal_error"}` (no stack traces, no internal details).
- API key comparison uses constant-time comparison (`bcrypt.checkpw` handles this inherently).

### 4.3 Symbol Mapping for Webhooks

**Source:** NT-FR-068 through NT-FR-071

After payload validation passes, the receiver maps the incoming `ticker` to a broker-specific contract symbol using the SymbolResolver (section 3.5).

#### 4.3.1 Resolution Order

1. Check **user's custom symbol mappings** first (highest priority).
2. Fall back to **system default mappings** (section 3.5.3).
3. Resolve to the current **front-month contract** via `contract_calendar`.
4. Format for the user's connected broker.

#### 4.3.2 Unmapped Symbol Behavior

When a `ticker` cannot be resolved:

1. Return **200 OK** to the webhook caller. This is critical: returning non-200 causes TradingView to disable the alert after repeated failures.
2. Log the signal with status `symbol_unmapped` in `webhook_log`.
3. Emit a `webhook.error` event to the notification engine [FSD-010a] which sends the user a notification: `"Webhook received but symbol '{ticker}' could not be mapped to a broker contract. Please add a custom mapping in Settings > Integrations > TradingView > Symbol Mappings."`
4. Do NOT route to the execution engine.

#### 4.3.3 Custom Symbol Mappings

Users can define custom mappings in **Settings > Integrations > TradingView > Symbol Mappings**. Custom mappings take priority over system defaults. This allows users to handle non-standard TradingView ticker names from custom Pine Script indicators.

### 4.4 Webhook Activity Log

**Source:** NT-FR-074 through NT-FR-076

#### 4.4.1 `webhook_log` Table Schema

| Field | Type | Constraints | Description |
|---|---|---|---|
| `id` | UUID | PK | Primary key |
| `user_id` | UUID | FK -> users.id, NULLABLE, INDEX | Resolved user (null if URL was invalid at step 1) |
| `received_at` | TIMESTAMPTZ | NOT NULL, INDEX | Request receipt timestamp |
| `source_ip` | INET | NOT NULL | Originating IP address |
| `payload` | JSONB | NOT NULL | Raw request body with `api_key` value replaced by `"[REDACTED]"` |
| `validation_status` | VARCHAR(20) | NOT NULL, INDEX | One of: `valid`, `invalid_key`, `invalid_payload`, `rate_limited`, `unknown_url` |
| `mapped_symbol` | VARCHAR(20) | NULLABLE | Broker-specific symbol after resolution (null if mapping failed) |
| `signal_id` | UUID | FK -> signals.id, NULLABLE | Reference to the created signal (null if validation failed) |
| `response_code` | INTEGER | NOT NULL | HTTP status code returned to caller |
| `processing_time_ms` | INTEGER | NOT NULL | Total request processing time in milliseconds |

#### 4.4.2 Dashboard View

**Location:** Settings > Integrations > TradingView > Activity Log

- Shows the most recent **100** webhooks received.
- **Filtering:** Dropdown by status: All, Valid, Invalid Key, Invalid Payload, Rate Limited, Unknown URL.
- **Color-coded status badges:**
  - Green: `valid`
  - Red: `invalid_key`, `invalid_payload`
  - Yellow: `rate_limited`
  - Gray: `unknown_url`
- **Columns:** Timestamp, Source Symbol, Mapped Symbol, Status, Signal ID (clickable link to signal detail).
- **Row expansion:** Clicking a row expands it to show the full payload (with `api_key` redacted to `"[REDACTED]"`).

#### 4.4.3 Retention

- Records retained for **30 days**.
- Daily Celery Beat task at **04:00 UTC** purges records older than 30 days.

### 4.5 Post-Validation Signal Flow

After successful validation and symbol mapping, the webhook receiver:

1. Creates a signal record with `signal_source = "tradingview_webhook"` and status `pending`.
2. Emits a `webhook.received` domain event [consumed by FSD-010a notification engine] with the mapped symbol and signal ID.
3. Enqueues a Celery task for the execution pipeline [FSD-003] to perform risk checks and order construction.
4. If execution is paused for the user (`user.execution_paused = true`), the signal is logged with status `paused_skipped` and the user is notified: `"Signal received but execution is PAUSED: {direction} {symbol} @ {price}. Use /resume to re-enable."` [FSD-010b handles this notification via Telegram].

---

## 5. Data Specifications

### 5.1 Entity Relationship Summary

```
market_data_daily       (standalone, shared across all users)
market_data_intraday    (standalone, shared across all users — Phase 2)
contract_calendar       (standalone, shared across all users)
symbol_mappings         (system defaults + per-user custom overrides)
webhook_log             (per-user, linked to user_integrations)
user_integrations       (per-user, stores TradingView webhook_id + API key hash)
```

### 5.2 `market_data_daily` Table

| Field | Type | Constraints | Default | Description |
|---|---|---|---|---|
| `id` | BIGSERIAL | PK | Auto-increment | Row ID |
| `symbol` | VARCHAR(10) | NOT NULL | — | Normalized base symbol (e.g., `ES`) |
| `date` | DATE | NOT NULL | — | Trading date |
| `open` | NUMERIC(12,4) | NOT NULL | — | Open price |
| `high` | NUMERIC(12,4) | NOT NULL | — | High price |
| `low` | NUMERIC(12,4) | NOT NULL | — | Low price |
| `close` | NUMERIC(12,4) | NOT NULL | — | Close / settlement price |
| `volume` | BIGINT | NOT NULL | — | Total volume |
| `source` | VARCHAR(20) | NOT NULL | — | Data source: `yfinance`, `databento`, `broker` |
| `fetched_at` | TIMESTAMPTZ | NOT NULL | — | When this data was fetched |

**Constraints:**
- Unique: `(symbol, date)` — prevents duplicate entries per day per instrument.
- Index: `(symbol, date DESC)` — optimizes queries for most recent data.

### 5.3 `contract_calendar` Table

(See section 3.4.1 for full schema.)

### 5.4 `symbol_mappings` Table

| Field | Type | Constraints | Default | Description |
|---|---|---|---|---|
| `id` | SERIAL | PK | Auto-increment | Row ID |
| `user_id` | UUID | FK -> users.id, NULLABLE | — | NULL = system default; non-NULL = user custom |
| `source_symbol` | VARCHAR(20) | NOT NULL | — | Input symbol (e.g., `ES1!`) |
| `source_platform` | VARCHAR(20) | NOT NULL | — | Source: `tradingview`, `yfinance`, `manual` |
| `base_symbol` | VARCHAR(10) | NOT NULL | — | Normalized base (e.g., `ES`) |
| `is_active` | BOOLEAN | NOT NULL | `true` | Active flag |

**Constraints:**
- Unique: `(user_id, source_symbol, source_platform)` — one mapping per source symbol per platform per user.

### 5.5 `webhook_log` Table

(See section 4.4.1 for full schema.)

### 5.6 `user_integrations` (TradingView-Specific Fields)

The `user_integrations` table (shared across all integration types) stores TradingView configuration with `channel = 'tradingview'`:

| Field | Type | Constraints | Description |
|---|---|---|---|
| `id` | UUID | PK | Primary key |
| `user_id` | UUID | FK -> users.id, NOT NULL | Owner |
| `channel` | VARCHAR(20) | NOT NULL, value = `'tradingview'` | Integration type |
| `external_id` | VARCHAR(255) | NOT NULL | The `user_webhook_id` (Base62, 22 chars) |
| `config` | JSONB | NOT NULL | Contains `api_key_hash` (bcrypt), `hmac_enabled` (bool), `hmac_secret_hash` (bcrypt, optional) |
| `is_active` | BOOLEAN | NOT NULL | Whether the webhook endpoint is active |
| `created_at` | TIMESTAMPTZ | NOT NULL | Creation timestamp |
| `updated_at` | TIMESTAMPTZ | NOT NULL | Last update |

### 5.7 Data Validation Rules

| Field | Rule | Error Message |
|---|---|---|
| TradingView API key | Must match `te_wh_[a-f0-9]{64}` on input | `"Invalid API key format."` |
| Symbol mapping `source_symbol` | Alphanumeric + `!` + `=` only, max 20 chars | `"Invalid symbol format."` |
| Symbol mapping `base_symbol` | Alphanumeric only, max 10 chars | `"Invalid base symbol format."` |
| Webhook payload size | <= 10KB | `"Payload too large."` |
| Webhook `action` field | Must be `buy`, `sell`, `close`, `close_long`, or `close_short` | `"Invalid action value."` |
| Custom webhook URL for TradingView | Must be valid HTTPS URL | `"Webhook URL must use HTTPS."` |

---

## 6. API Specifications

### 6.1 TradingView Webhook Endpoint

**`POST /webhooks/tv/{user_webhook_id}`**

- **Auth:** API key in request body (`api_key` field), verified via bcrypt.
- **Rate Limit:** 60 requests/hour, burst 10/minute per user.
- **Request Content-Type:** `application/json`
- **Max Body Size:** 10KB
- **Full validation pipeline:** See section 4.2.
- **Success Response (200):**
  ```json
  {
    "status": "accepted",
    "signal_id": "sig_abc123def456",
    "message": "Signal accepted and queued for processing"
  }
  ```
- **Error Responses:** See section 4.2 validation pipeline table for all error codes and HTTP status codes.
- **Performance:** < 500ms p99 response time.

### 6.2 TradingView Integration Management

**`POST /api/integrations/tradingview/regenerate-key`**
- Auth: Bearer token (JWT via Supabase Auth)
- Rate Limit: 3 requests/hour
- Response 200: `{"api_key": "te_wh_...", "message": "Copy this key now. It will not be shown again."}`
- Response 429: `{"error": "rate_limited", "message": "Too many key regeneration requests. Try again later."}`

**`GET /api/integrations/tradingview/activity-log?status={s}&page={n}`**
- Auth: Bearer token
- Params: `status` (optional, one of: `valid`, `invalid_key`, `invalid_payload`, `rate_limited`, `unknown_url`), `page` (default 1)
- Response 200: `{"entries": [...], "total": 87, "page": 1, "pages": 5}`
- Entries per page: 20
- Max visible entries: 100 (most recent)

**`GET /api/integrations/tradingview/symbol-mappings`**
- Auth: Bearer token
- Response 200: `{"system_mappings": [...], "custom_mappings": [...]}`

**`POST /api/integrations/tradingview/symbol-mappings`**
- Auth: Bearer token
- Body: `{"source_symbol": "CUSTOM1!", "source_platform": "tradingview", "base_symbol": "ES"}`
- Response 201: `{"id": 42, "source_symbol": "CUSTOM1!", "base_symbol": "ES"}`
- Response 400: `{"error": "invalid_symbol", "message": "Invalid symbol format."}`
- Response 409: `{"error": "duplicate_mapping", "message": "A mapping for this symbol already exists."}`

**`DELETE /api/integrations/tradingview/symbol-mappings/{id}`**
- Auth: Bearer token
- Response 200: `{"success": true}`
- Response 404: `{"error": "not_found", "message": "Mapping not found."}`

### 6.3 Rate Limiting (API-Level)

| Endpoint | Rate Limit | Window |
|---|---|---|
| TradingView webhook (`/webhooks/tv/...`) | 60 requests | Per hour per user |
| API key regeneration | 3 requests | Per hour |
| Integration configuration | 10 requests | Per minute |
| Activity log | 30 requests | Per minute |

### 6.4 Error Response Format

All API errors follow this structure:

```json
{
  "error": "error_code",
  "message": "Human-readable description",
  "details": {}
}
```

Standard HTTP status codes: 400 (bad request), 401 (unauthorized), 404 (not found), 409 (conflict), 413 (too large), 415 (unsupported media type), 422 (validation error), 429 (rate limited), 500 (internal error).

---

## 7. Security Specifications

### 7.1 Authentication

| Endpoint Category | Auth Method |
|---|---|
| TradingView webhook | API key in payload body (bcrypt-verified, constant-time comparison) |
| TradingView management APIs | Bearer token (JWT via Supabase Auth) |
| Market data (internal) | Service-level access (no user auth; data is shared) |

### 7.2 Data Encryption

| Data | At Rest | In Transit |
|---|---|---|
| Webhook API keys | bcrypt hash (cost=12) in PostgreSQL | HTTPS only |
| HMAC secrets | bcrypt hash (cost=12) in PostgreSQL | HTTPS only |
| Webhook payloads in `webhook_log` | PostgreSQL encryption at rest (Supabase default); `api_key` field redacted to `"[REDACTED]"` | HTTPS |
| Market data | PostgreSQL encryption at rest | HTTPS to yfinance; TLS/WSS to broker APIs |

### 7.3 Input Sanitization

| Input | Sanitization Rule |
|---|---|
| TradingView webhook payload | Validate JSON schema; reject unknown fields at validation level; enforce 10KB size limit |
| Symbol mapping inputs | Alphanumeric characters only (plus `!` and `=` for source symbols), max 20 chars |
| API key on input | Must match `te_wh_[a-f0-9]{64}` pattern |

### 7.4 Audit Logging

| Event | Logged Data | Retention |
|---|---|---|
| Webhook API key regeneration | `user_id`, timestamp, `old_key_hash_prefix` (first 8 chars of hash) | 1 year |
| Failed webhook authentication | `source_ip`, `user_webhook_id`, timestamp | 90 days |
| Custom symbol mapping CRUD | `user_id`, action, old/new values, timestamp | 1 year |
| Contract rollover execution | `symbol`, `old_contract`, `new_contract`, timestamp | 1 year |

---

## 8. Performance Specifications

### 8.1 Response Time Requirements

| Operation | Target (p95) | Target (p99) | Measurement |
|---|---|---|---|
| TradingView webhook response | < 300ms | < 500ms | Request received to HTTP response sent |
| Market data hot cache read | < 5ms | < 10ms | Redis GET latency |
| Market data warm cache read | < 10ms | < 20ms | Redis GET latency |
| Market data cold cache query | < 100ms | < 200ms | PostgreSQL query time (with index) |
| Symbol resolution | < 20ms | < 50ms | SymbolResolver call to return |
| Activity log query | < 100ms | < 200ms | API request to response |

### 8.2 Throughput Requirements

| Operation | Sustained | Burst |
|---|---|---|
| TradingView webhook ingestion | 100 requests/second | 200 requests/second for 30s |
| Market data updates (broker feed) | 10 instruments x 1 update/second = 10/s | 50/s during high volatility |
| yfinance daily fetch | 9 instruments per run | N/A (scheduled, not concurrent) |

### 8.3 Resource Limits

| Resource | Limit | Action on Exceed |
|---|---|---|
| Webhook log entries per user | ~1,000/month | 30-day retention purge handles this |
| Custom symbol mappings per user | 50 | API returns 400: `"Maximum custom mappings reached."` |
| Market data daily rows | ~5,000 per instrument (~2 years) | Append-only; no practical limit concern |

---

## 9. Testing Specifications

### 9.1 Unit Test Scenarios

| Test Area | Scenario | Expected Behavior |
|---|---|---|
| **Symbol mapping** | Input `ES1!` | Returns correct current front-month contract for user's broker |
| **Symbol mapping** | Input `ES=F` | Resolves yfinance format to base `ES`, then to front-month |
| **Symbol mapping** | Input `ESH26` | Returns specific contract formatted for user's broker |
| **Symbol mapping** | Input `ES` (base symbol) | Resolves to front-month contract |
| **Symbol mapping** | Unknown symbol `XYZ1!` | Returns `None`; logs warning |
| **Symbol mapping** | Custom mapping exists | Custom mapping takes priority over system default |
| **Webhook validation** | Valid payload with all fields | 200 OK, signal created, `webhook_log` entry with status `valid` |
| **Webhook validation** | Invalid API key | 401, no signal created, `webhook_log` status `invalid_key` |
| **Webhook validation** | Missing `ticker` field | 422, `missing_required_fields` with field list |
| **Webhook validation** | Missing `action` field | 422, `missing_required_fields` with field list |
| **Webhook validation** | Invalid action value `"hold"` | 422, `invalid_action` with value |
| **Webhook validation** | Oversized payload (>10KB) | 413, `payload_too_large` |
| **Webhook validation** | Non-JSON Content-Type | 415, `unsupported_media_type` |
| **Webhook validation** | Invalid JSON body | 400, `invalid_json` |
| **Webhook validation** | Duplicate `correlation_id` within 5 min | 409, `duplicate_request` |
| **Webhook validation** | Unknown `user_webhook_id` | 404, `unknown_endpoint` |
| **Webhook validation** | Rate limit exceeded (61st req in hour) | 429, `rate_limited` with `Retry-After` |
| **Webhook validation** | Valid payload but unmapped symbol | 200 OK (to TradingView), signal NOT created, user notified |
| **Contract rollover** | Rollover date reached | Old contract deactivated, new contract activated, users notified |
| **Contract rollover** | No successor contract | Critical error logged, current contract stays active |
| **Cache** | Hot cache miss | Falls back to warm, then cold |
| **Cache** | Broker tick received | Hot cache updated, TTL reset to 5s |
| **yfinance fetch** | Gap detected (missing trading day) | Backfill request issued automatically |
| **yfinance fetch** | Empty data returned | Warning logged, retry in 1 hour |
| **yfinance fetch** | Stale data (>2 days old) | Warning logged, cached data served, operations alerted |
| **Real-time fallback** | Broker disconnected | Delayed data shown with `"Delayed"` badge |

### 9.2 Integration Test Scenarios

| Test | Setup | Verification |
|---|---|---|
| TradingView webhook full pipeline | POST valid payload to `/webhooks/tv/{id}` | Signal created, `webhook.received` event emitted, notification sent to user, activity log updated |
| Webhook with unmapped symbol | POST payload with unknown ticker | 200 returned, `webhook.error` event emitted, user notification sent |
| Market data daily fetch | Trigger Celery Beat yfinance task | Data stored in `market_data_daily`, no duplicates on re-run |
| Gap detection and backfill | Remove 1 day from `market_data_daily` | Next fetch detects gap, backfills the missing day |
| Contract rollover | Advance system date past rollover date | `is_active` flags updated, user notification dispatched |
| Symbol resolution chain | Provide `ES1!` with user custom mapping for `ES1!` | Custom mapping used, not system default |
| API key regeneration | Regenerate key, send webhook with old key | 401 returned; send with new key: 200 returned |
| Cache tier access | Query warm cache while hot has expired data | Warm cache serves correct 4H bars |

### 9.3 Performance Test Criteria

| Test | Target | Method |
|---|---|---|
| Webhook endpoint under load | < 500ms p99 at 100 req/s | Load test with k6 or locust |
| Symbol resolution latency | < 50ms p99 | Benchmark with all 4 input formats |
| Market data query (cold cache) | < 200ms for 2-year range | Query explain analysis with production-like data volume |

### 9.4 Security Test Requirements

| Test | Method | Pass Criteria |
|---|---|---|
| Webhook brute force | Send 1,000 requests with random API keys | No information leakage; rate limit triggered; constant-time responses |
| API key timing attack | Measure response time for valid vs. invalid keys | < 5ms variance (bcrypt constant-time) |
| Webhook ID enumeration | Probe sequential/random webhook IDs | Generic 404 for all invalid IDs; no user info leaked |
| XSS in webhook payload | Inject script tags in `ticker` and `message` fields | Content sanitized before storage and display |
| RLS isolation | Attempt to read another user's webhook log or symbol mappings | 404 or empty result; never other user's data |
| Secret exposure | Search logs, API responses, and client code | No API keys, tokens, or bcrypt hashes exposed |

---

## 10. Migration & Deployment

### 10.1 Database Migrations (Phase 1, in Order)

1. Create `market_data_daily` table with unique constraint on `(symbol, date)` and index on `(symbol, date DESC)`.
2. Create `contract_calendar` table. Seed with current year's futures expiration dates for all supported instruments.
3. Create `symbol_mappings` table. Seed with default TradingView-to-broker mappings for all 12 instruments.
4. Create `webhook_log` table with indexes on `user_id`, `received_at`, and `validation_status`.
5. Ensure `user_integrations` table exists [shared with FSD-010b] with TradingView entries.

### 10.2 Phase 2 Migrations

1. Create `market_data_intraday` table for Databento integration.

### 10.3 Deployment Dependencies

| Dependency | Must Be Ready Before |
|---|---|
| Redis instance | Phase 1 (hot/warm cache, rate limiting, replay detection) |
| Celery Beat configured | Phase 1 (daily yfinance fetch, rollover check, log purge) |
| Contract calendar seeded | Phase 1 (SymbolResolver depends on it) |
| Symbol mappings seeded | Phase 1 (webhook receiver depends on it) |
| PostgreSQL with RLS | Phase 1 (webhook_log, symbol_mappings user isolation) |

### 10.4 Feature Flags

| Flag | Purpose | Default |
|---|---|---|
| `market_data.yfinance.enabled` | Enable/disable yfinance daily fetch | `true` |
| `market_data.realtime.enabled` | Enable/disable real-time broker data feed | `true` |
| `integrations.tradingview.enabled` | Enable/disable TradingView webhook endpoint | `true` |

### 10.5 Rollback Procedures

| Scenario | Rollback Action |
|---|---|
| Webhook endpoint returning errors | Revert deployment (feature flag not sufficient since external URL must remain responsive) |
| yfinance fetch failures | Disable via feature flag; serve cached data until resolved |
| Contract rollover executed incorrectly | Manual correction in `contract_calendar` table; send corrective notification to users |
| Market data corruption | Truncate affected rows in `market_data_daily`; re-run initial fetch for affected instruments |

---

## 11. Open Questions & Assumptions

### 11.1 Assumptions

| # | Assumption | Impact if Wrong |
|---|---|---|
| A1 | yfinance free tier is reliable enough for daily OHLCV | May need to switch to paid Databento or Nasdaq Data Link sooner |
| A2 | Users have at most 20 active instruments requiring market data | Caching and data fetch strategies scale linearly with instrument count |
| A3 | Contract rollover dates are predictable and can be pre-seeded | Edge cases like early expiration or exchange schedule changes need manual intervention |
| A4 | TradingView webhook payloads follow a consistent structure across different Pine Script strategies | Custom mapping + flexible parsing mitigates variability |

### 11.2 Items Requiring Clarification

| # | Question | Suggested Default |
|---|---|---|
| Q1 | Should custom symbol mappings support regex patterns or only exact matches? | Exact matches only in Phase 1; regex in Phase 3 |
| Q2 | How should the system handle broker-specific market data fees? | Document in broker connection flow; outside scope of this FSD |
| Q3 | Should the hot cache store full Level 2 data or only Level 1? | Level 1 only in Phase 1; Level 2 for Pro tier in Phase 2 |

---

## 12. Appendices

### 12.1 Glossary

| Term | Definition |
|---|---|
| Continuous Contract | A synthetic futures symbol that always refers to the current front-month contract (e.g., `ES1!` in TradingView, `ES=F` in yfinance) |
| Front Month | The nearest futures contract month that is actively trading |
| OHLCV | Open, High, Low, Close, Volume — standard market data bar format |
| Rollover | The process of transitioning from an expiring futures contract to the next active one |
| Hot Cache | Redis layer with 5-second TTL for real-time bid/ask/last prices |
| Warm Cache | Redis layer with 5-minute TTL for recent bars and computed indicators |
| Cold Cache | PostgreSQL permanent storage for full historical OHLCV data |
| SymbolResolver | Service that accepts 4 input formats and returns a broker-specific contract symbol |
| Tick | The minimum price movement for a futures instrument |
| MAE/MFE | Maximum Adverse Excursion / Maximum Favorable Excursion — tracks worst/best unrealized P&L during a trade |

### 12.2 Event Payload Examples

**`webhook.received` event (emitted to notification engine):**

```json
{
  "event_type": "webhook.received",
  "user_id": "usr_abc123",
  "timestamp": "2026-02-11T19:32:04Z",
  "correlation_id": "cor_wh_789",
  "payload": {
    "signal_id": "sig_abc123def456",
    "source_symbol": "ES1!",
    "mapped_symbol": "ESH26",
    "action": "buy",
    "price": 5205.25,
    "signal_source": "tradingview_webhook"
  }
}
```

**`webhook.error` event (emitted on unmapped symbol or validation failure):**

```json
{
  "event_type": "webhook.error",
  "user_id": "usr_abc123",
  "timestamp": "2026-02-11T19:32:04Z",
  "correlation_id": "cor_wh_790",
  "payload": {
    "error_type": "symbol_unmapped",
    "source_symbol": "CUSTOM1!",
    "raw_action": "buy",
    "message": "Symbol could not be mapped to a broker contract"
  }
}
```
