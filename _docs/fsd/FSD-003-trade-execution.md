# FSD-003: Trade Execution

**TrendEdge -- AI-Powered Futures Trading Platform**

| Field | Value |
|---|---|
| FSD ID | FSD-003 |
| Source PRD | PRD-003 |
| Title | Trade Execution |
| Version | 1.0 |
| Status | Draft |
| Author | Generated by Claude |
| Created | 2026-02-11 |

---

## 1. Introduction

### 1.1 Purpose

This Functional Specification Document translates PRD-003 (Trade Execution Pipeline & Broker Integration) into implementable behavioral specifications. Every requirement is decomposed into exact inputs, processing logic, outputs, error states, and edge cases so that a developer can build each component using only this document.

### 1.2 Scope

This FSD covers the complete trade execution pipeline:

- **Signal Ingestion**: Accepting trade signals from three sources (internal trendline engine, TradingView webhooks, manual dashboard entry) and normalizing them into a canonical format.
- **Signal Validation & Enrichment**: Authenticating, validating instrument/price data, deduplicating, and enriching signals with contract specs and market context.
- **Risk Management Engine**: Pre-trade, in-trade, and post-trade risk controls with configurable parameters and full audit trails.
- **Order Construction**: Building bracket orders (entry + stop loss + take profit as OCO groups) with quantity calculation and metadata attachment.
- **Broker Adapters**: Abstract interface and concrete implementations for IBKR (TWS API via ib_async), Tradovate (REST + WebSocket), and future Webull support.
- **Paper Trading Simulator**: Simulated fills with configurable slippage, separate P&L tracking, and paper-to-live transition enforcement.
- **Position & Order Lifecycle Management**: Real-time position tracking, order state machine, OCO group management, and fill reconciliation.
- **Continuous Contract Symbol Mapping**: TradingView continuous symbols to specific contract months with rollover management.
- **Circuit Breaker & Resilience**: Consecutive failure detection, health check monitoring, and graceful degradation during broker outages.
- **Manual Overrides**: Order cancellation, modification, position close, and emergency flatten-all.

### 1.3 Out of Scope

- Trendline detection engine internals [Cross-reference: see FSD-002 for trendline detection details]
- Trade journal entry content and UI [Cross-reference: see FSD-004 for trade journaling]
- Analytics and playbook computation [Cross-reference: see FSD-005 for analytics]
- Notification delivery mechanisms [Cross-reference: see FSD-008 for notifications]
- User authentication and authorization [Cross-reference: see FSD-009 for auth & multi-tenancy]
- Market data feed infrastructure [Cross-reference: see FSD-010 for market data]

### 1.4 Glossary

| Term | Definition |
|---|---|
| Signal | A normalized trade intent containing instrument, direction, prices, and metadata. |
| Bracket Order | An entry order with attached stop loss and take profit orders linked as an OCO group. |
| OCO | One-Cancels-Other: when one order in the group fills, the other is automatically cancelled. |
| R-Multiple | Net P&L divided by planned risk per trade; 1R = risk amount, 2R = twice the risk amount. |
| MAE | Maximum Adverse Excursion: the worst unrealized loss during a trade's lifetime. |
| MFE | Maximum Favorable Excursion: the best unrealized profit during a trade's lifetime. |
| RTH | Regular Trading Hours (e.g., 9:30 AM - 4:00 PM ET for equity index futures). |
| ETH | Extended Trading Hours (outside RTH, typically overnight session). |
| Circuit Breaker | A mechanism that halts order submission after consecutive broker failures. |
| Safety Line | The opposing trendline projected forward, used as a stop loss reference point. |
| Slippage | The difference between the intended order price and the actual fill price. |
| Front Month | The nearest expiring actively-traded futures contract. |

---

## 2. System Context

### 2.1 System Context Diagram

```
                    +------------------+
                    | TradingView      |
                    | (Webhook POST)   |
                    +--------+---------+
                             |
                             v
+------------------+   +-----------+   +------------------+
| Trendline Engine |-->|           |   | Dashboard UI     |
| (PRD-002)        |   | TrendEdge |<--| (Manual Entry)   |
| Internal Signals |   | Execution |   | (PRD-006)        |
+------------------+   | Pipeline  |   +------------------+
                        |           |
                        +-----+-----+
                              |
              +---------------+---------------+
              |               |               |
              v               v               v
       +------+------+ +-----+------+ +------+------+
       | IBKR        | | Tradovate  | | Paper       |
       | Adapter     | | Adapter    | | Simulator   |
       | (TWS API)   | | (REST+WS)  | |             |
       +------+------+ +-----+------+ +------+------+
              |               |               |
              v               v               v
       +------+------+ +-----+------+ +------+------+
       | IB Gateway  | | Tradovate  | | Internal    |
       | (VPS)       | | API        | | Ledger      |
       +-------------+ +------------+ +-------------+

              |               |               |
              +-------+-------+-------+-------+
                      |               |
                      v               v
              +-------+------+ +-----+--------+
              | Journal      | | Analytics    |
              | (PRD-004)    | | (PRD-005)    |
              +--------------+ +--------------+
```

### 2.2 Data Flow Overview

1. **Signal Receipt**: Signal arrives from one of three sources (internal engine via Redis pub/sub, TradingView webhook via HTTP POST, or manual entry via dashboard API).
2. **Normalization**: Raw signal is parsed and normalized into the canonical `Signal` data structure.
3. **Authentication**: Signal source is authenticated (API key, HMAC signature, session token, or internal process verification).
4. **Validation**: Instrument, prices, and signal freshness are validated.
5. **Enrichment**: Signal is enriched with contract specifications, computed fields (R:R ratio, risk in dollars), market context, and account context.
6. **Deduplication**: Signal is checked against recent signals; duplicates are rejected.
7. **Risk Checks**: Signal passes through all pre-trade risk checks (position size, daily loss, concurrent positions, R:R minimum, correlation).
8. **Order Construction**: Bracket order is built (entry + SL + TP) with computed quantity.
9. **Broker Routing**: Order is routed to the appropriate broker adapter (or paper simulator).
10. **Execution**: Broker adapter submits the order and monitors for fills.
11. **Post-Fill Processing**: Fill details are recorded, slippage is calculated, position is updated, journal entry is created, and analytics events are emitted.

### 2.3 External Dependencies

| Dependency | Type | Description |
|---|---|---|
| PostgreSQL | Hard | Primary data store for signals, orders, positions, risk audit. [Cross-reference: see FSD-001 for database infrastructure] |
| Redis | Hard | Pub/sub for internal signals, rate limiting (sliding window), deduplication cache, circuit breaker state. [Cross-reference: see FSD-001] |
| IB Gateway | Hard (IBKR) | TWS API socket server running on the application VPS. Required for IBKR live/paper trading. |
| Tradovate API | Hard (Tradovate) | REST API + WebSocket for order submission and real-time updates. |
| TradingView | Soft | External webhook source. TrendEdge has no control over TradingView's delivery latency. |
| Notification Service | Soft | Delivers alerts for broker failures, fill notifications, circuit breaker trips. [Cross-reference: see FSD-008] |

---

## 3. Functional Specifications

### 3.1 EX-FR-001: Internal Signal Source

**Source**: PRD-003 Section 3.1, US-EX-001

**Description**: The system accepts signals from the trendline detection engine via an internal message bus (Redis pub/sub channel or direct async function call). These signals carry full trendline metadata that enriches downstream journaling and analytics.

**Inputs**:

| Field | Type | Required | Description |
|---|---|---|---|
| instrument | string | Yes | Futures symbol (e.g., "MNQ", "MES") |
| direction | enum | Yes | `LONG` or `SHORT` |
| entry_price | Decimal | Yes | Price at which the trendline break was detected |
| stop_loss_price | Decimal | Yes | Safety line price (opposing trendline projected +4 candles) |
| take_profit_price | Decimal | Yes | First S/R level providing >= 2R reward |
| trendline_id | UUID | Yes | Reference to the trendline that generated this signal |
| trendline_grade | string | Yes | Grade of the trendline (e.g., "A+", "A", "B+", "B") |
| touch_count | integer | Yes | Number of times price touched the trendline |
| signal_timestamp | datetime | Yes | When the trendline break was detected |
| confidence_score | Decimal | Yes | Engine confidence score (0.0 to 1.0) |
| candle_spacing | string | No | Timeframe of the trendline (e.g., "5m", "15m", "1h", "4h") |
| slope | Decimal | No | Trendline slope value |
| duration_candles | integer | No | Number of candles the trendline spans |

**Processing Logic**:

1. Subscribe to Redis channel `trendedge:signals:internal` on application startup.
2. When a message is received, deserialize the JSON payload.
3. Validate that all required fields are present. If any required field is missing, log `ERROR: Internal signal missing required field '{field_name}'. Signal discarded. Payload: {truncated_payload}` and discard the signal.
4. Verify the signal originates from an authenticated trendline engine process by checking the `process_auth_token` field against the configured internal service token stored in environment variable `INTERNAL_SERVICE_TOKEN`. If the token is missing or does not match, log `SECURITY: Unauthorized internal signal attempt. Token: {masked_token}` and discard.
5. Create a `Signal` record with `source = 'INTERNAL'` and `status = 'RECEIVED'`.
6. Store the full raw payload in `source_metadata` as JSON.
7. Pass the Signal to the normalization pipeline (EX-FR-004).

**Outputs**:
- A persisted `Signal` record with `status = 'RECEIVED'` and `source = 'INTERNAL'`.
- Signal ID returned to the internal message bus as acknowledgment.

**Business Rules**:
- Internal signals are trusted at a higher level than webhook signals but still must pass all validation and risk checks.
- Internal signals always include trendline metadata; this metadata is preserved through the entire pipeline for journaling.
- The entry_type for internal signals defaults to `MARKET` unless the trendline engine explicitly specifies `LIMIT`.

**Error Handling**:

| Error Condition | System Behavior | Log Level |
|---|---|---|
| Redis pub/sub connection lost | Attempt reconnection with exponential backoff (1s, 2s, 4s, 8s, 16s, 32s, max 60s). Queue is maintained by Redis; messages published during reconnection will be lost unless Redis Streams are used. | ERROR |
| Malformed JSON payload | Discard signal. Log raw payload (truncated to 1000 chars). | ERROR |
| Missing required field | Discard signal. Log field name and signal payload. | ERROR |
| Invalid process auth token | Discard signal. Log attempt with masked token. | SECURITY |
| Database write failure | Retry 3 times with 1s delay. If all retries fail, log and discard. | CRITICAL |

**Edge Cases**:
- If the trendline engine publishes the same signal twice (e.g., due to a restart), the deduplication check (EX-FR-015) will catch it downstream.
- If the trendline engine sends a signal with a `trendline_id` that does not exist in the database, the signal is still processed (the trendline_id is stored as metadata but not validated via foreign key at signal receipt time; validation occurs during enrichment).

---

### 3.2 EX-FR-002: TradingView Webhook Signal Source

**Source**: PRD-003 Section 3.2, US-EX-002

**Description**: The system accepts TradingView alert webhooks via a unique per-user HTTP POST endpoint. Each user receives a unique webhook URL containing a cryptographically random identifier.

**Inputs**:

HTTP Request:
- Method: `POST`
- URL: `/api/v1/webhooks/tradingview/{user_webhook_id}`
- Content-Type: `application/json`
- Optional Header: `X-Signature` (HMAC-SHA256 signature)

JSON Body (primary format):

| Field | Type | Required | Alternatives | Description |
|---|---|---|---|---|
| key | string | Conditional | `api_key` | User API key (required if HMAC not used) |
| ticker | string | Yes | `symbol` | TradingView symbol (e.g., "NQ1!", "ES1!") |
| action | string | Yes | `side`, `order` | Trade direction: "buy", "sell", "close" |
| price | number | Yes | -- | Current price or entry price |
| stop | number | No | `sl` | Stop loss price |
| target | number | No | `tp` | Take profit price |
| quantity | integer | No | `qty`, `contracts` | Number of contracts (default: calculated by risk engine) |
| timeframe | string | No | -- | Chart timeframe (e.g., "240" for 4h) |
| message | string | No | -- | Free-text alert message |
| timestamp | string | No | -- | ISO 8601 timestamp of the alert |

**Processing Logic**:

1. Receive HTTP POST request at `/api/v1/webhooks/tradingview/{user_webhook_id}`.
2. Rate limit check (EX-FR-009): query Redis key `ratelimit:webhook:{user_webhook_id}` using sliding window. If over limit, return HTTP 429.
3. Look up `user_webhook_id` in the `webhook_urls` table. If not found, return HTTP 404 with body `{"error": "Webhook URL not found"}`.
4. Authenticate the request (EX-FR-006):
   a. If `X-Signature` header is present, compute HMAC-SHA256 of the raw request body using the user's webhook secret. Compare using `hmac.compare_digest()`. If mismatch, return HTTP 401 with body `{"error": "Invalid signature"}`.
   b. Else if `key` or `api_key` field is present in the body, hash the provided key with SHA-256 and compare against the stored hash. If mismatch, return HTTP 401 with body `{"error": "Invalid API key"}`.
   c. Else, the webhook URL path itself serves as minimum authentication (the 32+ character random ID acts as a shared secret).
5. Parse the JSON body. Handle alternative field names: map `symbol` to `ticker`, `side`/`order` to `action`, `sl` to `stop`, `tp` to `target`, `qty`/`contracts` to `quantity`.
6. Validate required fields (`ticker`, `action`, `price`). If missing, return HTTP 400 with body `{"error": "Missing required field: {field_name}"}`.
7. Validate `action` value: must be one of `buy`, `sell`, `close` (case-insensitive). If invalid, return HTTP 400 with body `{"error": "Invalid action '{value}'. Must be 'buy', 'sell', or 'close'"}`.
8. Check replay attack prevention (EX-SEC-006): if `timestamp` is present and older than 5 minutes, return HTTP 400 with body `{"error": "Request timestamp too old. Maximum age: 5 minutes"}`. Check Redis set `webhook:processed:{user_webhook_id}` for the request body hash; if found, return HTTP 400 with body `{"error": "Duplicate request detected"}`.
9. Create a `Signal` record with `source = 'WEBHOOK'` and `status = 'RECEIVED'`. Store the entire raw JSON payload (including unrecognized fields) in `source_metadata`.
10. Return HTTP 200 immediately with body: `{"signal_id": "{uuid}", "status": "received", "message": "Signal accepted for processing"}`.
11. Continue processing asynchronously: pass the Signal to the normalization pipeline (EX-FR-004) via an async task (Celery task or asyncio background task).

**Outputs**:
- HTTP 200 response with signal_id (synchronous, within 2 seconds).
- Persisted `Signal` record with `status = 'RECEIVED'` and `source = 'WEBHOOK'`.

**Business Rules**:
- The HTTP 200 response must be returned within 2 seconds regardless of downstream processing time. TradingView will retry if it does not receive a response within its timeout window.
- The `close` action maps to closing an existing open position in the specified instrument. If no open position exists, the signal is rejected during validation with reason `NO_OPEN_POSITION_TO_CLOSE`.
- Unrecognized fields in the JSON body are preserved in `source_metadata` for journaling purposes. They are never rejected.
- The `price` field from TradingView represents the price at the time the alert fired, not necessarily the desired entry price. For market orders, this serves as the reference price for slippage calculation.

**Error Handling**:

| HTTP Status | Condition | Response Body |
|---|---|---|
| 200 | Valid signal accepted | `{"signal_id": "uuid", "status": "received", "message": "Signal accepted for processing"}` |
| 400 | Missing required field | `{"error": "Missing required field: {field_name}"}` |
| 400 | Invalid action value | `{"error": "Invalid action '{value}'. Must be 'buy', 'sell', or 'close'"}` |
| 400 | Stale timestamp | `{"error": "Request timestamp too old. Maximum age: 5 minutes"}` |
| 400 | Duplicate request | `{"error": "Duplicate request detected"}` |
| 400 | Malformed JSON | `{"error": "Invalid JSON in request body"}` |
| 401 | Invalid API key | `{"error": "Invalid API key"}` |
| 401 | Invalid HMAC signature | `{"error": "Invalid signature"}` |
| 404 | Unknown webhook URL | `{"error": "Webhook URL not found"}` |
| 429 | Rate limit exceeded | `{"error": "Rate limit exceeded. Maximum 10 requests per minute", "retry_after": {seconds}}` |
| 500 | Internal server error | `{"error": "Internal server error. Signal may not have been processed. Please check status."}` |

**Edge Cases**:
- TradingView sends the same alert multiple times (due to bar close recalculation): deduplication (EX-FR-015) catches this.
- TradingView sends an alert with `price: 0` or `price: null`: rejected by price validation (EX-FR-013).
- TradingView sends an alert for an instrument TrendEdge does not support (e.g., forex): rejected by instrument validation (EX-FR-011).
- Request body exceeds 64 KB: reject with HTTP 413 `{"error": "Request body too large. Maximum size: 64 KB"}`.
- Non-JSON content type: reject with HTTP 415 `{"error": "Content-Type must be application/json"}`.

---

### 3.3 EX-FR-003: Manual Signal Source

**Source**: PRD-003 Section 3.1, US-EX-003

**Description**: The dashboard provides a form for manual signal entry. The form validates all inputs client-side and server-side before creating a signal.

**Inputs**:

| Field | Type | Required | Validation | Default |
|---|---|---|---|---|
| instrument | string | Yes | Must be in supported instruments list. Searchable dropdown. | -- |
| direction | enum | Yes | `LONG` or `SHORT` | -- |
| entry_type | enum | Yes | `MARKET` or `LIMIT` | `MARKET` |
| entry_price | Decimal | Conditional | Required for LIMIT orders. Pre-filled with last price for MARKET orders. Must be > 0. | Last market price |
| stop_loss_price | Decimal | No | If provided, must be on correct side of entry. | -- |
| take_profit_price | Decimal | No | If provided, must be on correct side of entry. | -- |
| quantity | integer | No | Must be >= 1 and <= max position size. | Calculated by risk engine |
| notes | string | No | Max 500 characters. | -- |

**Processing Logic**:

1. User submits the form via `POST /api/v1/signals/manual`.
2. Authenticate the user via session token (Bearer token in Authorization header). If invalid, return HTTP 401 `{"error": "Authentication required"}`.
3. Validate all inputs server-side (never trust client-side validation alone):
   a. `instrument`: must exist in the `supported_instruments` reference table. If not found, return HTTP 400 `{"error": "Unsupported instrument '{value}'. See /api/v1/instruments for supported instruments."}`.
   b. `direction`: must be `LONG` or `SHORT`. If invalid, return HTTP 400 `{"error": "Direction must be 'LONG' or 'SHORT'"}`.
   c. `entry_type`: must be `MARKET` or `LIMIT`. If invalid, return HTTP 400 `{"error": "Entry type must be 'MARKET' or 'LIMIT'"}`.
   d. `entry_price`: for LIMIT orders, must be provided and > 0. If missing for LIMIT, return HTTP 400 `{"error": "Entry price is required for LIMIT orders"}`.
   e. `stop_loss_price`: if provided, validated in EX-FR-013.
   f. `take_profit_price`: if provided, validated in EX-FR-013.
   g. `quantity`: if provided, must be integer >= 1 and <= the user's max position size for this instrument.
   h. `notes`: if provided, must be <= 500 characters.
4. Create a `Signal` record with `source = 'MANUAL'` and `status = 'RECEIVED'`.
5. Return HTTP 201 with body: `{"signal_id": "{uuid}", "status": "received", "message": "Manual signal submitted for processing"}`.
6. Process the signal synchronously (manual signals are user-initiated and the user expects immediate feedback). The response may alternatively be returned after validation and risk checks complete, with the signal status reflecting the outcome.

**Outputs**:
- HTTP 201 response with signal_id.
- Persisted `Signal` record.

**Business Rules**:
- Manual signals do NOT carry trendline metadata (`trendline_id` and `trendline_grade` are null).
- If stop_loss_price and take_profit_price are both omitted, the signal is accepted but flagged with a warning: "No stop loss or take profit specified. Consider adding risk levels." The warning is returned in the response and displayed on the dashboard. The signal proceeds through the pipeline; the risk check for minimum R:R (EX-FR-019) will reject it if R:R cannot be calculated.
- Manual signals are NOT subject to the signal staleness check (EX-RM-008) since they are submitted in real-time by the user.

**Error Handling**:

| HTTP Status | Condition | Response Body |
|---|---|---|
| 201 | Signal accepted | `{"signal_id": "uuid", "status": "received", "message": "Manual signal submitted for processing"}` |
| 400 | Validation failure | `{"error": "{specific validation message}", "field": "{field_name}"}` |
| 401 | Not authenticated | `{"error": "Authentication required"}` |
| 403 | Account suspended | `{"error": "Your account is suspended. Contact support."}` |
| 429 | Manual submission rate limit | `{"error": "Too many manual signals. Maximum 5 per minute."}` |

**Edge Cases**:
- User submits a MARKET order during a market holiday or weekend: the order is constructed but the broker will reject it. The rejection is captured and the user is notified.
- User submits a LIMIT order with an entry price very far from the current market (>5% tolerance): rejected by price validation (EX-FR-013) with message `"Entry price {price} is more than 5% from current market price {market_price} for {instrument}"`.

---

### 3.4 EX-FR-004: Signal Normalization

**Source**: PRD-003 Section 3.1

**Description**: All signals, regardless of source, are normalized into a canonical `Signal` data structure before entering the validation pipeline.

**Inputs**: Raw signal data from any of the three sources (internal, webhook, manual).

**Processing Logic**:

1. Map source-specific fields to canonical fields:
   - **Webhook**: `ticker` -> `instrument` (after symbol mapping), `action` -> `direction` (`buy` -> `LONG`, `sell` -> `SHORT`), `stop` -> `stop_loss_price`, `target` -> `take_profit_price`.
   - **Internal**: Fields already match canonical names. Confirm `direction` is uppercase enum.
   - **Manual**: Fields submitted via API already use canonical names.
2. Assign a UUID `id` to the signal if not already assigned.
3. Set `user_id` from the authenticated context.
4. Set `entry_type` to `MARKET` if not specified.
5. Set `quantity` to `null` if not specified (will be calculated in EX-FR-026).
6. Compute `risk_reward_ratio` if both `stop_loss_price` and `take_profit_price` are provided:
   - For LONG: `rr = (take_profit_price - entry_price) / (entry_price - stop_loss_price)`
   - For SHORT: `rr = (entry_price - take_profit_price) / (stop_loss_price - entry_price)`
   - Store as Decimal with 2 decimal places.
7. Set `status` to `RECEIVED`.
8. Set `created_at` to current UTC timestamp.
9. Set `is_paper` based on the user's current trading mode.
10. Persist the Signal record to the `signals` table.
11. Pass the normalized signal to validation (EX-FR-010 through EX-FR-015).

**Outputs**: A fully populated `Signal` record in the database with `status = 'RECEIVED'`.

**Business Rules**:
- The `close` action from webhooks is handled specially: direction is set to the opposite of the current open position's direction. If the user has a LONG position in the instrument, `close` maps to `SHORT` (and vice versa). If no open position exists, the signal is rejected during validation.
- The `risk_reward_ratio` field is computed but not enforced at this stage; enforcement happens in EX-FR-019.

**Error Handling**:

| Error Condition | Behavior |
|---|---|
| Cannot determine direction from webhook `action` field | Reject signal with `status = 'REJECTED'`, `rejection_reason = "Cannot determine direction from action '{value}'"` |
| Division by zero in R:R calculation (entry == stop) | Set `risk_reward_ratio = null`, log warning. Signal proceeds; EX-FR-013 will reject based on stop distance < 1 tick. |

---

### 3.5 EX-FR-005: Unique Webhook URL Generation

**Source**: PRD-003 Section 3.2

**Description**: Each user receives a unique webhook URL with a cryptographically random identifier. Users can regenerate their URL at any time.

**Inputs**:
- Trigger: user registration, first broker connection, or explicit regeneration request.

**Processing Logic**:

1. Generate a webhook ID using `secrets.token_urlsafe(32)` (produces a 43-character URL-safe base64 string with 256 bits of entropy).
2. Store in `webhook_urls` table: `user_id`, `webhook_id`, `created_at`, `is_active = true`.
3. If regenerating, set the previous webhook URL's `is_active = false` and `deactivated_at = NOW()`. The old URL is immediately invalid.
4. Construct the full URL: `https://{domain}/api/v1/webhooks/tradingview/{webhook_id}`.
5. Return the URL to the user via the dashboard or API response.

**Outputs**:
- Full webhook URL displayed to the user (shown once, copyable).
- Stored record in `webhook_urls` table.

**Business Rules**:
- The webhook ID is NOT the user's UUID. It is a separate, opaque identifier.
- Only one webhook URL per user is active at a time. Regenerating invalidates the previous URL immediately.
- Deactivated webhook URLs are retained in the database for audit purposes (with `is_active = false`).
- The webhook URL is displayed in the dashboard settings page with a "Copy" button and a "Regenerate" button.
- Regeneration requires re-authentication (password or 2FA confirmation).

**Error Handling**:

| Error Condition | Behavior |
|---|---|
| Collision in webhook_id (astronomically unlikely with 256 bits) | Retry generation up to 3 times. If collision persists (should never happen), log CRITICAL error and return HTTP 500. |

---

### 3.6 EX-FR-006: Webhook Authentication

**Source**: PRD-003 Section 3.2

**Description**: Each webhook request is authenticated using one of three methods in priority order: HMAC signature, API key in payload, or webhook URL path validation.

**Processing Logic**:

1. **HMAC Signature** (highest security): If the `X-Signature` header is present:
   a. Retrieve the user's webhook secret from the database (looked up via the webhook URL's user_id).
   b. Compute the expected signature: `hmac.new(user_secret.encode(), request_body_bytes, hashlib.sha256).hexdigest()`.
   c. Compare using `hmac.compare_digest(expected_signature, provided_signature)` (constant-time comparison to prevent timing attacks).
   d. If match: authentication succeeds.
   e. If no match: return HTTP 401 `{"error": "Invalid signature"}`. Log: `SECURITY: HMAC validation failed for webhook {webhook_id}. IP: {client_ip}`.

2. **API Key in Payload** (medium security): If no `X-Signature` header but `key` or `api_key` field exists in the JSON body:
   a. Hash the provided key: `hashlib.sha256(provided_key.encode()).hexdigest()`.
   b. Compare the hash against the stored API key hash for the user.
   c. If match: authentication succeeds.
   d. If no match: return HTTP 401 `{"error": "Invalid API key"}`. Log: `SECURITY: API key validation failed for webhook {webhook_id}. IP: {client_ip}`.

3. **Webhook URL Path** (minimum security): If neither HMAC signature nor API key is present:
   a. The 32+ character random webhook ID in the URL path serves as a shared secret.
   b. If the webhook_id exists and is active: authentication succeeds.
   c. This is the minimum acceptable security level.

**Business Rules**:
- All failed authentication attempts are logged with the client IP address, webhook_id, and timestamp.
- After 10 failed authentication attempts within 1 hour for the same webhook_id, the webhook URL is temporarily suspended for 1 hour. The user is notified via email/Telegram.
- The user's webhook secret (for HMAC) is generated alongside the webhook URL and displayed once. It can be regenerated independently of the URL.

---

### 3.7 EX-FR-007 through EX-FR-009: Webhook Payload Parsing, Response, and Rate Limiting

**Source**: PRD-003 Section 3.2

**EX-FR-007 Payload Parsing**: Covered in EX-FR-002 processing logic steps 5-6. Alternative field names are mapped during normalization.

**EX-FR-008 Webhook Response**: Covered in EX-FR-002 processing logic step 10. The HTTP 200 response with `signal_id`, `status`, and `message` is returned within 2 seconds. Processing continues asynchronously.

**EX-FR-009 Rate Limiting**:

**Processing Logic**:

1. On each webhook request, check the Redis sliding window counter for the webhook URL:
   - Key: `ratelimit:webhook:{webhook_id}:minute` -- max 10 requests per 60-second window.
   - Key: `ratelimit:webhook:{webhook_id}:hour` -- max 100 requests per 3600-second window.
2. Implementation uses Redis sorted sets with timestamps as scores:
   a. `ZREMRANGEBYSCORE` to remove entries older than the window.
   b. `ZCARD` to count remaining entries.
   c. If count >= limit, return HTTP 429.
   d. Otherwise, `ZADD` the current timestamp and set TTL on the key to window_size + 1 second.
3. The `Retry-After` header is set to the number of seconds until the oldest entry in the window expires.

**Outputs**:
- HTTP 429 response when rate limit exceeded: `{"error": "Rate limit exceeded. Maximum 10 requests per minute", "retry_after": {seconds}}`.
- `Retry-After` header with seconds until the rate limit resets.

**Edge Cases**:
- If Redis is unavailable for rate limiting, the system SHALL allow the request through (fail-open for rate limiting) and log a warning. Rate limiting is a protective measure; failing closed would block legitimate signals.

---

### 3.8 EX-FR-010: Signal Authentication Validation

**Source**: PRD-003 Section 3.3

**Description**: Validates that each signal comes from an authenticated source appropriate to its type.

**Processing Logic**:

| Signal Source | Authentication Method | Validation |
|---|---|---|
| WEBHOOK | API key or HMAC signature | Already validated at HTTP endpoint (EX-FR-006). Double-check that `signal.user_id` matches the webhook URL's owner. |
| INTERNAL | Process auth token | Verify `process_auth_token` matches `INTERNAL_SERVICE_TOKEN` env var. Already validated at receipt (EX-FR-001). |
| MANUAL | Session token | Verify the Bearer token in the Authorization header is valid and not expired. Already validated at API endpoint (EX-FR-003). |

**Business Rules**:
- Authentication validation at this stage is a defense-in-depth check. Primary authentication occurs at the ingestion point.
- If authentication fails at this stage (should not happen in normal operation), the signal status is set to `REJECTED` with `rejection_reason = "Authentication failed at validation stage"` and a SECURITY-level log entry is created.

---

### 3.9 EX-FR-011: Instrument Validation

**Source**: PRD-003 Section 3.3

**Description**: Validates that the signal's instrument symbol maps to a supported futures contract.

**Processing Logic**:

1. Look up the instrument in the `supported_instruments` reference table.
2. If the instrument is a TradingView continuous contract symbol (e.g., "NQ1!", "ES1!"), map it to the specific contract month using EX-FR-012.
3. If the instrument is a generic TrendEdge symbol (e.g., "MNQ", "MES"), resolve it to the current front-month contract.
4. If the instrument cannot be resolved, reject the signal.

**Supported Instruments** (initial set):

| Symbol | Exchange | Full Name |
|---|---|---|
| MNQ | CME | Micro E-mini Nasdaq-100 |
| MES | CME | Micro E-mini S&P 500 |
| MYM | CBOT | Micro E-mini Dow Jones |
| M2K | CME | Micro E-mini Russell 2000 |
| MGC | COMEX | Micro Gold |
| MCL | NYMEX | Micro WTI Crude Oil |
| SIL | COMEX | Micro Silver |
| NQ | CME | E-mini Nasdaq-100 |
| ES | CME | E-mini S&P 500 |

**Error Handling**:

| Error | Signal Status | Rejection Reason |
|---|---|---|
| Instrument not in supported list | REJECTED | `"Unsupported instrument '{symbol}'. Supported instruments: MNQ, MES, MYM, M2K, MGC, MCL, SIL, NQ, ES"` |
| Expired contract month | REJECTED | `"Contract {symbol} has expired. Current front month is {front_month}"` |

---

### 3.10 EX-FR-012: Continuous Contract Symbol Mapping

**Source**: PRD-003 Section 3.3

**Description**: Maps TradingView continuous contract symbols (e.g., "NQ1!") to specific contract months based on rollover schedules and user preference for micro vs. full-size.

**Processing Logic**:

1. Receive a TradingView continuous symbol (e.g., "NQ1!").
2. Determine whether the user prefers micro or full-size contracts (stored in user settings, default: micro).
3. Look up the symbol mapping:

| TV Symbol | Micro Instrument | Full-Size Instrument |
|---|---|---|
| NQ1! | MNQ | NQ |
| ES1! | MES | ES |
| YM1! | MYM | YM |
| RTY1! | M2K | RTY |
| GC1! | MGC | GC |
| CL1! | MCL | CL |
| SI1! | SIL | SI |

4. Determine the current front-month contract:
   a. Query the `contract_calendar` table for the instrument family.
   b. The front month is the nearest contract whose expiration date is more than `rollover_days_before_expiry` business days in the future (default: 3 business days).
   c. If within the rollover window, map to the next month contract.
5. Construct the specific contract symbol: `{instrument}{month_code}{year_digit}` (e.g., "MNQH6" for Micro Nasdaq March 2026).

**Outputs**: The resolved specific contract symbol (e.g., "MNQH6") replaces the continuous symbol in the Signal record.

**Business Rules**:
- The rollover schedule is configurable per instrument family. Default: roll 3 business days before the contract's First Notice Day (for physically delivered) or Last Trading Day (for cash-settled).
- When a rollover occurs, all users with active webhook configurations receive a notification: "Symbol mapping has rolled from {old_contract} to {new_contract}".
- Users can override the automatic mapping by specifying exact contract symbols in their signals (e.g., "MNQH6" instead of "NQ1!").

**Edge Cases**:
- Signal arrives exactly on the rollover boundary (within the 3-day window): the signal maps to the new (next) contract month.
- User sends a signal for a back-month contract that TrendEdge does not track: rejected with `"Contract month {month} for {instrument} is not currently tracked. Front month is {front_month}"`.

---

### 3.11 EX-FR-013: Price Validation

**Source**: PRD-003 Section 3.3

**Description**: Validates that entry price, stop loss, and take profit are logically consistent and within market tolerance.

**Processing Logic**:

1. **Entry price tolerance**: Verify that `entry_price` is within 5% of the current market price for the instrument. The tolerance is configurable per user (stored in user settings).
   - Current market price is retrieved from the market data cache (Redis key `market:price:{instrument}`).
   - If market data is unavailable, skip this check and log a warning. The check is advisory; the broker will ultimately validate the price.
   - Validation: `abs(entry_price - market_price) / market_price <= tolerance`.
   - Failure message: `"Entry price {entry_price} is more than {tolerance*100}% from current market price {market_price} for {instrument}"`.

2. **Stop loss side validation**:
   - For LONG: `stop_loss_price < entry_price`. If violated: `"Stop loss ({stop_loss_price}) must be below entry price ({entry_price}) for LONG positions"`.
   - For SHORT: `stop_loss_price > entry_price`. If violated: `"Stop loss ({stop_loss_price}) must be above entry price ({entry_price}) for SHORT positions"`.

3. **Take profit side validation**:
   - For LONG: `take_profit_price > entry_price`. If violated: `"Take profit ({take_profit_price}) must be above entry price ({entry_price}) for LONG positions"`.
   - For SHORT: `take_profit_price < entry_price`. If violated: `"Take profit ({take_profit_price}) must be below entry price ({entry_price}) for SHORT positions"`.

4. **Minimum stop distance**: The stop distance must be at least 1 tick:
   - `stop_distance = abs(entry_price - stop_loss_price)`
   - Retrieve `tick_size` from the contract specification for the instrument.
   - If `stop_distance < tick_size`: `"Stop distance ({stop_distance}) must be at least 1 tick ({tick_size}) for {instrument}"`.

5. **Risk-reward ratio**: If both stop and target are provided, compute R:R and verify it meets the user's minimum (default 2.0). This is enforced later in EX-FR-019 but computed here for enrichment.

**Outputs**: Signal status updated to `VALIDATED` if all checks pass. If any check fails, status is set to `REJECTED` with the specific rejection reason.

**Edge Cases**:
- Stop loss price equals entry price: rejected (stop distance is 0, which is less than 1 tick).
- Take profit price equals entry price: rejected (target distance is 0; R:R would be 0).
- Both stop and target are missing (manual signal): signal proceeds with a warning; R:R cannot be computed. The R:R risk check (EX-FR-019) will reject unless the user has set minimum R:R to 0.

---

### 3.12 EX-FR-014: Signal Enrichment

**Source**: PRD-003 Section 3.3

**Description**: Enriches validated signals with contract specifications, computed risk fields, market context, and account context.

**Processing Logic**:

1. **Contract specification enrichment**: Look up the instrument in the `contract_specifications` table and attach:
   - `tick_size`: e.g., 0.25 for MNQ
   - `tick_value`: e.g., $0.50 for MNQ
   - `notional_value_per_contract`: current price * point value
   - `margin_requirement`: day trading margin for the instrument
   - `exchange`: e.g., "CME"

2. **Computed fields**:
   - `stop_distance_ticks = abs(entry_price - stop_loss_price) / tick_size`
   - `target_distance_ticks = abs(take_profit_price - entry_price) / tick_size`
   - `risk_per_contract = stop_distance_ticks * tick_value`
   - `reward_per_contract = target_distance_ticks * tick_value`
   - `risk_reward_ratio = reward_per_contract / risk_per_contract` (if risk_per_contract > 0)

3. **Market context**:
   - `session`: Determine if current time is RTH or ETH based on the instrument's exchange hours.
   - `day_of_week`: Monday through Friday (1-5).
   - `time_to_next_session_boundary`: minutes until RTH open/close.

4. **Trendline metadata** (if source is INTERNAL):
   - Already attached during signal creation (EX-FR-001). Verify `trendline_id`, `trendline_grade`, `touch_count`, `slope`, `duration_candles`, and `candle_spacing` are present.

5. **Account context**:
   - `current_position_same_instrument`: query `positions` table for OPEN positions in the same instrument for this user.
   - `current_daily_pnl`: sum of realized P&L for today's closed trades plus unrealized P&L for open positions.
   - `current_open_position_count`: count of all OPEN positions for this user.

6. Store all enrichment data in a `signal_enrichment` JSONB column or related table.

**Outputs**: The Signal record is updated with enrichment data. Status remains `VALIDATED`.

---

### 3.13 EX-FR-015: Signal Deduplication

**Source**: PRD-003 Section 3.3

**Description**: Detects and rejects duplicate signals within a configurable deduplication window.

**Processing Logic**:

1. Construct a deduplication key: `dedup:{user_id}:{instrument}:{direction}`.
2. Query Redis for existing entries within the deduplication window (default: 5 minutes):
   - Key: `dedup:{user_id}:{instrument}:{direction}`
   - Value: `{signal_id}:{entry_price}:{timestamp}`
3. For each existing entry, check if the new signal's entry price is within the tolerance (default: 2 ticks):
   - `abs(new_entry_price - existing_entry_price) <= 2 * tick_size`
4. If a match is found:
   - Set signal status to `REJECTED`.
   - Set `rejection_reason = "DUPLICATE_SIGNAL"`.
   - Log: `INFO: Duplicate signal detected for user {user_id}, instrument {instrument}. Original signal: {original_signal_id}. Duplicate: {new_signal_id}`.
   - Return without further processing.
5. If no match: add the new signal to the Redis dedup set with TTL equal to the deduplication window.

**Business Rules**:
- The deduplication window is configurable per user (default: 5 minutes, range: 1-30 minutes).
- The price tolerance is configurable per user (default: 2 ticks, range: 0-10 ticks).
- Deduplication applies across all signal sources. A webhook signal and an internal signal for the same instrument/direction/price within the window are considered duplicates.
- The first signal is always the one that proceeds; subsequent duplicates are rejected.

---

### 3.14 EX-FR-016 through EX-FR-022: Risk Management Engine

**Source**: PRD-003 Section 3.4

#### EX-FR-016: Maximum Position Size Check

**Processing Logic**:

1. Retrieve the user's maximum position size for the signal's instrument from `user_risk_settings` (defaults: 2 for micro contracts, 1 for full-size contracts).
2. Query the `positions` table for OPEN positions in the same instrument for this user. Sum the quantities.
3. Check: `existing_quantity + proposed_quantity <= max_position_size`.
4. If the check fails:
   - Risk check result: `FAIL`.
   - Rejection reason: `"Maximum position size exceeded for {instrument}. Current: {existing_quantity}, Proposed: {proposed_quantity}, Maximum: {max_position_size}"`.
5. Log the check in `risk_check_audit`: signal_id, check_name=`MAX_POSITION_SIZE`, result, actual_value=`existing_quantity + proposed_quantity`, threshold_value=`max_position_size`.

#### EX-FR-017: Daily Loss Limit Check

**Processing Logic**:

1. Retrieve the user's daily loss limit from `user_risk_settings` (default: $500 for paper, user-defined for live).
2. Calculate current daily P&L:
   - Realized: sum of `realized_pnl` from `positions` table where `closed_at >= today_5pm_ct` (futures day boundary: 5:00 PM CT).
   - Unrealized: sum of `unrealized_pnl` from open positions.
   - Total daily P&L = realized + unrealized.
3. Calculate worst-case scenario: assume the stop is hit on all open positions AND the new proposed trade:
   - `worst_case_additional_loss = sum(risk_per_contract * quantity for each open position) + proposed_risk`.
   - `worst_case_daily_pnl = total_daily_pnl - worst_case_additional_loss`.
4. If `worst_case_daily_pnl < -daily_loss_limit`:
   - Risk check result: `FAIL`.
   - Rejection reason: `"Daily loss limit would be exceeded. Current daily P&L: ${total_daily_pnl}. Worst case with new trade: ${worst_case_daily_pnl}. Daily limit: -${daily_loss_limit}"`.
5. If `total_daily_pnl <= -daily_loss_limit` (already at/past limit):
   - Risk check result: `FAIL`.
   - Rejection reason: `"Daily loss limit reached. Current daily P&L: ${total_daily_pnl}. No further trades allowed until next trading day (5:00 PM CT reset)"`.
6. The daily loss counter resets at 5:00 PM CT daily (futures day boundary).

#### EX-FR-018: Maximum Concurrent Positions Check

**Processing Logic**:

1. Retrieve the user's max concurrent positions from `user_risk_settings` (default: 3).
2. Count positions in `positions` table with `status = 'OPEN'` for this user.
3. If `open_count >= max_concurrent_positions`:
   - Risk check result: `FAIL`.
   - Rejection reason: `"Maximum concurrent positions reached. Open: {open_count}, Maximum: {max_concurrent_positions}"`.

#### EX-FR-019: Minimum Risk-Reward Ratio Check

**Processing Logic**:

1. Retrieve the user's minimum R:R from `user_risk_settings` (default: 2.0).
2. Use the R:R calculated during enrichment (EX-FR-014).
3. If `risk_reward_ratio` is null (stop or target missing): if minimum R:R > 0, reject with `"Risk-reward ratio cannot be calculated. Stop loss and take profit are required when minimum R:R is set to {min_rr}"`.
4. If `risk_reward_ratio < min_rr`:
   - Risk check result: `FAIL`.
   - Rejection reason: `"Risk-reward ratio {risk_reward_ratio} is below minimum {min_rr}. Stop distance: {stop_distance} ticks, Target distance: {target_distance} ticks"`.

#### EX-FR-020: Correlation Limit Check

**Processing Logic**:

1. Retrieve the user's correlation settings: action (`warn` or `block`, default: `warn`) and threshold (default: 0.7).
2. Query open positions for this user.
3. For each open position, look up the correlation coefficient between the open position's instrument and the proposed signal's instrument in the `instrument_correlations` table.
4. Pre-configured correlation pairs:

| Instrument A | Instrument B | Correlation |
|---|---|---|
| MNQ | MES | 0.95 |
| MNQ | MYM | 0.88 |
| MNQ | M2K | 0.82 |
| MES | MYM | 0.92 |
| MES | M2K | 0.85 |
| MYM | M2K | 0.80 |
| NQ | MNQ | 1.00 |
| ES | MES | 1.00 |
| MGC | SIL | 0.75 |

5. If any correlation coefficient exceeds the threshold:
   - If action is `block`: risk check result `FAIL`, rejection reason `"Correlation limit exceeded. {instrument_a} and {instrument_b} have correlation {correlation}, threshold: {threshold}"`.
   - If action is `warn`: risk check result `WARN`. Signal proceeds but a warning is logged and displayed to the user: `"Warning: {instrument_a} and {instrument_b} are highly correlated ({correlation}). Consider the combined risk exposure."`.

#### EX-FR-021: Risk Check Audit Trail

Every risk check (EX-FR-016 through EX-FR-020, plus EX-RM-006 through EX-RM-008) is logged to the `risk_check_audit` table with: signal_id, check_name, result (PASS/FAIL/WARN), actual_value, threshold_value, details (JSONB with additional context), checked_at.

#### EX-FR-022: Risk Parameter Configuration

Users configure risk parameters via `PUT /api/v1/settings/risk`:

| Parameter | Field Name | Type | Default | Range |
|---|---|---|---|---|
| Max position size per instrument | max_position_size_micro | integer | 2 | 1-50 |
| Max position size (full-size) | max_position_size_full | integer | 1 | 1-10 |
| Daily loss limit | daily_loss_limit | Decimal | 500.00 | 50-100000 |
| Max concurrent positions | max_concurrent_positions | integer | 3 | 1-20 |
| Min R:R ratio | min_risk_reward_ratio | Decimal | 2.0 | 0-10.0 |
| Correlation action | correlation_action | enum | warn | warn, block |
| Correlation threshold | correlation_threshold | Decimal | 0.7 | 0.0-1.0 |
| Max single-trade risk | max_single_trade_risk | Decimal | 200.00 | 10-10000 |
| Trading hours | trading_hours | enum | RTH | RTH, ETH, 24H |
| Signal staleness | signal_staleness_minutes | integer | 5 | 1-30 |

Changes take effect immediately for new signals. Changes do NOT affect orders already submitted. All changes are logged in `risk_settings_changelog` with previous_value, new_value, changed_at, and user_id.

---

### 3.15 EX-FR-023 through EX-FR-027: Order Construction

**Source**: PRD-003 Section 3.5

#### EX-FR-023: Bracket Order Construction

**Processing Logic**:

1. For each signal that passes all risk checks, construct a bracket order group:
2. Generate a `bracket_group_id` (UUID) to link the three orders.
3. **Entry Order**:
   - `order_type`: `MARKET` or `LIMIT` (from signal `entry_type`).
   - `side`: `BUY` for LONG, `SELL` for SHORT.
   - `price`: for LIMIT orders, set to `signal.entry_price`. For MARKET, null.
   - `quantity`: from signal (or calculated by EX-FR-026).
   - `time_in_force`: configurable (default: `GTC`; options: `DAY`, `GTC`, `GTD`).
   - `bracket_role`: `ENTRY`.
   - `status`: `CONSTRUCTED`.
4. **Stop Loss Order**:
   - `order_type`: `STOP` (default stop-market) or `STOP_LIMIT` (user-configurable).
   - `side`: `SELL` for LONG (closing the position), `BUY` for SHORT.
   - `stop_price`: `signal.stop_loss_price`.
   - `price`: for `STOP_LIMIT`, set to `stop_price - (2 * tick_size)` for sells, `stop_price + (2 * tick_size)` for buys (2-tick limit offset from stop price).
   - `quantity`: same as entry.
   - `bracket_role`: `STOP_LOSS`.
   - `status`: `CONSTRUCTED`.
5. **Take Profit Order**:
   - `order_type`: `LIMIT`.
   - `side`: `SELL` for LONG, `BUY` for SHORT.
   - `price`: `signal.take_profit_price`.
   - `quantity`: same as entry.
   - `bracket_role`: `TAKE_PROFIT`.
   - `status`: `CONSTRUCTED`.
6. All three orders share the same `bracket_group_id`.
7. The stop loss and take profit are linked as an OCO pair: when one fills, the system cancels the other.
8. Persist all three orders to the `orders` table.
9. Update signal status to `EXECUTING`.

#### EX-FR-024: Safety Line Stop Loss Calculation

For internal engine signals:
1. The stop loss price is the safety line value provided in the signal payload (the opposing trendline projected forward by 4 candles).
2. If `safety_line_price` is null or missing, fall back to default stop distance:
   - Micro index futures (MNQ, MES, MYM, M2K): 20 ticks from entry.
   - Micro metals/energy (MGC, MCL, SIL): 10 ticks from entry.
3. Calculate fallback stop: for LONG, `entry_price - (default_ticks * tick_size)`. For SHORT, `entry_price + (default_ticks * tick_size)`.

#### EX-FR-025: Take Profit at Support/Resistance

For internal engine signals:
1. The signal payload includes an array of `candidate_sr_levels` (support/resistance prices from the trendline engine).
2. For each level, compute the reward: `abs(level - entry_price) / tick_size * tick_value`.
3. Compute the risk: `abs(entry_price - stop_loss_price) / tick_size * tick_value`.
4. Select the first level (closest to entry) that provides reward >= 2R.
5. If no qualifying level exists, use default: `take_profit_price = entry_price + (stop_distance * 2.5)` for LONG (inverted for SHORT).

#### EX-FR-026: Order Quantity Calculation

**Processing Logic** (when signal quantity is null):

1. Retrieve user's fixed risk per trade from `user_risk_settings` (default: $100).
2. Calculate risk per contract: `stop_distance_ticks * tick_value`.
3. Calculate quantity: `floor(fixed_risk / risk_per_contract)`.
4. Clamp to maximum position size (EX-FR-016): `min(quantity, max_position_size - existing_position)`.
5. Enforce minimum quantity of 1: `max(quantity, 1)`.
6. If `risk_per_contract > fixed_risk`, quantity is 1 and a warning is logged: `"Risk per contract (${risk_per_contract}) exceeds fixed risk per trade (${fixed_risk}). Proceeding with minimum quantity of 1."`.

**Example**:
- User fixed risk: $100. MNQ stop distance: 40 ticks. MNQ tick value: $0.50.
- Risk per contract: 40 * $0.50 = $20.
- Quantity: floor(100 / 20) = 5.
- If max position size is 2: quantity = 2.

#### EX-FR-027: Order Metadata Attachment

Each order record in the database includes: signal_id, user_id, broker (adapter name), order_type, side, instrument, quantity, price, stop_price, bracket_group_id, bracket_role, client_order_id (UUID), and all enrichment data from the signal. This metadata enables full traceability from order back to the originating signal and trendline.

---

### 3.16 EX-FR-028 through EX-FR-029: Broker Adapter Interface and Registry

**Source**: PRD-003 Section 3.6

#### EX-FR-028: Abstract Broker Interface

The `BrokerAdapter` abstract base class defines the contract that all broker implementations must fulfill. The interface methods and their expected behaviors:

| Method | Input | Output | Exceptions |
|---|---|---|---|
| `connect()` | None | `ConnectionStatus` (CONNECTED, FAILED) | `BrokerConnectionError` |
| `disconnect()` | None | None | -- |
| `place_order(order)` | `Order` | `OrderResult` (broker_order_id, status) | `OrderRejectedError`, `InsufficientMarginError`, `InvalidSymbolError`, `BrokerConnectionError` |
| `place_bracket_order(entry, sl, tp)` | Three `Order` objects | `BracketOrderResult` (entry_id, sl_id, tp_id, status) | Same as place_order |
| `cancel_order(broker_order_id)` | string | `CancelResult` (success, reason) | `BrokerConnectionError`, `OrderNotFoundError` |
| `modify_order(broker_order_id, mods)` | string, `OrderModification` | `ModifyResult` (success, new_values) | `BrokerConnectionError`, `OrderNotFoundError`, `InvalidModificationError` |
| `get_positions()` | None | `list[Position]` | `BrokerConnectionError` |
| `get_order_status(broker_order_id)` | string | `OrderStatus` | `BrokerConnectionError`, `OrderNotFoundError` |
| `get_account_info()` | None | `AccountInfo` (balance, margin, buying_power) | `BrokerConnectionError` |
| `subscribe_order_updates(callback)` | Callable | None | `BrokerConnectionError` |
| `subscribe_position_updates(callback)` | Callable | None | `BrokerConnectionError` |
| `get_contract_details(symbol)` | string | `ContractDetails` | `InvalidSymbolError`, `BrokerConnectionError` |

All methods are async. All methods raise typed exceptions rather than returning error codes.

#### EX-FR-029: Broker Adapter Registry

The system maintains a registry of available broker adapters. Configuration is stored per user in the `broker_connections` table:

| Field | Type | Description |
|---|---|---|
| id | UUID | Primary key |
| user_id | UUID | Owner |
| broker_type | enum | `IBKR`, `TRADOVATE`, `WEBULL`, `PAPER` |
| connection_params | JSONB (encrypted) | Broker-specific connection parameters |
| default_account_id | string | The account to route orders to |
| is_active | boolean | Whether this connection is currently active |
| is_paper | boolean | Whether this is a paper/demo account |
| created_at | timestamptz | When the connection was created |
| last_connected_at | timestamptz | Last successful connection |
| status | enum | `CONNECTED`, `DISCONNECTED`, `ERROR` |

Routing logic: when an order is ready for submission, the system selects the user's active broker connection. If the user is in paper mode, the order is always routed to the paper simulator regardless of broker connections.

---

### 3.17 EX-FR-030 through EX-FR-033: IBKR Adapter

**Source**: PRD-003 Section 3.7

#### EX-FR-030: IBKR Connection Management

**Processing Logic**:

1. Connect to IB Gateway via `ib_async` library on ports 4001 (live) or 4002 (paper).
2. Set `clientId` to a unique integer per user connection (hash of user_id modulo 999, starting at 100).
3. On connection success, subscribe to order updates, position updates, and account updates.
4. On connection failure or drop, auto-reconnect with exponential backoff:
   - Initial delay: 1 second.
   - Backoff multiplier: 2x.
   - Maximum delay: 60 seconds.
   - Jitter: +/- 500ms (random).
   - Retry indefinitely until connected or user disables the connection.
5. Handle IB's pacing violations (max 50 messages/second) via an internal token bucket rate limiter. If the rate limit is reached, queue messages and process them at the allowed rate.

**Error Handling**:

| IB Error Code | Meaning | System Response |
|---|---|---|
| 110 | Price out of range | Set order status to REJECTED. Rejection reason: "Broker rejected: price out of acceptable range". |
| 201 | Order rejected | Set order status to REJECTED. Rejection reason: "Broker rejected order: {ib_message}". |
| 502 | Couldn't connect to TWS | Increment circuit breaker counter. Attempt reconnection. |
| 1100 | Connectivity lost | Mark connection as DISCONNECTED. Notify user. Begin reconnection. |
| 2104 | Market data farm connected | Log as INFO. No action needed. |
| 2106 | HMDS data farm connected | Log as INFO. No action needed. |
| 10197 | Order not found for cancellation | Log as WARNING. Treat cancel as successful (order may have already filled). |

#### EX-FR-031: IBKR Order Submission

**Processing Logic**:

1. Translate TrendEdge instrument to IB Contract: `Contract(symbol="MNQ", exchange="CME", secType="FUT", lastTradeDateOrContractMonth="202603")`.
2. Create IB Order objects:
   - Entry: `Order(action="BUY"/"SELL", orderType="MKT"/"LMT", totalQuantity=qty, lmtPrice=price, transmit=False)`.
   - Stop Loss: `Order(action="SELL"/"BUY", orderType="STP", auxPrice=stop_price, totalQuantity=qty, parentId=entry_orderId, transmit=False)`.
   - Take Profit: `Order(action="SELL"/"BUY", orderType="LMT", lmtPrice=tp_price, totalQuantity=qty, parentId=entry_orderId, ocaGroup=oca_id, transmit=True)`.
3. Set `transmit=False` on parent and first child, `transmit=True` on last child to submit atomically.
4. Set `ocaGroup` to a unique string for the SL and TP orders so they form an OCA group.
5. Submit via `ib.placeOrder(contract, order)`.
6. Capture `orderId` and `permId` returned by IB. Store as `broker_order_id`.
7. Update order status to `SUBMITTED`.

#### EX-FR-032: IBKR Event Handling

| IB Event | Processing |
|---|---|
| `orderStatus` | Map IB status to TrendEdge states: `Submitted`->`SUBMITTED`, `Filled`->`FILLED`, `Cancelled`->`CANCELLED`, `Inactive`->`REJECTED`. Update `orders` table. Create `order_events` record. |
| `execDetails` | Record fill_price, fill_quantity, commission, execution_time, exchange. Calculate slippage. Update order and position records. |
| `error` | Handle by error code (see table above). Log all errors with code, message, and order context. |
| `position` | Reconcile with TrendEdge positions table. Flag discrepancies. |

#### EX-FR-033: IBKR Account Data

Retrieve and cache (refresh every 30 seconds) via `ib.accountSummary()` and `ib.accountValues()`:
- NetLiquidation, TotalCashValue -> `account_balance`
- InitMarginReq, MaintMarginReq, AvailableFunds -> `margin_info`
- RealizedPnL, UnrealizedPnL -> `daily_pnl`
- Open positions via `ib.positions()` -> reconcile with internal tracking.

---

### 3.18 EX-FR-034 through EX-FR-037: Tradovate Adapter

**Source**: PRD-003 Section 3.8

#### EX-FR-034: Tradovate Authentication

**Processing Logic**:

1. Authenticate via `POST https://live.tradovateapi.com/v1/auth/accessTokenRequest`:
   ```json
   {
     "name": "{username}",
     "password": "{password}",
     "appId": "{app_id}",
     "appVersion": "1.0",
     "deviceId": "{device_uuid}",
     "cid": "{client_id}",
     "sec": "{client_secret}"
   }
   ```
2. Store the returned `accessToken` and `expirationTime` securely (encrypted at rest via AES-256-GCM).
3. Set a timer to refresh the token proactively at 50 minutes (10-minute buffer before 60-minute expiry).
4. Token refresh: `POST /auth/renewAccessToken` with the current token.
5. On refresh failure: retry 3 times with 5-second intervals. If all retries fail, mark connection as FAILED and notify the user: "Tradovate authentication failed. Please re-authenticate in dashboard settings."

#### EX-FR-035: Tradovate Order Submission

**Processing Logic**:

1. Submit bracket orders via `POST /order/placeOSO`:
   ```json
   {
     "accountSpec": "{account_name}",
     "accountId": {account_id},
     "action": "Buy"/"Sell",
     "symbol": "MNQH6",
     "orderQty": 1,
     "orderType": "Market"/"Limit",
     "price": 18450.25,
     "isAutomated": true,
     "bracket1": {
       "action": "Sell"/"Buy",
       "orderType": "Stop",
       "price": 18420.00
     },
     "bracket2": {
       "action": "Sell"/"Buy",
       "orderType": "Limit",
       "price": 18510.50
     }
   }
   ```
2. Set `isAutomated=true` for all programmatic orders (required by Tradovate).
3. Capture the returned order IDs for entry, stop, and target.

#### EX-FR-036: Tradovate WebSocket Streaming

1. Connect to `wss://live.tradovateapi.com/v1/websocket` (live) or `wss://demo.tradovateapi.com/v1/websocket` (paper).
2. Authenticate the WebSocket with the access token.
3. Subscribe to: `order/item`, `fill/item`, `position/item`.
4. Send heartbeat ping every 2.5 seconds (Tradovate specification).
5. Process events: map Tradovate order statuses to TrendEdge states, record fills, update positions.
6. On disconnect, reconnect with exponential backoff (same parameters as IBKR).

#### EX-FR-037: Tradovate Account Data

Retrieve via REST endpoints:
- `GET /account/item` and `GET /cashBalance/getCashBalanceSnapshot` -> balance and margin.
- `GET /position/list` -> open positions.
- `GET /order/list` -> open orders.

---

### 3.19 EX-FR-038 through EX-FR-041: Paper Trading Simulator

**Source**: PRD-003 Section 3.9

#### EX-FR-038: Paper Trading Mode

Paper mode uses the exact same code paths as live mode through signal ingestion, validation, enrichment, risk checks, and order construction. The only difference is at the broker routing step: instead of calling a live broker adapter, orders are routed to the `PaperBrokerAdapter` which simulates fills internally.

Paper mode is the default for all new users. Paper mode is enabled per user in `user_settings.trading_mode` (values: `PAPER` or `LIVE`).

#### EX-FR-039: Paper Fill Simulation

**Processing Logic**:

1. **Market orders**: Fill immediately at `signal.entry_price + slippage`.
   - Slippage model (default):
     - Micro contracts: 1 tick adverse slippage.
     - Full-size contracts: 2 ticks adverse slippage.
   - Adverse direction: for BUY, fill price = entry_price + (slippage_ticks * tick_size). For SELL, fill price = entry_price - (slippage_ticks * tick_size).
   - Slippage is configurable per user: 0 to 10 ticks.
2. **Limit orders**: In MVP, fill immediately at the limit price (no slippage). Future enhancement: use real-time market data to determine when the limit price is reached.
3. **Stop orders**: In MVP, when the paper position monitoring loop detects that the current market price has reached the stop price, the stop order is triggered and filled at stop_price + slippage.
4. Paper fills generate the same `order_events` records as live fills, with `is_paper = true`.

#### EX-FR-040: Paper Position Tracking

1. Paper positions are tracked in the same `positions` table with `is_paper = true`.
2. The paper position monitoring loop runs every 5 seconds (configurable):
   a. For each open paper position, check the current market price (from market data cache or last known price).
   b. If the market price has reached the stop loss price: trigger the stop, fill the stop order, cancel the take profit order, close the position with `exit_reason = 'STOP_LOSS'`.
   c. If the market price has reached the take profit price: trigger the take profit, fill the TP order, cancel the stop loss order, close the position with `exit_reason = 'TAKE_PROFIT'`.
   d. Update unrealized P&L, MAE, and MFE on each iteration.
3. MAE calculation: track the worst price the position has seen relative to entry. For LONG: `mae = max(0, entry_price - lowest_price_seen)`. Store in ticks and dollars.
4. MFE calculation: track the best price the position has seen relative to entry. For LONG: `mfe = max(0, highest_price_seen - entry_price)`. Store in ticks and dollars.

#### EX-FR-041: Paper-to-Live Transition

**Processing Logic**:

1. Check if user has completed the minimum paper trading period:
   - `paper_start_date` is set when the user's first paper trade fills.
   - `minimum_paper_days` is configurable (default: 60, range: 0-365).
   - If `(current_date - paper_start_date).days < minimum_paper_days`: reject the transition request with `"You have {remaining} days remaining in your paper trading period. Paper start: {date}. Minimum period: {min_days} days."`.
2. If the minimum period is met, display a notification: "You are eligible to enable live trading."
3. The transition flow requires explicit opt-in:
   a. User clicks "Enable Live Trading" in dashboard settings.
   b. User checks a checkbox: "I understand I am trading with real money and real losses."
   c. User types the confirmation text: "I understand I am trading with real money" in an input field.
   d. System validates the typed text matches exactly (case-insensitive).
   e. If match: set `user_settings.trading_mode = 'LIVE'`. Log the transition.
   f. If mismatch: display error "Confirmation text does not match. Please type exactly: 'I understand I am trading with real money'".
4. Setting the minimum paper period to 0 requires an additional acknowledgment: "I acknowledge that skipping paper trading increases my risk of losses."
5. All paper trading history is retained after transition. Paper and live P&L remain separated.
6. Users can run paper and live simultaneously on different broker connections.

---

### 3.20 EX-FR-042 through EX-FR-058: Position Management, Order Lifecycle, Symbol Mapping, Circuit Breaker, Manual Override, Fill Reconciliation

These requirements are specified in detail in later sections. Key behaviors:

#### EX-FR-044: Order State Machine

States: `CONSTRUCTED` -> `SUBMITTED` -> `PENDING` -> `PARTIAL_FILL` -> `FILLED` -> `CLOSED`.
Terminal states: `REJECTED`, `CANCELLED`, `CLOSED`.
Every state transition is persisted to `order_events` with timestamp, broker response, fill details, and rejection reason.

#### EX-FR-046: OCO Group Management

When a stop loss fills: cancel take profit, close position, create journal entry with `exit_reason = 'STOP_LOSS'`.
When a take profit fills: cancel stop loss, close position, create journal entry with `exit_reason = 'TAKE_PROFIT'`.
If both fill due to a race condition: detect the double fill, alert the user immediately, and log as a critical discrepancy.

#### EX-FR-050: Circuit Breaker

Trips after N consecutive failures (default: 3). When tripped: pause all signal processing, notify user (Telegram + email + dashboard), display circuit breaker state on dashboard. Auto-reset after configurable cooldown (default: 15 minutes) or manual reset by user.

#### EX-FR-052-054: Manual Overrides

Users can cancel orders, modify pending orders (price, stop, target, reduce quantity), and close positions from the dashboard. All modifications are validated against risk rules. All actions are logged with user_id and timestamp.

#### EX-FR-055: Emergency Flatten All

One-click (with confirmation) to: close all open positions via market orders, cancel all pending orders, disable signal processing. Must complete within 5 seconds. Requires single confirmation dialog (fast path, not multi-step).

#### EX-FR-056-058: Fill Reconciliation

On every broker reconnection, query broker for fills since last known timestamp. Compare against internal records. Flag discrepancies (missing fills, extra fills, price differences > 1 tick). Calculate and store slippage for every fill. Track commissions per broker schedule.

---

## 4. Data Specifications

### 4.1 Database Tables

#### 4.1.1 `signals` Table

```sql
CREATE TABLE signals (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    source VARCHAR(20) NOT NULL CHECK (source IN ('INTERNAL', 'WEBHOOK', 'MANUAL')),
    source_metadata JSONB,
    instrument VARCHAR(20) NOT NULL,
    direction VARCHAR(5) NOT NULL CHECK (direction IN ('LONG', 'SHORT')),
    entry_type VARCHAR(10) NOT NULL CHECK (entry_type IN ('MARKET', 'LIMIT')),
    entry_price DECIMAL(12,4) NOT NULL,
    stop_loss_price DECIMAL(12,4),
    take_profit_price DECIMAL(12,4),
    quantity INTEGER DEFAULT 1,
    risk_reward_ratio DECIMAL(4,2),
    trendline_id UUID,
    trendline_grade VARCHAR(5),
    enrichment_data JSONB,
    status VARCHAR(20) NOT NULL DEFAULT 'RECEIVED'
        CHECK (status IN ('RECEIVED','VALIDATED','RISK_PASSED','EXECUTING','FILLED','REJECTED')),
    rejection_reason TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ,
    is_paper BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE INDEX idx_signals_user_id ON signals(user_id);
CREATE INDEX idx_signals_status ON signals(status);
CREATE INDEX idx_signals_instrument ON signals(instrument);
CREATE INDEX idx_signals_created_at ON signals(created_at);
CREATE INDEX idx_signals_user_instrument_direction ON signals(user_id, instrument, direction);
```

#### 4.1.2 `orders` Table

```sql
CREATE TABLE orders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    signal_id UUID NOT NULL REFERENCES signals(id),
    user_id UUID NOT NULL REFERENCES users(id),
    broker VARCHAR(20) NOT NULL,
    broker_order_id VARCHAR(100),
    client_order_id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    order_type VARCHAR(15) NOT NULL CHECK (order_type IN ('MARKET','LIMIT','STOP','STOP_LIMIT')),
    side VARCHAR(5) NOT NULL CHECK (side IN ('BUY', 'SELL')),
    instrument VARCHAR(20) NOT NULL,
    quantity INTEGER NOT NULL,
    price DECIMAL(12,4),
    stop_price DECIMAL(12,4),
    time_in_force VARCHAR(5) DEFAULT 'GTC' CHECK (time_in_force IN ('DAY','GTC','GTD')),
    status VARCHAR(20) NOT NULL DEFAULT 'CONSTRUCTED'
        CHECK (status IN ('CONSTRUCTED','SUBMITTED','PENDING','PARTIAL_FILL','FILLED','REJECTED','CANCELLED','CLOSED')),
    bracket_group_id UUID,
    bracket_role VARCHAR(15) CHECK (bracket_role IN ('ENTRY', 'STOP_LOSS', 'TAKE_PROFIT')),
    fill_price DECIMAL(12,4),
    fill_quantity INTEGER,
    commission DECIMAL(8,4),
    slippage_ticks DECIMAL(6,2),
    slippage_dollars DECIMAL(8,4),
    is_paper BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    submitted_at TIMESTAMPTZ,
    filled_at TIMESTAMPTZ,
    cancelled_at TIMESTAMPTZ
);

CREATE INDEX idx_orders_signal_id ON orders(signal_id);
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_bracket_group_id ON orders(bracket_group_id);
CREATE INDEX idx_orders_client_order_id ON orders(client_order_id);
CREATE INDEX idx_orders_broker_order_id ON orders(broker_order_id);
```

#### 4.1.3 `order_events` Table

```sql
CREATE TABLE order_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    order_id UUID NOT NULL REFERENCES orders(id),
    previous_state VARCHAR(20),
    new_state VARCHAR(20) NOT NULL,
    broker_order_id VARCHAR(100),
    fill_price DECIMAL(12,4),
    fill_quantity INTEGER,
    commission DECIMAL(8,4),
    rejection_reason TEXT,
    raw_broker_response JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_order_events_order_id ON order_events(order_id);
CREATE INDEX idx_order_events_created_at ON order_events(created_at);
```

#### 4.1.4 `positions` Table

```sql
CREATE TABLE positions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    signal_id UUID REFERENCES signals(id),
    entry_order_id UUID REFERENCES orders(id),
    instrument VARCHAR(20) NOT NULL,
    direction VARCHAR(5) NOT NULL,
    quantity INTEGER NOT NULL,
    entry_price DECIMAL(12,4) NOT NULL,
    current_price DECIMAL(12,4),
    stop_loss_price DECIMAL(12,4),
    take_profit_price DECIMAL(12,4),
    stop_loss_order_id UUID REFERENCES orders(id),
    take_profit_order_id UUID REFERENCES orders(id),
    unrealized_pnl DECIMAL(12,4),
    realized_pnl DECIMAL(12,4),
    commission_total DECIMAL(8,4),
    net_pnl DECIMAL(12,4),
    r_multiple DECIMAL(6,2),
    planned_risk DECIMAL(12,4),
    mae_ticks DECIMAL(8,2),
    mfe_ticks DECIMAL(8,2),
    mae_dollars DECIMAL(12,4),
    mfe_dollars DECIMAL(12,4),
    status VARCHAR(10) NOT NULL DEFAULT 'OPEN' CHECK (status IN ('OPEN', 'CLOSED')),
    exit_reason VARCHAR(20) CHECK (exit_reason IN ('STOP_LOSS','TAKE_PROFIT','MANUAL_CLOSE','FLATTEN_ALL','BROKER_LIQUIDATION')),
    is_paper BOOLEAN NOT NULL DEFAULT TRUE,
    opened_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    closed_at TIMESTAMPTZ
);

CREATE INDEX idx_positions_user_id ON positions(user_id);
CREATE INDEX idx_positions_status ON positions(status);
CREATE INDEX idx_positions_instrument ON positions(instrument);
CREATE INDEX idx_positions_user_status ON positions(user_id, status);
```

#### 4.1.5 `risk_check_audit` Table

```sql
CREATE TABLE risk_check_audit (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    signal_id UUID NOT NULL REFERENCES signals(id),
    check_name VARCHAR(50) NOT NULL,
    result VARCHAR(10) NOT NULL CHECK (result IN ('PASS', 'FAIL', 'WARN')),
    actual_value DECIMAL(12,4),
    threshold_value DECIMAL(12,4),
    details JSONB,
    checked_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_risk_audit_signal_id ON risk_check_audit(signal_id);
```

#### 4.1.6 `webhook_urls` Table

```sql
CREATE TABLE webhook_urls (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    webhook_id VARCHAR(64) NOT NULL UNIQUE,
    webhook_secret VARCHAR(128),
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deactivated_at TIMESTAMPTZ
);

CREATE INDEX idx_webhook_urls_webhook_id ON webhook_urls(webhook_id);
CREATE INDEX idx_webhook_urls_user_id ON webhook_urls(user_id);
```

#### 4.1.7 `broker_connections` Table

```sql
CREATE TABLE broker_connections (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    broker_type VARCHAR(20) NOT NULL CHECK (broker_type IN ('IBKR','TRADOVATE','WEBULL','PAPER')),
    connection_params_encrypted BYTEA NOT NULL,
    default_account_id VARCHAR(100),
    is_active BOOLEAN NOT NULL DEFAULT FALSE,
    is_paper BOOLEAN NOT NULL DEFAULT TRUE,
    status VARCHAR(20) NOT NULL DEFAULT 'DISCONNECTED'
        CHECK (status IN ('CONNECTED','DISCONNECTED','RECONNECTING','ERROR')),
    last_connected_at TIMESTAMPTZ,
    last_error TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_broker_connections_user_id ON broker_connections(user_id);
```

#### 4.1.8 `user_risk_settings` Table

```sql
CREATE TABLE user_risk_settings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL UNIQUE REFERENCES users(id),
    max_position_size_micro INTEGER NOT NULL DEFAULT 2,
    max_position_size_full INTEGER NOT NULL DEFAULT 1,
    daily_loss_limit DECIMAL(10,2) NOT NULL DEFAULT 500.00,
    max_concurrent_positions INTEGER NOT NULL DEFAULT 3,
    min_risk_reward_ratio DECIMAL(4,2) NOT NULL DEFAULT 2.00,
    correlation_action VARCHAR(10) NOT NULL DEFAULT 'warn'
        CHECK (correlation_action IN ('warn', 'block')),
    correlation_threshold DECIMAL(3,2) NOT NULL DEFAULT 0.70,
    max_single_trade_risk DECIMAL(10,2) NOT NULL DEFAULT 200.00,
    fixed_risk_per_trade DECIMAL(10,2) NOT NULL DEFAULT 100.00,
    trading_hours VARCHAR(5) NOT NULL DEFAULT 'RTH'
        CHECK (trading_hours IN ('RTH', 'ETH', '24H')),
    signal_staleness_minutes INTEGER NOT NULL DEFAULT 5,
    paper_slippage_ticks INTEGER NOT NULL DEFAULT 1,
    min_paper_trading_days INTEGER NOT NULL DEFAULT 60,
    dedup_window_minutes INTEGER NOT NULL DEFAULT 5,
    dedup_price_tolerance_ticks INTEGER NOT NULL DEFAULT 2,
    stop_type VARCHAR(15) NOT NULL DEFAULT 'STOP_MARKET'
        CHECK (stop_type IN ('STOP_MARKET', 'STOP_LIMIT')),
    default_time_in_force VARCHAR(5) NOT NULL DEFAULT 'GTC'
        CHECK (default_time_in_force IN ('DAY', 'GTC', 'GTD')),
    prefer_micro BOOLEAN NOT NULL DEFAULT TRUE,
    consecutive_loss_cooldown INTEGER NOT NULL DEFAULT 3,
    weekly_drawdown_warning DECIMAL(10,2) NOT NULL DEFAULT 1000.00,
    break_even_stop_mode VARCHAR(10) NOT NULL DEFAULT 'manual'
        CHECK (break_even_stop_mode IN ('auto', 'manual', 'off')),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

#### 4.1.9 `risk_settings_changelog` Table

```sql
CREATE TABLE risk_settings_changelog (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    setting_name VARCHAR(50) NOT NULL,
    previous_value TEXT,
    new_value TEXT NOT NULL,
    changed_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_risk_changelog_user_id ON risk_settings_changelog(user_id);
```

#### 4.1.10 `contract_calendar` Table

```sql
CREATE TABLE contract_calendar (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    instrument_family VARCHAR(10) NOT NULL,
    contract_symbol VARCHAR(20) NOT NULL UNIQUE,
    month_code CHAR(1) NOT NULL,
    year INTEGER NOT NULL,
    first_notice_date DATE,
    last_trading_date DATE NOT NULL,
    expiration_date DATE NOT NULL,
    rollover_date DATE NOT NULL,
    is_front_month BOOLEAN NOT NULL DEFAULT FALSE,
    is_active BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE INDEX idx_contract_calendar_family ON contract_calendar(instrument_family);
CREATE INDEX idx_contract_calendar_front ON contract_calendar(instrument_family, is_front_month);
```

#### 4.1.11 `contract_specifications` Table

```sql
CREATE TABLE contract_specifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    symbol VARCHAR(10) NOT NULL UNIQUE,
    full_name VARCHAR(100) NOT NULL,
    exchange VARCHAR(10) NOT NULL,
    tick_size DECIMAL(10,6) NOT NULL,
    tick_value DECIMAL(10,4) NOT NULL,
    point_value DECIMAL(10,4) NOT NULL,
    contract_size DECIMAL(10,4),
    margin_day DECIMAL(10,2),
    margin_overnight DECIMAL(10,2),
    is_micro BOOLEAN NOT NULL DEFAULT TRUE,
    trading_hours_rth VARCHAR(50),
    trading_hours_eth VARCHAR(50)
);
```

#### 4.1.12 `execution_audit_log` Table

```sql
CREATE TABLE execution_audit_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    event_type VARCHAR(50) NOT NULL,
    event_data JSONB NOT NULL,
    ip_address INET,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_exec_audit_user_id ON execution_audit_log(user_id);
CREATE INDEX idx_exec_audit_event_type ON execution_audit_log(event_type);
CREATE INDEX idx_exec_audit_created_at ON execution_audit_log(created_at);
```

### 4.2 Contract Specifications Reference Data

| Symbol | Full Name | Tick Size | Tick Value | Point Value | Exchange | Is Micro |
|---|---|---|---|---|---|---|
| MNQ | Micro E-mini Nasdaq-100 | 0.25 | $0.50 | $2.00 | CME | Yes |
| MES | Micro E-mini S&P 500 | 0.25 | $1.25 | $5.00 | CME | Yes |
| MYM | Micro E-mini Dow Jones | 1.00 | $0.50 | $0.50 | CBOT | Yes |
| M2K | Micro E-mini Russell 2000 | 0.10 | $0.50 | $5.00 | CME | Yes |
| MGC | Micro Gold | 0.10 | $1.00 | $10.00 | COMEX | Yes |
| MCL | Micro WTI Crude Oil | 0.01 | $1.00 | $100.00 | NYMEX | Yes |
| SIL | Micro Silver | 0.005 | $2.50 | $500.00 | COMEX | Yes |
| NQ | E-mini Nasdaq-100 | 0.25 | $5.00 | $20.00 | CME | No |
| ES | E-mini S&P 500 | 0.25 | $12.50 | $50.00 | CME | No |

### 4.3 Futures Month Codes

| Code | Month | | Code | Month |
|---|---|---|---|---|
| F | January | | N | July |
| G | February | | Q | August |
| H | March | | U | September |
| J | April | | V | October |
| K | May | | X | November |
| M | June | | Z | December |

---

## 5. API Specifications

### 5.1 Webhook Endpoint

#### `POST /api/v1/webhooks/tradingview/{user_webhook_id}`

**Authentication**: Webhook ID path + optional API key or HMAC signature.
**Rate Limit**: 10/minute, 100/hour per webhook URL.
**Max Body Size**: 64 KB.

**Request**:
```json
{
  "key": "user_api_key_here",
  "ticker": "NQ1!",
  "action": "buy",
  "price": 18450.25,
  "stop": 18420.00,
  "target": 18510.50,
  "quantity": 1,
  "timeframe": "240",
  "message": "A+ trendline break"
}
```

**Response 200**:
```json
{
  "signal_id": "550e8400-e29b-41d4-a716-446655440000",
  "status": "received",
  "message": "Signal accepted for processing"
}
```

**Error Responses**: See EX-FR-002 error handling table.

### 5.2 Manual Signal Endpoint

#### `POST /api/v1/signals/manual`

**Authentication**: Bearer token (session token).
**Rate Limit**: 5/minute per user.

**Request**:
```json
{
  "instrument": "MNQ",
  "direction": "LONG",
  "entry_type": "MARKET",
  "entry_price": 18450.25,
  "stop_loss_price": 18430.00,
  "take_profit_price": 18490.50,
  "quantity": 2,
  "notes": "Support bounce setup"
}
```

**Response 201**:
```json
{
  "signal_id": "550e8400-e29b-41d4-a716-446655440001",
  "status": "received",
  "message": "Manual signal submitted for processing",
  "warnings": []
}
```

### 5.3 Signal Status Endpoint

#### `GET /api/v1/signals/{signal_id}`

**Authentication**: Bearer token. User can only access their own signals.

**Response 200**:
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "source": "WEBHOOK",
  "instrument": "MNQH6",
  "direction": "LONG",
  "entry_price": "18450.25",
  "stop_loss_price": "18420.00",
  "take_profit_price": "18510.50",
  "quantity": 1,
  "risk_reward_ratio": "2.97",
  "status": "FILLED",
  "created_at": "2026-02-11T14:30:00Z",
  "processed_at": "2026-02-11T14:30:04Z",
  "risk_checks": [
    {"check": "MAX_POSITION_SIZE", "result": "PASS", "actual": 1, "threshold": 2},
    {"check": "DAILY_LOSS_LIMIT", "result": "PASS", "actual": -150.00, "threshold": -500.00},
    {"check": "MAX_CONCURRENT_POSITIONS", "result": "PASS", "actual": 1, "threshold": 3},
    {"check": "MIN_RISK_REWARD", "result": "PASS", "actual": 2.97, "threshold": 2.00},
    {"check": "CORRELATION", "result": "PASS", "actual": 0.00, "threshold": 0.70}
  ]
}
```

### 5.4 Order Management Endpoints

#### `GET /api/v1/orders`
Returns all orders for the authenticated user. Supports filters: `status`, `instrument`, `is_paper`, `from_date`, `to_date`. Paginated (default 50, max 200).

#### `GET /api/v1/orders/{order_id}`
Returns a single order with full details including order events.

#### `DELETE /api/v1/orders/{order_id}`
Cancels a pending/working order. Returns 200 on success, 400 if order is already filled/cancelled, 404 if not found.

#### `PATCH /api/v1/orders/{order_id}`
Modifies a pending order. Body may include: `price`, `stop_price`, `quantity` (reduce only). Returns 200 with updated order, 400 if modification violates risk rules.

### 5.5 Position Endpoints

#### `GET /api/v1/positions`
Returns all positions. Supports filters: `status` (OPEN/CLOSED), `instrument`, `is_paper`, `from_date`, `to_date`. Paginated.

#### `POST /api/v1/positions/{position_id}/close`
Closes a position at market. Returns 200 with the closing order details.

#### `POST /api/v1/positions/flatten-all`
Emergency flatten all. Requires body: `{"confirm": true}`. Returns 200 with count of positions closed and orders cancelled.

### 5.6 Settings Endpoints

#### `GET /api/v1/settings/risk`
Returns the user's current risk settings.

#### `PUT /api/v1/settings/risk`
Updates risk settings. All fields are optional; only provided fields are updated. Returns 200 with updated settings.

#### `GET /api/v1/settings/webhook`
Returns the user's webhook URL and API key (masked). Includes `webhook_url`, `api_key_prefix` (first 8 chars), `created_at`.

#### `POST /api/v1/settings/webhook/regenerate`
Regenerates the webhook URL. Requires re-authentication. Returns the new URL (shown once).

#### `POST /api/v1/settings/api-key/regenerate`
Regenerates the API key. Returns the new key (shown once, never again).

### 5.7 Broker Connection Endpoints

#### `GET /api/v1/brokers`
Returns all broker connections for the user.

#### `POST /api/v1/brokers`
Creates a new broker connection. Body: `broker_type`, `connection_params`, `default_account_id`, `is_paper`.

#### `PUT /api/v1/brokers/{connection_id}`
Updates broker connection settings.

#### `DELETE /api/v1/brokers/{connection_id}`
Removes a broker connection. Active connections must be deactivated first.

#### `POST /api/v1/brokers/{connection_id}/test`
Tests a broker connection. Returns connection status and account info if successful.

### 5.8 WebSocket API

#### `WS /api/v1/ws/execution`

**Authentication**: Bearer token as query parameter or in the initial handshake.

**Server-Sent Events**:

| Event Type | Payload | Description |
|---|---|---|
| `order.status_changed` | `{order_id, previous_status, new_status, fill_price, timestamp}` | Order state transition |
| `position.updated` | `{position_id, current_price, unrealized_pnl, mae, mfe}` | Position P&L update |
| `position.closed` | `{position_id, exit_reason, realized_pnl, r_multiple}` | Position closed |
| `signal.processed` | `{signal_id, status, rejection_reason}` | Signal processing result |
| `broker.status_changed` | `{broker_type, status, message}` | Broker connection status |
| `circuit_breaker.tripped` | `{consecutive_failures, cooldown_seconds}` | Circuit breaker activated |
| `circuit_breaker.reset` | `{reset_type: "manual"/"auto"}` | Circuit breaker reset |
| `risk.warning` | `{check_name, message, actual_value, threshold}` | Risk warning (correlation, etc.) |

---

## 6. UI/UX Specifications

### 6.1 Order Entry Form (Manual Signal)

**Location**: Dashboard main panel, accessible via "New Trade" button.

**Form Layout**:
1. **Instrument**: Searchable dropdown. Shows instrument symbol, full name, and last price. Updates entry_price field on selection.
2. **Direction**: Two-button toggle: LONG (green) / SHORT (red).
3. **Entry Type**: Two-button toggle: MARKET / LIMIT.
4. **Entry Price**: Numeric input. Pre-filled with last market price when entry_type is MARKET. Editable when entry_type is LIMIT.
5. **Stop Loss**: Numeric input. Optional but recommended. Shows calculated risk in dollars below the field when filled.
6. **Take Profit**: Numeric input. Optional but recommended. Shows calculated reward in dollars below the field when filled.
7. **R:R Ratio**: Computed and displayed in real-time as user types stop/target values. Shows as "R:R: 2.5" with color: green >= 2.0, yellow 1.5-2.0, red < 1.5.
8. **Quantity**: Numeric input. Shows "Auto (calculated from risk)" placeholder when empty. Shows calculated quantity based on current risk settings.
9. **Notes**: Text area, max 500 chars. Character count displayed.
10. **Submit Button**: "Place Trade" (disabled until minimum required fields are filled). Shows "Place Paper Trade" with a distinct style (e.g., dashed border, "PAPER" badge) when in paper mode.

**Validation Messages** (displayed inline below each field):
- Empty instrument: "Please select an instrument"
- Invalid entry price: "Entry price must be a positive number"
- Stop on wrong side: "Stop loss must be below entry price for LONG trades" / "Stop loss must be above entry price for SHORT trades"
- Target on wrong side: "Take profit must be above entry price for LONG trades" / "Take profit must be below entry price for SHORT trades"
- Quantity exceeds max: "Maximum position size for {instrument} is {max}"

### 6.2 Active Orders Panel

**Location**: Dashboard, below the chart or in a side panel.

**Columns**: Order ID (truncated), Instrument, Side (BUY/SELL), Type (MKT/LMT/STP), Qty, Price, Status, Actions.

**Status Indicators**:
- CONSTRUCTED: gray dot
- SUBMITTED: blue dot + spinner
- PENDING: yellow dot
- PARTIAL_FILL: orange dot + "X/Y filled"
- FILLED: green dot
- REJECTED: red dot + tooltip with rejection reason
- CANCELLED: gray strikethrough

**Actions**:
- Cancel button (X icon) on PENDING orders. Confirmation tooltip: "Cancel this order?"
- Modify button (pencil icon) on PENDING orders. Opens inline edit for price/stop/target.

### 6.3 Open Positions Panel

**Location**: Dashboard, prominent position.

**Columns**: Instrument, Direction (LONG/SHORT with color), Qty, Entry, Current, P&L ($), P&L (R), Stop, Target, Time In Position, Actions.

**P&L Color**: Green for positive, red for negative. Flashes briefly on update.

**Actions**:
- "Close" button on each position. Confirmation: "Close {instrument} {direction} position at market?"
- "Modify Stop" and "Modify Target" inline edit buttons.

### 6.4 Paper Trading Indicator

When the user is in paper mode, the entire dashboard shows:
- A persistent banner at the top: "PAPER TRADING MODE - No real money at risk" (blue background, white text).
- All P&L values are prefixed with "Paper:" (e.g., "Paper: +$125.50").
- The "New Trade" button shows "New Paper Trade".
- Paper trades have a distinct visual style (e.g., dashed borders on position cards, paper icon).

### 6.5 Circuit Breaker Status

**Location**: Dashboard header bar, next to broker connection status.

**States**:
- Normal: Green shield icon. No text.
- Tripped: Red shield icon + "CIRCUIT BREAKER ACTIVE - Trading halted" banner. Shows countdown to auto-reset. Shows "Reset" button.
- Cooldown: Yellow shield icon + "Resetting in {seconds}s" text.

### 6.6 Broker Connection Status

**Location**: Dashboard header bar.

**States**:
- Connected: Green dot + broker name (e.g., "IBKR: Connected").
- Reconnecting: Yellow dot + "Reconnecting..." + animated spinner.
- Disconnected: Red dot + "Disconnected" + "Reconnect" button.
- Error: Red dot + error icon + "Connection Error" + tooltip with error details.

### 6.7 Emergency Flatten All

**Location**: Dashboard header bar, always visible. Red button labeled "FLATTEN ALL".

**Confirmation Dialog**: Modal with:
- Text: "This will immediately close ALL open positions and cancel ALL pending orders. This action cannot be undone."
- Single "Confirm Flatten All" button (red).
- "Cancel" button.
- No additional confirmation steps (fast path per PRD requirement).

---

## 7. Integration Specifications

### 7.1 Interactive Brokers (IBKR) Integration

**Provider**: Interactive Brokers via IB Gateway + ib_async Python library.
**Purpose**: Live and paper order routing for futures trading.
**Environment**:
- IB Gateway runs on the application VPS.
- Port 4001: live trading. Port 4002: paper trading.
- API key location: IB Gateway configuration (not stored in TrendEdge DB; connection is socket-based).

**Connection Protocol**:
1. Application startup: connect to IB Gateway via `ib_async.IB.connectAsync(host='127.0.0.1', port=4001/4002, clientId=N)`.
2. On connection success: subscribe to order updates, position updates, and account summary.
3. On disconnect: reconnect with exponential backoff (1s initial, 60s max, +/- 500ms jitter).

**Rate Limits**:
- IB pacing: max 50 messages/second.
- TrendEdge internal rate limiter: token bucket, 45 tokens/second (5-message buffer).

**Error Handling**:

| IB Error | Our Response |
|---|---|
| Connection refused (port closed) | Log ERROR, retry with backoff. Notify user after 3 failures. |
| 502 (Couldn't connect) | Increment circuit breaker. Retry with backoff. |
| 1100 (Connectivity lost) | Mark DISCONNECTED. Begin reconnection. Notify user. |
| 110 (Price out of range) | Reject order. Log warning. Do not retry. |
| 201 (Order rejected) | Mark order REJECTED with broker message. Do not retry. |
| Pacing violation | Queue message, wait 50ms, retry. |

**Fallback Behavior**: If IB Gateway is unavailable for > 5 minutes, circuit breaker trips. Incoming signals are queued (up to 50). When connection is restored, queued signals are re-evaluated (price validity re-checked) and processed if still valid.

### 7.2 Tradovate Integration

**Provider**: Tradovate via REST API + WebSocket.
**Purpose**: Live and paper order routing for futures trading.
**Environment**:
- Live: `https://live.tradovateapi.com/v1/`
- Demo: `https://demo.tradovateapi.com/v1/`
- WebSocket Live: `wss://live.tradovateapi.com/v1/websocket`
- WebSocket Demo: `wss://demo.tradovateapi.com/v1/websocket`
- Credentials: stored encrypted in `broker_connections` table.

**Authentication Flow**:
1. Initial auth: `POST /auth/accessTokenRequest` with credentials.
2. Token refresh: scheduled at 50-minute mark (10-minute buffer before 60-minute expiry).
3. On 401 response during any API call: immediately attempt token refresh, then retry the original request once.

**Endpoints Used**:

| Action | Method | Endpoint | Rate Limit |
|---|---|---|---|
| Authenticate | POST | /auth/accessTokenRequest | -- |
| Refresh token | POST | /auth/renewAccessToken | -- |
| Place order | POST | /order/placeOrder | 50/min |
| Place bracket (OSO) | POST | /order/placeOSO | 50/min |
| Cancel order | POST | /order/cancelOrder | 50/min |
| Modify order | POST | /order/modifyOrder | 50/min |
| Get positions | GET | /position/list | 120/min |
| Get orders | GET | /order/list | 120/min |
| Get account | GET | /account/item | 120/min |
| Get cash balance | GET | /cashBalance/getCashBalanceSnapshot | 120/min |

**Error Handling**:

| HTTP Status | Cause | Our Response |
|---|---|---|
| 401 | Token expired | Refresh token, retry request once. If refresh fails, mark connection ERROR, notify user. |
| 429 | Rate limited | Exponential backoff: 1s, 2s, 4s. Max 3 retries. |
| 500 | Server error | Retry once after 2s. If persistent, increment circuit breaker. |
| Timeout (>10s) | Network issue | Retry once. If persistent, increment circuit breaker. |

**WebSocket Heartbeat**: Send `[]` (empty array) every 2.5 seconds as required by Tradovate. If no heartbeat response received within 10 seconds, consider the connection dead and reconnect.

### 7.3 Redis Integration

**Purpose**: Signal pub/sub, rate limiting, deduplication, circuit breaker state, market price cache.
**Connection**: Redis connection pool managed by application. [Cross-reference: see FSD-001 for Redis infrastructure]

**Key Patterns**:

| Key Pattern | Type | TTL | Purpose |
|---|---|---|---|
| `trendedge:signals:internal` | Pub/Sub channel | -- | Internal signal delivery |
| `ratelimit:webhook:{webhook_id}:minute` | Sorted Set | 120s | Per-minute rate limiting |
| `ratelimit:webhook:{webhook_id}:hour` | Sorted Set | 7200s | Per-hour rate limiting |
| `dedup:{user_id}:{instrument}:{direction}` | Sorted Set | dedup_window + 60s | Signal deduplication |
| `circuit_breaker:{user_id}` | Hash | -- | Circuit breaker state (failures, tripped_at, cooldown) |
| `market:price:{instrument}` | String | 30s | Latest market price cache |
| `webhook:processed:{webhook_id}` | Set | 300s | Replay attack prevention |
| `broker:health:{user_id}:{broker_type}` | Hash | -- | Broker health check state |

### 7.4 Notification Service Integration

**Purpose**: Deliver alerts for broker failures, fill notifications, circuit breaker trips, risk warnings.
**Integration**: The execution pipeline emits notification events to a message queue. The notification service (PRD-008) consumes and delivers them. [Cross-reference: see FSD-008 for notification delivery details]

**Events Emitted**:

| Event | Priority | Channels |
|---|---|---|
| Order filled | Normal | Dashboard, Telegram (if configured) |
| Order rejected | High | Dashboard, Telegram, Email |
| Broker connection lost | Critical | Dashboard, Telegram, Email |
| Circuit breaker tripped | Critical | Dashboard, Telegram, Email |
| Daily loss limit reached | High | Dashboard, Telegram |
| Position stop loss hit | Normal | Dashboard, Telegram |
| Fill reconciliation discrepancy | High | Dashboard, Email |
| Webhook auth failure (repeated) | High | Email |

### 7.5 Journal Service Integration

**Purpose**: Create journal entries for completed trades.
**Integration**: When a position is closed (any exit reason), the execution pipeline emits a `trade.closed` event containing: position_id, signal_id, instrument, direction, entry_price, exit_price, realized_pnl, r_multiple, mae, mfe, exit_reason, trendline metadata (if available), risk check audit trail reference, and all order events. [Cross-reference: see FSD-004 for journal entry creation]

### 7.6 Analytics Service Integration

**Purpose**: Feed closed trade data to the analytics and playbook engine.
**Integration**: The same `trade.closed` event consumed by the journal service is also consumed by the analytics service for performance tracking, playbook generation, and strategy evaluation. [Cross-reference: see FSD-005 for analytics processing]

---

## 8. Security Specifications

### 8.1 Broker Credential Security

#### 8.1.1 Encryption at Rest (EX-SEC-001)

All broker credentials (API keys, secrets, OAuth tokens, IB Gateway passwords) are encrypted at rest using AES-256-GCM.

**Implementation**:
1. Encryption key is stored in environment variable `BROKER_ENCRYPTION_KEY` (or fetched from a secrets manager such as Railway's built-in secrets or AWS Secrets Manager). The key is 256 bits (32 bytes), hex-encoded in the environment variable.
2. Each credential is encrypted individually. A unique 96-bit (12-byte) nonce is generated per encryption operation using `os.urandom(12)`.
3. The encrypted output is stored as: `nonce (12 bytes) || ciphertext || tag (16 bytes)` in the `connection_params_encrypted` BYTEA column.
4. Decryption retrieves the nonce from the first 12 bytes, the tag from the last 16 bytes, and the ciphertext from the middle.

**Prohibitions**:
- Credentials SHALL NEVER appear in application logs. All logging of broker connection events must mask credential values: `"Tradovate auth with user: t***e"`.
- Credentials SHALL NEVER appear in API responses. The `GET /api/v1/brokers` endpoint returns broker_type and status but never connection_params.
- Credentials SHALL NEVER appear in error messages or stack traces. Exception handlers must sanitize credential data before logging.

#### 8.1.2 Credential Transmission (EX-SEC-002)

- All external broker API calls use TLS 1.2+. The application verifies TLS certificates and rejects connections with invalid or self-signed certificates (except in development mode).
- IB Gateway communication is local (127.0.0.1); socket communication does not traverse the network. If IB Gateway is on a separate host, the connection must use an SSH tunnel or VPN.
- Credentials are never included in URL query parameters. All credentials are sent in request bodies or headers.

#### 8.1.3 Credential Rotation (EX-SEC-003)

- Users can update broker credentials via `PUT /api/v1/brokers/{connection_id}` with new `connection_params`.
- The system validates the new credentials by performing a test connection (`POST /api/v1/brokers/{connection_id}/test`) before replacing the old ones.
- Upon successful validation, the old encrypted credentials are overwritten (not retained).
- The broker adapter is disconnected and reconnected with the new credentials without application restart.

### 8.2 Webhook Security

#### 8.2.1 HMAC Signature Validation (EX-SEC-004)

- The HMAC-SHA256 signature is computed over the raw request body bytes (not parsed JSON).
- The user's webhook secret is used as the HMAC key.
- Signature comparison uses `hmac.compare_digest()` (constant-time) to prevent timing attacks.
- The expected signature format in the `X-Signature` header is: hex-encoded HMAC-SHA256 digest (64 hex characters).

#### 8.2.2 Webhook URL Security (EX-SEC-005)

- Webhook IDs are generated using `secrets.token_urlsafe(32)`, producing 43 characters with 256 bits of entropy.
- Webhook IDs are not sequential, not predictable, and not derived from user data.
- Regenerating a webhook URL immediately invalidates the previous one. There is no grace period.

#### 8.2.3 Replay Attack Prevention (EX-SEC-006)

- If the webhook payload contains a `timestamp` field, the system rejects requests older than 5 minutes: `abs(now - timestamp) > 300 seconds`.
- The system maintains a Redis set (`webhook:processed:{webhook_id}`) of SHA-256 hashes of processed request bodies, with a 5-minute TTL. If a hash matches, the request is rejected as a duplicate.
- Both checks are applied. A request can be rejected by either the timestamp check or the body hash check.

### 8.3 API Key Management

#### 8.3.1 Key Generation (EX-SEC-007)

- API keys are generated using `secrets.token_urlsafe(32)` (256 bits of entropy).
- The plaintext key is shown to the user exactly once upon generation. It is displayed in a copyable field with a warning: "Copy this key now. It will not be shown again."
- The key is stored in the database as a SHA-256 hash. The plaintext is never persisted.
- Users can revoke their API key at any time from the dashboard. Revocation is immediate.
- Users can generate a new key, which automatically revokes the old key.

#### 8.3.2 Key Scoping (EX-SEC-008)

- Default API key scope: `signal:write` only (can submit signals via webhook).
- Additional scopes available: `order:read` (query order status), `position:read` (query positions).
- Scopes are stored as an array in the `api_keys` table.
- Requests with insufficient scope receive HTTP 403: `{"error": "API key does not have required scope: {scope}"}`.

### 8.4 Audit and Compliance

#### 8.4.1 Execution Audit Log (EX-SEC-009)

All order-related actions are logged to the `execution_audit_log` table (append-only):

| Event Type | Logged Data |
|---|---|
| `signal.received` | Source, payload (sanitized), timestamp, IP address |
| `signal.validated` | Validation results, instrument resolution |
| `signal.risk_checked` | All risk check results with values |
| `signal.rejected` | Rejection reason, which check failed |
| `order.submitted` | Broker, order details, client_order_id |
| `order.filled` | Fill price, quantity, commission, timestamp |
| `order.cancelled` | Cancel reason (user/system/OCO), broker response |
| `order.modified` | Original values, new values, modifier (user/system) |
| `position.opened` | Entry details, bracket order IDs |
| `position.closed` | Exit details, P&L, R-multiple |
| `manual.cancel` | User ID, order ID, timestamp |
| `manual.modify` | User ID, order ID, original/new values |
| `manual.close_position` | User ID, position ID, timestamp |
| `manual.flatten_all` | User ID, positions closed count, orders cancelled count |
| `webhook.auth_failed` | Webhook ID, IP address, failure reason |
| `broker.connected` | Broker type, account ID |
| `broker.disconnected` | Broker type, reason |
| `circuit_breaker.tripped` | Consecutive failures, last error |
| `circuit_breaker.reset` | Reset type (manual/auto) |
| `risk_settings.changed` | Setting name, old value, new value |

**Retention**: Minimum 7 years. Records are never deleted by application code. Archival to cold storage after 1 year is managed by the infrastructure layer.

#### 8.4.2 IP Allowlisting for Webhooks (EX-SEC-010)

- Users can optionally configure an IP allowlist for their webhook endpoint via `PUT /api/v1/settings/webhook/ip-allowlist`.
- If configured, only requests from allowed IP addresses are accepted. Others receive HTTP 403: `{"error": "IP address not in allowlist"}`.
- TradingView's known webhook source IP ranges are documented in the dashboard settings and can be pre-configured with a single click.
- IP allowlisting is disabled by default (all IPs accepted).

---

## 9. Performance Specifications

### 9.1 Latency Targets

| Metric | Target (p50) | Target (p95) | Measurement Point |
|---|---|---|---|
| Webhook receipt to HTTP 200 response | < 500ms | < 2s | Time from request received to response sent |
| Webhook receipt to broker order submission | < 3s | < 5s | Time from request received to broker adapter `place_order` call |
| Internal signal to broker order submission | < 1.5s | < 3s | Time from Redis message received to broker adapter call |
| Manual signal to broker order submission | < 1s | < 3s | Time from API request received to broker adapter call |
| Broker order submission to fill acknowledgment (IBKR) | < 500ms | < 2s | Time from `place_order` call to fill event received |
| Broker order submission to fill acknowledgment (Tradovate) | < 1s | < 3s | Time from REST call to WebSocket fill event received |
| Fill event to dashboard update (WebSocket) | < 500ms | < 2s | Time from fill event received to WebSocket push sent |
| End-to-end webhook to dashboard fill display | < 5s | < 10s | Total pipeline latency visible to the user |

### 9.2 Throughput Targets

| Metric | Target | Notes |
|---|---|---|
| Concurrent signal processing | 50 signals/second across all users | Limited by database write throughput |
| Webhook requests per user | 10/minute, 100/hour | Rate limited |
| Manual signals per user | 5/minute | Rate limited |
| Broker API calls (IBKR) | 45/second | IB pacing limit with buffer |
| Broker API calls (Tradovate) | 50/minute per endpoint | Tradovate rate limit |
| WebSocket connections | 500 concurrent | Per application instance |

### 9.3 Availability Targets

| Component | Target | Measurement |
|---|---|---|
| Webhook endpoint | 99.9% uptime | Measured monthly. Max 43 minutes downtime/month. |
| Signal processing pipeline | 99.9% uptime | Zero missed signals over 30 trading days. |
| Broker connection (IBKR) | 99.5% during market hours | Excludes IB's own scheduled maintenance. |
| Broker connection (Tradovate) | 99.5% during market hours | Excludes Tradovate's own scheduled maintenance. |
| Dashboard WebSocket | 99.9% uptime | Reconnection within 5 seconds on drop. |

### 9.4 Resource Utilization

| Resource | Expected Usage | Alert Threshold |
|---|---|---|
| Database connections | 20 per application instance | > 80 connections |
| Redis memory | < 500 MB for rate limiting, dedup, cache | > 1 GB |
| Application memory | < 512 MB per instance | > 1 GB |
| CPU per signal | < 50ms processing time | > 200ms |

---

## 10. Testing Specifications

### 10.1 Unit Tests

#### 10.1.1 Signal Normalization Tests

| Test ID | Test Case | Input | Expected Output |
|---|---|---|---|
| UT-SN-001 | Normalize webhook buy signal | `{"ticker":"NQ1!","action":"buy","price":18450.25}` | Signal with instrument=resolved MNQ contract, direction=LONG, entry_type=MARKET |
| UT-SN-002 | Normalize webhook sell signal | `{"ticker":"ES1!","action":"sell","price":5200.50}` | Signal with direction=SHORT |
| UT-SN-003 | Normalize webhook close signal (LONG position open) | `{"ticker":"NQ1!","action":"close","price":18460}` | Signal with direction=SHORT (opposite of open position) |
| UT-SN-004 | Normalize webhook close signal (no position) | `{"ticker":"NQ1!","action":"close","price":18460}` | Signal REJECTED, reason: "NO_OPEN_POSITION_TO_CLOSE" |
| UT-SN-005 | Alternative field names | `{"symbol":"NQ1!","side":"buy","sl":18420,"tp":18510}` | Fields mapped correctly to canonical names |
| UT-SN-006 | R:R calculation LONG | entry=18450, stop=18430, target=18490 | R:R = (18490-18450)/(18450-18430) = 2.00 |
| UT-SN-007 | R:R calculation SHORT | entry=18450, stop=18470, target=18410 | R:R = (18450-18410)/(18470-18450) = 2.00 |
| UT-SN-008 | R:R when stop equals entry | entry=18450, stop=18450 | R:R = null, warning logged |

#### 10.1.2 Price Validation Tests

| Test ID | Test Case | Input | Expected |
|---|---|---|---|
| UT-PV-001 | Entry within tolerance | entry=18450, market=18440 (0.05% diff) | PASS |
| UT-PV-002 | Entry outside tolerance | entry=18450, market=17000 (8.5% diff) | FAIL: "Entry price 18450 is more than 5% from current market price 17000" |
| UT-PV-003 | Stop below entry for LONG | direction=LONG, entry=18450, stop=18430 | PASS |
| UT-PV-004 | Stop above entry for LONG | direction=LONG, entry=18450, stop=18470 | FAIL: "Stop loss (18470) must be below entry price (18450) for LONG positions" |
| UT-PV-005 | Stop above entry for SHORT | direction=SHORT, entry=18450, stop=18470 | PASS |
| UT-PV-006 | Stop below entry for SHORT | direction=SHORT, entry=18450, stop=18430 | FAIL: "Stop loss (18430) must be above entry price (18450) for SHORT positions" |
| UT-PV-007 | Stop distance less than 1 tick (MNQ) | entry=18450.00, stop=18449.90, tick=0.25 | FAIL: "Stop distance (0.10) must be at least 1 tick (0.25)" |
| UT-PV-008 | Stop distance exactly 1 tick | entry=18450.00, stop=18449.75, tick=0.25 | PASS |

#### 10.1.3 Risk Check Tests

| Test ID | Test Case | Input | Expected |
|---|---|---|---|
| UT-RC-001 | Position size within limit | existing=1, proposed=1, max=2 | PASS |
| UT-RC-002 | Position size exceeds limit | existing=2, proposed=1, max=2 | FAIL: "Maximum position size exceeded for MNQ. Current: 2, Proposed: 1, Maximum: 2" |
| UT-RC-003 | Daily loss within limit | daily_pnl=-$200, limit=$500 | PASS |
| UT-RC-004 | Daily loss at limit | daily_pnl=-$500, limit=$500 | FAIL: "Daily loss limit reached..." |
| UT-RC-005 | Worst case exceeds limit | daily_pnl=-$400, new_risk=$150, limit=$500 | FAIL (worst case: -$550 > -$500) |
| UT-RC-006 | Concurrent positions within limit | open=2, max=3 | PASS |
| UT-RC-007 | Concurrent positions at limit | open=3, max=3 | FAIL: "Maximum concurrent positions reached. Open: 3, Maximum: 3" |
| UT-RC-008 | R:R above minimum | rr=2.5, min=2.0 | PASS |
| UT-RC-009 | R:R below minimum | rr=1.5, min=2.0 | FAIL: "Risk-reward ratio 1.5 is below minimum 2.0..." |
| UT-RC-010 | Correlation warn mode | MNQ open, new MES signal, corr=0.95, action=warn | WARN with message |
| UT-RC-011 | Correlation block mode | MNQ open, new MES signal, corr=0.95, action=block | FAIL |
| UT-RC-012 | No correlation concern | MNQ open, new MGC signal, corr=0.15, threshold=0.7 | PASS |

#### 10.1.4 Order Quantity Calculation Tests

| Test ID | Test Case | Input | Expected |
|---|---|---|---|
| UT-QC-001 | Standard calculation | risk=$100, stop=40 ticks, tick_val=$0.50 | qty=5 (100/20=5) |
| UT-QC-002 | Clamped to max | risk=$100, stop=10 ticks, tick_val=$0.50, max=2 | qty=2 (floor(100/5)=20, clamped to 2) |
| UT-QC-003 | Minimum of 1 | risk=$100, stop=300 ticks, tick_val=$0.50 | qty=1 (floor(100/150)=0, min=1) + warning |
| UT-QC-004 | Exact division | risk=$100, stop=200 ticks, tick_val=$0.50 | qty=1 (floor(100/100)=1) |

#### 10.1.5 Symbol Mapping Tests

| Test ID | Test Case | Input | Expected |
|---|---|---|---|
| UT-SM-001 | NQ1! to micro front month | NQ1!, user prefers micro, current date Feb 2026, March contract active | MNQH6 |
| UT-SM-002 | NQ1! to full-size | NQ1!, user prefers full-size | NQH6 |
| UT-SM-003 | Near rollover (3 days before expiry) | March contract expires in 2 business days | Maps to June contract (MNQM6) |
| UT-SM-004 | Exact contract specified | MNQH6 (not continuous) | No mapping needed, passed through |
| UT-SM-005 | Expired contract | MNQZ5 when current is Feb 2026 | REJECTED: "Contract MNQZ5 has expired. Current front month is MNQH6" |

#### 10.1.6 Paper Fill Simulation Tests

| Test ID | Test Case | Input | Expected |
|---|---|---|---|
| UT-PF-001 | Market BUY with 1 tick slippage | MNQ, BUY, price=18450.00, slippage=1 tick | fill_price=18450.25 |
| UT-PF-002 | Market SELL with 1 tick slippage | MNQ, SELL, price=18450.00, slippage=1 tick | fill_price=18449.75 |
| UT-PF-003 | Full-size with 2 tick slippage | NQ, BUY, price=18450.00, slippage=2 ticks | fill_price=18450.50 |
| UT-PF-004 | Zero slippage configured | MNQ, BUY, price=18450.00, slippage=0 | fill_price=18450.00 |
| UT-PF-005 | Limit order fill | MNQ, LIMIT BUY at 18440.00 | fill_price=18440.00 (no slippage on limits in MVP) |

#### 10.1.7 Circuit Breaker Tests

| Test ID | Test Case | Input | Expected |
|---|---|---|---|
| UT-CB-001 | 2 failures, not tripped | 2 consecutive failures, threshold=3 | Circuit breaker NOT tripped, counter=2 |
| UT-CB-002 | 3 failures, tripped | 3 consecutive failures, threshold=3 | Circuit breaker TRIPPED, no further orders |
| UT-CB-003 | Success resets counter | 2 failures then 1 success | Counter reset to 0 |
| UT-CB-004 | Auto-reset after cooldown | Tripped, wait 15 minutes | Circuit breaker RESET, orders resume |
| UT-CB-005 | Manual reset | Tripped, user clicks reset | Circuit breaker RESET, orders resume |

### 10.2 Integration Tests

#### 10.2.1 IBKR Adapter Tests (EX-TEST-006)

Using mock `ib_async.IB` client:
- Test connection establishment and automatic reconnection after simulated disconnect.
- Test market order submission: verify correct Contract and Order objects are constructed.
- Test limit order submission: verify lmtPrice is set correctly.
- Test bracket order submission: verify parent-child relationship, OCA group, and transmit flags.
- Test fill event processing: simulate `execDetails` callback, verify order status updated to FILLED with correct fill_price and commission.
- Test partial fill: simulate partial `execDetails`, verify PARTIAL_FILL status and remaining quantity tracking.
- Test order cancellation: verify cancel request and status update.
- Test error handling for IB error codes: 110 (reject), 201 (reject), 502 (reconnect), 1100 (reconnect + notify).

#### 10.2.2 Tradovate Adapter Tests (EX-TEST-007)

Using `httpx` mock responses and mock WebSocket:
- Test OAuth token acquisition: mock successful auth response, verify token stored.
- Test token refresh at 50 minutes: verify proactive refresh before expiry.
- Test token refresh failure (3 retries): verify connection marked as FAILED after 3 failures.
- Test order submission via REST: mock 200 response, verify order details.
- Test OSO bracket order submission: verify correct JSON structure.
- Test WebSocket order event processing: mock fill event, verify order updated.
- Test WebSocket heartbeat: verify ping sent every 2.5 seconds.
- Test HTTP 401 during order -> token refresh -> retry: verify seamless recovery.
- Test HTTP 429 rate limiting: verify exponential backoff.

#### 10.2.3 Adapter Interface Compliance (EX-TEST-008)

Parameterized test suite that runs against every `BrokerAdapter` implementation:
- Verify all abstract methods are implemented (no `NotImplementedError`).
- Verify `connect()` returns `ConnectionStatus`.
- Verify `place_order()` returns `OrderResult`.
- Verify `place_bracket_order()` returns `BracketOrderResult`.
- Verify exceptions are typed (`BrokerConnectionError`, `OrderRejectedError`, etc.).

### 10.3 End-to-End Tests

#### 10.3.1 Webhook-to-Paper-Trade Flow (EX-TEST-009)

1. POST a TradingView-formatted webhook to the test user's webhook URL.
2. Verify HTTP 200 response with signal_id within 2 seconds.
3. Wait up to 10 seconds for async processing.
4. Query `GET /api/v1/signals/{signal_id}` and verify status is `FILLED`.
5. Query `GET /api/v1/positions` and verify a new OPEN position exists with correct instrument, direction, entry_price (with slippage), stop_loss, and take_profit.
6. Verify `risk_check_audit` records exist for all risk checks.
7. Verify `order_events` records show the state transitions: CONSTRUCTED -> SUBMITTED -> FILLED.

#### 10.3.2 Risk Check Rejection Flow (EX-TEST-012)

For each risk check:
1. Set up preconditions that will cause the check to fail (e.g., open max positions for concurrent position test).
2. Submit a signal via webhook.
3. Verify the signal is REJECTED with the correct rejection_reason.
4. Verify no order was created.
5. Verify `risk_check_audit` shows the FAIL result with actual and threshold values.

#### 10.3.3 Duplicate Signal Rejection (EX-TEST-013)

1. Submit a webhook signal (ticker=NQ1!, action=buy, price=18450).
2. Wait 1 second.
3. Submit the identical signal again.
4. Verify the first signal is processed (status=FILLED or EXECUTING).
5. Verify the second signal is REJECTED with reason "DUPLICATE_SIGNAL".
6. Verify only one order exists.

### 10.4 Failover Tests

#### 10.4.1 Broker Disconnection During Order (EX-TEST-014)

1. Start an order submission.
2. Simulate broker connection drop mid-submission (mock the adapter to raise `BrokerConnectionError` after sending the order but before receiving confirmation).
3. Verify the circuit breaker counter increments.
4. Verify the user receives a notification (check notification queue).
5. Simulate reconnection.
6. Verify the system queries the broker for the order status.
7. If the broker confirms the order was placed, verify TrendEdge updates its records accordingly.

#### 10.4.2 Circuit Breaker Trip and Reset (EX-TEST-015)

1. Simulate 3 consecutive broker failures (connection timeouts).
2. Verify circuit breaker trips after the 3rd failure.
3. Submit a new signal. Verify it is queued (not rejected, but not submitted to broker).
4. Verify notification sent to user.
5. Wait for cooldown period (use fast-forward in test). Verify circuit breaker auto-resets.
6. Verify the queued signal is now processed.

#### 10.4.3 Double Fill Detection (EX-TEST-046-edge)

1. Simulate a scenario where both stop loss and take profit fill simultaneously (race condition).
2. Verify the system detects the double fill.
3. Verify an alert is sent to the user: "Double fill detected for position {id}. Both stop loss and take profit filled. Please check your broker account."
4. Verify the position is marked as CLOSED with a discrepancy flag.

### 10.5 Latency Benchmarks (EX-TEST-018, EX-TEST-019)

#### 10.5.1 Pipeline Latency Benchmark

Test conditions and targets:

| Condition | Signals | p50 Target | p95 Target |
|---|---|---|---|
| Baseline (single signal, no positions) | 1 | < 2s | < 5s |
| Moderate load (10 concurrent, different users) | 10 | < 3s | < 8s |
| Stress (50 concurrent, different users) | 50 | < 5s | < 10s |

#### 10.5.2 Broker API Latency Tracking

Daily benchmark (paper mode):
1. Submit a LIMIT order far from market (will not fill).
2. Measure round-trip time to broker acknowledgment.
3. Cancel the order.
4. Measure cancel round-trip time.
5. Log results with timestamp for trend analysis.

Expected baselines:
- IBKR: < 500ms round-trip (local IB Gateway).
- Tradovate: < 1s round-trip (REST API).
- Alert if > 5x baseline.

### 10.6 Security Tests

| Test ID | Test Case | Expected |
|---|---|---|
| ST-001 | POST webhook with invalid API key | HTTP 401 |
| ST-002 | POST webhook with valid HMAC, then tamper body | HTTP 401 |
| ST-003 | POST webhook with timestamp 10 min old | HTTP 400 (stale) |
| ST-004 | POST same webhook body twice in 5 min | Second rejected as duplicate |
| ST-005 | POST 20 webhooks in 1 minute | First 10 accepted, remaining get 429 |
| ST-006 | Search all logs for test broker credentials | Zero matches |
| ST-007 | GET /api/v1/brokers returns credentials | Credentials NOT in response |
| ST-008 | POST webhook from non-allowlisted IP (when allowlist active) | HTTP 403 |
| ST-009 | 10 failed webhook auth attempts in 1 hour | Webhook temporarily suspended |
| ST-010 | Access another user's signal via API | HTTP 404 (not 403, to avoid information leakage) |

---

## 11. Migration & Deployment

### 11.1 Database Migrations

#### Phase 1 Migrations (Paper Trading Foundation)

**Migration 001**: Create `contract_specifications` table and seed with initial instrument data (MNQ, MES, MYM, M2K, MGC, MCL, SIL, NQ, ES).

**Migration 002**: Create `contract_calendar` table and seed with futures contract months for 2026 (H6, M6, U6, Z6 for equity indices; G6, J6, M6, Q6, V6, Z6 for metals/energy as applicable).

**Migration 003**: Create `signals` table with all columns and indexes.

**Migration 004**: Create `orders` table with all columns and indexes.

**Migration 005**: Create `order_events` table with indexes.

**Migration 006**: Create `positions` table with all columns and indexes.

**Migration 007**: Create `risk_check_audit` table with indexes.

**Migration 008**: Create `webhook_urls` table with indexes.

**Migration 009**: Create `broker_connections` table with indexes.

**Migration 010**: Create `user_risk_settings` table with indexes. Insert default settings for all existing users.

**Migration 011**: Create `risk_settings_changelog` table with indexes.

**Migration 012**: Create `execution_audit_log` table with indexes.

**Migration 013**: Create `instrument_correlations` table and seed with correlation data.

#### Migration Rollback

Each migration includes a `down()` method that reverses the schema change. Rollback order is the reverse of migration order. Data inserted by seed operations is removed in the rollback.

### 11.2 Deployment Strategy

#### Phase 1 Deployment (Paper Trading)

1. **Pre-deployment**:
   - Run all database migrations on staging environment.
   - Verify all integration tests pass against staging.
   - Verify IB Gateway connectivity from the VPS.
   - Verify Tradovate demo API connectivity.

2. **Deployment Steps**:
   a. Deploy database migrations to production.
   b. Deploy application code with feature flag `EXECUTION_PIPELINE_ENABLED=false`.
   c. Verify application starts without errors.
   d. Enable the execution pipeline: set `EXECUTION_PIPELINE_ENABLED=true`.
   e. Run smoke test: submit a webhook signal for a paper user, verify paper trade created.
   f. Monitor logs and metrics for 30 minutes.

3. **Rollback Plan**:
   - Set `EXECUTION_PIPELINE_ENABLED=false` to disable the pipeline without redeployment.
   - If database issues: run migration rollbacks in reverse order.
   - If broker adapter issues: disable specific broker adapters via feature flags (`IBKR_ENABLED`, `TRADOVATE_ENABLED`).

#### Phase 2 Deployment (Live Trading)

1. **Pre-deployment**:
   - Complete 30 trading days of paper trading with zero missed signals.
   - Verify fill reconciliation accuracy.
   - Conduct security review of credential handling.
   - Load test with 50 concurrent signals.

2. **Deployment Steps**:
   a. Deploy code with `LIVE_TRADING_ENABLED=false`.
   b. Verify paper trading continues to work correctly.
   c. Enable live trading: set `LIVE_TRADING_ENABLED=true`.
   d. First live trade must be manually triggered by an engineer (not automated).
   e. Monitor the first 10 live trades with real-time log observation.

3. **Rollback Plan**:
   - Set `LIVE_TRADING_ENABLED=false`. All users revert to paper mode.
   - Any open live positions remain with the broker and must be managed directly through the broker's own interface.
   - Users are notified: "Live trading has been temporarily disabled. Please manage any open positions directly with your broker."

### 11.3 Environment Configuration

| Variable | Description | Example |
|---|---|---|
| `EXECUTION_PIPELINE_ENABLED` | Master switch for execution pipeline | `true` |
| `LIVE_TRADING_ENABLED` | Enable live trading (paper always available) | `false` |
| `IBKR_ENABLED` | Enable IBKR adapter | `true` |
| `TRADOVATE_ENABLED` | Enable Tradovate adapter | `true` |
| `IBKR_GATEWAY_HOST` | IB Gateway hostname | `127.0.0.1` |
| `IBKR_GATEWAY_PORT_LIVE` | IB Gateway live port | `4001` |
| `IBKR_GATEWAY_PORT_PAPER` | IB Gateway paper port | `4002` |
| `BROKER_ENCRYPTION_KEY` | AES-256 key for credential encryption | (hex-encoded 32 bytes) |
| `INTERNAL_SERVICE_TOKEN` | Auth token for internal signal source | (generated secret) |
| `REDIS_URL` | Redis connection string | `redis://localhost:6379/0` |
| `CIRCUIT_BREAKER_THRESHOLD` | Consecutive failures before trip | `3` |
| `CIRCUIT_BREAKER_COOLDOWN_SECONDS` | Auto-reset cooldown period | `900` |

---

## 12. Open Questions & Assumptions

### 12.1 Open Questions

| ID | Question | Impact | Status |
|---|---|---|---|
| OQ-001 | Should the paper trading simulator use real-time market data for stop/target triggers, or is periodic polling (every 5 seconds) sufficient for MVP? | Affects paper fill accuracy and resource usage. | Open -- MVP uses polling; real-time data enhancement deferred. |
| OQ-002 | What is the exact IB Gateway deployment model? One gateway instance per user, or shared gateway with multiple clientIds? | Affects VPS resource planning and connection management. | Open -- Assumed shared gateway with unique clientIds per user. |
| OQ-003 | Should the system support partial position closes (close 1 of 3 contracts), or only full position closes in MVP? | Affects order construction and position tracking complexity. | Open -- MVP supports full close only. Partial close deferred. |
| OQ-004 | How should the system handle signals that arrive during market holidays or weekends? Queue them for market open, or reject immediately? | Affects user experience for weekend strategy setup. | Open -- Assumed reject with clear message about market hours. |
| OQ-005 | What is the Webull futures API availability and authentication model? | Affects Phase 3 timeline. | Open -- Webull adapter is P1 (Phase 3). API documentation review needed. |
| OQ-006 | Should the correlation matrix be static (pre-configured) or dynamically computed from recent price data? | Affects accuracy and compute requirements. | Open -- MVP uses static matrix. Dynamic computation deferred. |
| OQ-007 | How should the system handle broker-side margin calls or forced liquidations? | Affects position tracking and reconciliation. | Open -- Assumed detection via position reconciliation with exit_reason `BROKER_LIQUIDATION`. |

### 12.2 Assumptions

| ID | Assumption | Risk if Wrong |
|---|---|---|
| AS-001 | IB Gateway will be hosted on the same VPS as the application, enabling local socket communication with <1ms latency. | If IB Gateway is remote, latency increases and TLS/SSH tunnel is required. |
| AS-002 | TradingView webhook delivery latency (2-60 seconds) is acceptable and outside TrendEdge's control. | If users expect sub-second signal delivery from TradingView, expectations must be managed. |
| AS-003 | Redis is available and persistent for rate limiting, deduplication, and circuit breaker state. Redis data loss results in temporary loss of these protections. | If Redis fails, rate limiting fails open (allows requests) and deduplication is temporarily disabled. |
| AS-004 | Users will have at most 1-2 active broker connections. The system does not need to optimize for users with 10+ broker connections. | Multi-account routing may need optimization if prop firm support requires many connections. |
| AS-005 | The paper trading simulator with periodic polling (5-second intervals) provides sufficient accuracy for validation purposes. Exact-tick simulation is not required for MVP. | Paper results may differ from live results by 1-2 ticks in fast-moving markets. This is acceptable. |
| AS-006 | CME/CBOT/NYMEX/COMEX micro futures contracts will remain the primary instruments. Support for other exchanges (Eurex, ICE) is not needed in the initial release. | If users request non-US futures, the instrument validation and symbol mapping tables need expansion. |
| AS-007 | The commission schedule is relatively stable. Commission tracking uses broker-reported values when available, with fallback to configured schedules. | If brokers change commission structures frequently, the fallback schedule may become inaccurate. |
| AS-008 | The PostgreSQL database with proper indexing can handle the expected write volume (signals, orders, order_events, audit logs) without performance degradation. | If write volume exceeds expectations, consider partitioning the order_events and execution_audit_log tables by date. |

---

## 13. Appendices

### Appendix A: Signal Processing Pipeline Flowchart

```
Signal Received
    |
    v
[Normalize] -- Map fields to canonical format
    |
    v
[Authenticate] -- Verify source credentials
    |    |
    |    +--> FAIL: Reject (401/REJECTED)
    |
    v
[Validate Instrument] -- Check supported instruments, resolve symbols
    |    |
    |    +--> FAIL: Reject ("Unsupported instrument")
    |
    v
[Validate Prices] -- Entry tolerance, stop/target sides, min stop distance
    |    |
    |    +--> FAIL: Reject (specific price validation error)
    |
    v
[Check Staleness] -- Signal age < staleness threshold
    |    |
    |    +--> FAIL: Reject ("Signal too old")
    |
    v
[Deduplicate] -- Check dedup window for same user/instrument/direction/price
    |    |
    |    +--> DUPLICATE: Reject ("DUPLICATE_SIGNAL")
    |
    v
[Enrich] -- Add contract specs, compute R:R, add market/account context
    |
    v
[Risk Check: Position Size] -- existing + proposed <= max
    |    |
    |    +--> FAIL: Reject ("Max position size exceeded")
    |
    v
[Risk Check: Daily Loss Limit] -- worst case P&L within limit
    |    |
    |    +--> FAIL: Reject ("Daily loss limit exceeded")
    |
    v
[Risk Check: Concurrent Positions] -- open count < max
    |    |
    |    +--> FAIL: Reject ("Max concurrent positions reached")
    |
    v
[Risk Check: R:R Ratio] -- R:R >= minimum
    |    |
    |    +--> FAIL: Reject ("R:R below minimum")
    |
    v
[Risk Check: Correlation] -- check correlated positions
    |    |
    |    +--> FAIL (block mode): Reject ("Correlation limit exceeded")
    |    +--> WARN (warn mode): Continue with warning
    |
    v
[Risk Check: Max Single Trade Risk] -- risk per trade <= max
    |    |
    |    +--> FAIL: Reject ("Single trade risk exceeds maximum")
    |
    v
[Risk Check: Trading Hours] -- current session matches user preference
    |    |
    |    +--> FAIL: Reject ("Trading not allowed during {session}")
    |
    v
[Calculate Quantity] -- floor(fixed_risk / risk_per_contract), clamp to max
    |
    v
[Construct Bracket Order] -- Entry + Stop Loss + Take Profit (OCO)
    |
    v
[Route to Broker] -- Select adapter based on user config
    |    |
    |    +--> Paper Mode: Paper Simulator
    |    +--> Live Mode: IBKR / Tradovate adapter
    |
    v
[Submit Order] -- Send to broker, handle response
    |    |
    |    +--> SUCCESS: Order SUBMITTED, await fill
    |    +--> FAILURE: Increment circuit breaker, notify user
    |
    v
[Monitor Fills] -- Listen for broker events
    |
    v
[Fill Received] -- Record fill, calculate slippage, update position
    |
    v
[OCO Management] -- Cancel paired order (SL or TP)
    |
    v
[Post-Fill] -- Create journal entry, emit analytics event, notify user
```

### Appendix B: Order State Machine Diagram

```
                        +-------------+
                        | CONSTRUCTED |
                        +------+------+
                               |
                         place_order()
                               |
                        +------v------+
                   +--->| SUBMITTED   |<---+
                   |    +------+------+    |
                   |           |           |
                   |     +-----+-----+    |
                   |     |           |    |
                   |     v           v    |
              +----+-----+   +------+----+-+
              | REJECTED  |   | PENDING     |
              | (terminal)|   +------+------+
              +-----------+          |
                               +-----+-----+
                               |           |
                               v           v
                        +------+------+ +--+--------+
                        | PARTIAL_FILL| | CANCELLED  |
                        +------+------+ | (terminal) |
                               |        +-----------+
                               v
                        +------+------+
                        | FILLED      |
                        +------+------+
                               |
                         position exit
                               |
                        +------v------+
                        | CLOSED      |
                        | (terminal)  |
                        +-------------+
```

**Valid State Transitions**:

| From | To | Trigger | Side Effects |
|---|---|---|---|
| CONSTRUCTED | SUBMITTED | `place_order()` called on broker adapter | `submitted_at` set, `order_events` record created |
| SUBMITTED | PENDING | Broker acknowledges order (limit/stop working) | `order_events` record created |
| SUBMITTED | FILLED | Market order filled immediately | `filled_at` set, fill details recorded, position created/updated |
| SUBMITTED | REJECTED | Broker rejects order | `rejection_reason` set, signal status updated, user notified |
| PENDING | FILLED | Limit/stop price reached and filled | Same as SUBMITTED->FILLED |
| PENDING | PARTIAL_FILL | Part of quantity filled | Partial fill details recorded |
| PENDING | CANCELLED | User cancels, OCO triggers, circuit breaker | `cancelled_at` set, cancel reason logged |
| PARTIAL_FILL | FILLED | Remaining quantity filled | Same as PENDING->FILLED |
| PARTIAL_FILL | CANCELLED | User cancels remaining quantity | Partial position may exist |
| FILLED | CLOSED | Position fully exited (SL, TP, manual close) | `exit_reason` set, journal entry created |

### Appendix C: Commission Schedule

| Broker | Instrument Type | Per-Contract Per-Side | Notes |
|---|---|---|---|
| IBKR | Micro futures | $0.25 - $0.85 | Varies by monthly volume tier. Default estimate: $0.62 |
| IBKR | Full-size futures | $0.85 | Standard rate |
| Tradovate | Micro futures | $0.79 | Standard pricing. Funded accounts may have $0 commissions. |
| Tradovate | Full-size futures | $1.29 | Standard pricing |
| Webull | Micro futures | ~$0.25 + exchange fees | Approximate; varies |

Exchange fees (approximate, per side):
- CME E-mini/Micro: $0.27 - $0.47
- CBOT: $0.25 - $0.45
- NYMEX: $0.25 - $0.50
- COMEX: $0.25 - $0.50

### Appendix D: Instrument Correlation Matrix

| | MNQ | MES | MYM | M2K | MGC | MCL | SIL |
|---|---|---|---|---|---|---|---|
| **MNQ** | 1.00 | 0.95 | 0.88 | 0.82 | 0.15 | 0.10 | 0.12 |
| **MES** | 0.95 | 1.00 | 0.92 | 0.85 | 0.18 | 0.12 | 0.14 |
| **MYM** | 0.88 | 0.92 | 1.00 | 0.80 | 0.20 | 0.15 | 0.16 |
| **M2K** | 0.82 | 0.85 | 0.80 | 1.00 | 0.12 | 0.08 | 0.10 |
| **MGC** | 0.15 | 0.18 | 0.20 | 0.12 | 1.00 | 0.25 | 0.75 |
| **MCL** | 0.10 | 0.12 | 0.15 | 0.08 | 0.25 | 1.00 | 0.30 |
| **SIL** | 0.12 | 0.14 | 0.16 | 0.10 | 0.75 | 0.30 | 1.00 |

Note: Full-size contracts (NQ, ES) have correlation 1.00 with their micro counterparts (MNQ, MES).

### Appendix E: Futures Month Codes Reference

| Code | Month | | Code | Month |
|---|---|---|---|---|
| F | January | | N | July |
| G | February | | Q | August |
| H | March | | U | September |
| J | April | | V | October |
| K | May | | X | November |
| M | June | | Z | December |

**Example**: `MNQH6` = Micro E-mini Nasdaq-100, March 2026.

**Equity Index Quarterly Contracts**: H (March), M (June), U (September), Z (December).

### Appendix F: Contract Specifications Quick Reference

| Symbol | Tick Size | Tick Value | Point Value | Exchange | Day Margin (approx) |
|---|---|---|---|---|---|
| MNQ | 0.25 | $0.50 | $2.00 | CME | ~$920 |
| MES | 0.25 | $1.25 | $5.00 | CME | ~$660 |
| MYM | 1.00 | $0.50 | $0.50 | CBOT | ~$440 |
| M2K | 0.10 | $0.50 | $5.00 | CME | ~$360 |
| MGC | 0.10 | $1.00 | $10.00 | COMEX | ~$780 |
| MCL | 0.01 | $1.00 | $100.00 | NYMEX | ~$590 |
| SIL | 0.005 | $2.50 | $500.00 | COMEX | ~$930 |
| NQ | 0.25 | $5.00 | $20.00 | CME | ~$9,200 |
| ES | 0.25 | $12.50 | $50.00 | CME | ~$6,600 |

---

## Changelog

- 2026-02-11: Initial FSD created from PRD-003 v1.0 -- Generated by Claude

---

*FSD-003 v1.0 -- Trade Execution*
*TrendEdge -- February 2026*
