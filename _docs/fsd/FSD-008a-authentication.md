# FSD-008a: Authentication

**TrendEdge â€” AI-Powered Futures Trading Platform**

| Field | Value |
|---|---|
| FSD ID | FSD-008a |
| Source FSD | FSD-008 (Authentication & User Management) |
| Source PRD | PRD-008 |
| Title | Authentication |
| Version | 1.0 |
| Status | Draft |
| Author | Generated by Claude |
| Created | 2026-02-12 |

---

## Sibling Sub-FSDs

FSD-008 has been split into the following focused sub-documents:

| Sub-FSD | Scope |
|---------|-------|
| **FSD-008a** (this document) | Registration, login, OAuth, magic links, email verification, password reset, JWT handling, refresh token rotation, session management |
| FSD-008b | User profiles, trading preferences, notification preferences, display settings |
| FSD-008c | Broker connection management, credential encryption, connection health monitoring, credential refresh |
| FSD-008d | Authorization (RBAC, RLS), admin access, teams/organizations, account lifecycle (export, deletion), API key management |

---

## 1. Introduction

### 1.1 Purpose

This sub-FSD specifies the complete authentication layer for TrendEdge: how users register, prove their identity, maintain sessions, and recover access. It covers every user-visible behavior, error state, and state transition required for a developer to implement authentication without ambiguity.

TrendEdge handles sensitive financial data including broker API credentials, trading history, and proprietary strategies. A breach could result in direct financial loss. Every specification here is designed with security-by-default, defense-in-depth, and least-privilege access as foundational principles.

### 1.2 Scope

This document covers:

- **User Registration** -- Email/password, OAuth (Google, GitHub), magic link flows
- **Email Verification** -- Verification enforcement, feature restrictions for unverified users
- **Password Reset** -- Secure reset flow with no information leakage
- **JWT Token Lifecycle** -- Access token handling, storage, validation
- **Refresh Token Rotation** -- Automatic refresh, theft detection, cross-tab coordination
- **Session Expiry** -- Inactivity timeout with user warning
- **Multi-Device Session Management** -- Session listing, revocation

This document does NOT cover:
- User profile CRUD, trading preferences, notification preferences -- see **FSD-008b**
- Broker connection management, credential encryption -- see **FSD-008c**
- RBAC, RLS, admin access, teams, account lifecycle, API keys -- see **FSD-008d**

### 1.3 Phased Delivery

| Phase | Timeline | Auth Scope |
|-------|----------|------------|
| Phase 1 | Weeks 1-2 | Email/password registration and login, JWT handling, refresh token rotation, basic session management, inactivity timeout |
| Phase 2 | Weeks 9-14 | Magic links, OAuth (Google, GitHub), email verification enforcement, password reset, multi-device session management, hCaptcha brute force protection |
| Phase 3 | Weeks 15-22 | Team invitation acceptance flow (cross-ref FSD-008d), onboarding wizard integration |

### 1.4 Auth Provider

**Supabase Auth** is the authentication provider. It provides:
- OAuth 2.0 and OpenID Connect flows
- Magic link (passwordless) authentication
- JWT-based session tokens with configurable expiry
- Row Level Security integration with PostgreSQL
- Built-in email verification and password reset flows

### 1.5 Dependencies

| Dependency | What This FSD Needs |
|------------|---------------------|
| Supabase Auth | User registration, JWT issuance, OAuth integration, email delivery |
| Redis (Upstash) | Rate limiting counters, failed login counters, token blacklist |
| SendGrid/Resend | Transactional emails (verification, reset, security notifications) |
| PostgreSQL (Supabase) | Users table, audit logs, database triggers |

---

## 2. System Context

### 2.1 Architecture Overview

```
+-------------------+       +-------------------+       +-------------------+
|   React Frontend  | <---> |  FastAPI Backend   | <---> |    PostgreSQL      |
|   (Next.js)       |       |  (Python 3.11+)   |       |    (Supabase)      |
+-------------------+       +-------------------+       +-------------------+
        |                           |                           |
        |                   +-------+-------+           +-------+-------+
        |                   |    Redis      |           |   RLS Policies |
        |                   |   (Upstash)   |           |   (Per-table)  |
        |                   +---------------+           +---------------+
        |
+-------+-------+                               +-------------------+
| Supabase Auth  |                               |   SendGrid/       |
| (OAuth, JWT)   |                               |   Resend (Email)  |
+---------------+                               +-------------------+
```

### 2.2 Component Responsibilities (Auth-Specific)

| Component | Auth Responsibility |
|-----------|---------------------|
| **React Frontend (Next.js)** | Registration/login forms, session state via Supabase JS SDK, token storage in memory, inactivity timeout tracking, auth UI rendering |
| **FastAPI Backend** | JWT validation, RLS context injection (`SET request.jwt.claim.sub`), rate limiting enforcement, audit logging |
| **Supabase Auth** | User registration, JWT issuance, refresh token rotation, OAuth provider integration, magic link generation, email verification, password reset email delivery |
| **PostgreSQL (Supabase)** | User data storage, database triggers for new user setup |
| **Redis (Upstash)** | Rate limiting counters (sliding window), token blacklist for revoked sessions, failed login counters |
| **SendGrid/Resend** | Transactional emails: verification, password reset, security notifications (stolen token) |

### 2.3 External Actor Interactions

| Actor | Interaction | Authentication Method |
|-------|------------|----------------------|
| Anonymous visitor | Registration, login, password reset, OAuth redirect | None (public endpoints) |
| Authenticated user | Access to all platform features | JWT Bearer token in Authorization header |

---

## 3. Functional Specifications

### 3.1 FR-001: Email/Password Registration

**Source:** PRD AU-FR-001 | **Phase:** 1 | **Priority:** P0

#### Description

The system provides email/password registration using Supabase Auth. On successful registration, a corresponding row is created in the `public.users` table via a database trigger, populated with default settings. The user receives a verification email.

#### Inputs

| Field | Type | Validation | Required |
|-------|------|-----------|----------|
| email | string | RFC 5322 format; case-insensitive (lowercased before storage) | Yes |
| password | string | Minimum 8 characters, at least 1 uppercase letter, at least 1 lowercase letter, at least 1 digit, at least 1 special character from `!@#$%^&*` | Yes |
| confirm_password | string | Must exactly match `password` | Yes |

#### Processing Logic

1. User navigates to `/register`. The page renders a form with three fields: email, password, confirm password.
2. **Client-side validation (before submit):**
   - Email is validated against RFC 5322 format in real time as the user types (debounced 300ms).
   - Password is validated against all four complexity rules. A real-time strength indicator displays: "Weak" (red, <3 rules met), "Fair" (orange, 3 rules met), "Strong" (green, all 4 rules met, 8-11 chars), "Very Strong" (green, all 4 rules met, 12+ chars).
   - Confirm password is validated to match password as the user types.
   - The "Register" button is disabled until all three validations pass.
3. **On submit:** The frontend calls `supabase.auth.signUp({ email, password })`.
4. **On Supabase success:** The Supabase backend creates a row in `auth.users`. A PostgreSQL trigger (`on_auth_user_created`) fires and inserts a corresponding row into `public.users` with all default settings (see section 4.1).
5. **Frontend redirect:** Display the message "Check your email to verify your account." and redirect to `/verify-email`.

#### Outputs

| Scenario | HTTP Status | Response / UI Behavior |
|----------|-------------|----------------------|
| Success | 201 | Supabase returns session object. Frontend displays verification message, redirects to `/verify-email`. |
| Duplicate email (production) | 200 | Generic message: "If this email is not already registered, you will receive a verification email." No indication of whether the account exists. |
| Duplicate email (development) | 422 | "An account with this email already exists. Try logging in or resetting your password." |
| Rate limited | 429 | "Too many attempts. Please try again in 60 seconds." |
| Network error | N/A (client) | "Unable to connect. Please check your connection and try again." |

#### Business Rules

- BR-001: In production, the system MUST NOT reveal whether an email is already registered. The generic message is used for both existing and new emails.
- BR-002: All new users are created with `subscription_tier = 'free'`, `role = 'user'`, `paper_trading_mode = true`, and `onboarding_completed = false`.
- BR-003: The database trigger that creates the `public.users` row runs as `SECURITY DEFINER` to ensure it can insert into the `public.users` table regardless of the calling context.
- BR-004: Registration rate limit is 5 requests per IP per hour.

#### Error Handling

| Error Condition | User-Facing Message | System Action |
|----------------|---------------------|---------------|
| Empty email field | "Please enter a valid email address." | Client-side inline validation; form not submitted |
| Invalid email format | "Please enter a valid email address." | Client-side inline validation; form not submitted |
| Password too short (<8 chars) | "Password must be at least 8 characters with 1 uppercase, 1 lowercase, 1 number, and 1 special character." | Client-side inline validation; form not submitted |
| Password missing uppercase | Same as above | Client-side; register button disabled |
| Password missing lowercase | Same as above | Client-side; register button disabled |
| Password missing digit | Same as above | Client-side; register button disabled |
| Password missing special char | Same as above | Client-side; register button disabled |
| Passwords do not match | "Passwords do not match." | Client-side inline validation below confirm field |
| Supabase 429 (rate limit) | "Too many attempts. Please try again in 60 seconds." | Log rate limit event, display countdown timer |
| Supabase 500 (server error) | "Something went wrong. Please try again later." | Log error with full Supabase response (excluding credentials) |
| Network timeout (>10s) | "Unable to connect. Please check your connection and try again." | Client-side timeout detection |
| Database trigger failure | User sees success (Supabase auth row created), but `public.users` row missing | Backend health check detects orphaned auth users and retries trigger logic within 5 minutes |

#### Edge Cases

- **SQL injection in email:** The Supabase SDK parameterizes all inputs. Raw SQL characters in the email field are treated as literal text and will fail RFC 5322 validation.
- **XSS in any field:** React JSX escaping prevents script execution. Server-side `bleach` sanitization strips HTML tags on any stored text.
- **Simultaneous registration with same email:** Supabase enforces unique email constraint at the database level. The second request receives the duplicate email response.
- **Browser back button after registration:** The `/verify-email` page is idempotent. Revisiting it shows the same "Check your email" message.
- **Registration with OAuth-linked email:** If the email is already associated with a Google/GitHub OAuth account, Supabase links the password credential to the existing account (Phase 2 behavior). In Phase 1, OAuth is not available, so this case does not arise.

---

### 3.2 FR-002: Magic Link (Passwordless) Authentication

**Source:** PRD AU-FR-002 | **Phase:** 2 | **Priority:** P0

#### Description

The system supports passwordless login via one-time magic links sent to the user's email address. Magic links are single-use and expire after 1 hour.

#### Inputs

| Field | Type | Validation | Required |
|-------|------|-----------|----------|
| email | string | RFC 5322 format | Yes |

#### Processing Logic

1. User navigates to `/login` and clicks "Sign in with magic link."
2. A single email input field is displayed.
3. User enters their email and clicks "Send magic link."
4. Frontend calls `supabase.auth.signInWithOtp({ email })`.
5. Regardless of whether the email exists, display: "Check your email for a login link. The link expires in 1 hour."
6. Supabase sends an email containing a link to `/auth/callback?token=<otp_token>&type=magiclink`.
7. User clicks the link. The `/auth/callback` page extracts the token and calls `supabase.auth.verifyOtp({ token_hash, type: 'magiclink' })`.
8. On success, the user is redirected to `/dashboard`.

#### Outputs

| Scenario | Response / UI Behavior |
|----------|----------------------|
| Success (email exists) | Email sent with magic link. User clicks link, session created, redirect to `/dashboard`. |
| Email does not exist | Same "Check your email" message displayed (no information leakage). No email sent. |
| Expired link (>1 hour) | "This link has expired. Request a new one." with a "Send new link" button. |
| Already-used link | "This link has already been used. Request a new one." with a "Send new link" button. |
| Invalid/malformed token | "Invalid login link. Please request a new one." |
| Rate limited | "Too many attempts. Please try again in 15 minutes." |

#### Business Rules

- BR-005: Magic links are single-use. After one successful verification, the token is invalidated.
- BR-006: Rate limit: maximum 3 magic link requests per email per 15-minute window.
- BR-007: Magic links expire after 1 hour (configured in Supabase dashboard).

#### Error Handling

| Error Condition | User-Facing Message | System Action |
|----------------|---------------------|---------------|
| Empty email | "Please enter your email address." | Client-side validation |
| Invalid email format | "Please enter a valid email address." | Client-side validation |
| 3+ requests in 15 min for same email | "Too many attempts. Please try again in 15 minutes." | Redis counter tracks per-email requests |
| Supabase unavailable | "Something went wrong. Please try again later." | Log error, suggest email/password login as fallback |

#### Edge Cases

- **User clicks magic link in a different browser:** The link works in any browser. A new session is created in the browser where the link is opened.
- **User requests multiple magic links:** Only the most recent link is valid. Previous links are invalidated by Supabase.
- **Email delivered after expiry window:** The link shows the expiration message with an option to request a new one.

---

### 3.3 FR-003: OAuth Provider Authentication (Google)

**Source:** PRD AU-FR-003 | **Phase:** 2 | **Priority:** P0

#### Description

The system supports Google OAuth login. New users are automatically registered; existing users with the same email have the OAuth identity linked to their account.

#### Inputs

None (user-initiated via button click).

#### Processing Logic

1. User clicks "Continue with Google" on the `/login` or `/register` page.
2. Frontend calls `supabase.auth.signInWithOAuth({ provider: 'google', options: { redirectTo: 'https://app.trendedge.io/auth/callback' } })`.
3. User is redirected to Google's consent screen.
4. On consent, Google redirects to `/auth/callback` with authorization code.
5. Supabase exchanges the code for tokens and creates or links the user account.
6. **New user:** The `on_auth_user_created` database trigger fires, creating the `public.users` row with defaults.
7. **Existing user (same email):** Supabase links the Google OAuth identity to the existing account. No duplicate user row is created.
8. Frontend receives the session and redirects:
   - Existing user: `/dashboard`
   - New user (Phase 3): `/onboarding`
   - New user (Phase 1-2): `/dashboard`

#### Outputs

| Scenario | Response / UI Behavior |
|----------|----------------------|
| Success (new user) | Account created, session established, redirect to dashboard (or onboarding in Phase 3). |
| Success (existing user) | OAuth identity linked, session established, redirect to dashboard. |
| User denies consent | Redirect to `/login` with message: "Google sign-in was cancelled." |
| OAuth state mismatch (CSRF) | "Authentication failed. Please try again." |
| Google returns error | "Google sign-in failed. Please try again or use another login method." |

#### Business Rules

- BR-008: Google OAuth requires `GOOGLE_OAUTH_CLIENT_ID` and `GOOGLE_OAUTH_CLIENT_SECRET` environment variables.
- BR-009: The OAuth redirect URL must be registered in the Google Cloud Console: `https://[SUPABASE_URL]/auth/v1/callback`.
- BR-010: Requested Google scopes: `openid`, `email`, `profile`.

#### Edge Cases

- **User's Google email matches an existing password-only account:** Supabase links the identities. The user can now log in with either method.
- **User revokes Google access after linking:** The user can still log in with email/password or magic link. The Google login option will require re-consent.
- **Google account has no public email:** Sign-in fails. Display: "Could not retrieve your email from Google. Please ensure your Google account has a verified email."

---

### 3.4 FR-004: OAuth Provider Authentication (GitHub)

**Source:** PRD AU-FR-004 | **Phase:** 2 | **Priority:** P1

#### Description

The system supports GitHub OAuth login. The flow is identical to FR-003 (Google OAuth) but uses `provider: 'github'`. GitHub is relevant for the developer persona.

#### Processing Logic

Same as FR-003 with the following substitutions:
- Provider: `'github'` instead of `'google'`
- Button text: "Continue with GitHub"
- Consent screen: GitHub's authorization page
- Scopes: `user:email`
- Environment variables: `GITHUB_OAUTH_CLIENT_ID`, `GITHUB_OAUTH_CLIENT_SECRET`

#### Error Messages

- User denies consent: "GitHub sign-in was cancelled."
- OAuth error: "GitHub sign-in failed. Please try again or use another login method."

---

### 3.5 FR-005: Email Verification Flow

**Source:** PRD AU-FR-005 | **Phase:** 2 | **Priority:** P0

#### Description

The system requires email verification before granting full account access. Unverified users can access the dashboard in read-only mode but cannot connect brokers, execute trades, or create API keys.

#### Inputs

None (triggered automatically on registration). Resend requires no new input.

#### Processing Logic

1. On registration (FR-001), Supabase automatically sends a verification email containing a link to `/auth/callback?token=<token>&type=signup`.
2. The dashboard displays a persistent verification banner at the top of the page for unverified users.
3. Banner text: "Please verify your email to unlock all features. Didn't receive the email? [Resend]"
4. Clicking "Resend" calls `supabase.auth.resend({ type: 'signup', email: currentUser.email })`.
5. Verification link expires after 24 hours.
6. On successful verification via the link, the frontend listens to `supabase.onAuthStateChange()` and:
   - Removes the verification banner immediately (no page reload required).
   - Unlocks all restricted features.
   - Displays a toast notification: "Email verified successfully!"

#### Feature Restrictions for Unverified Users

| Feature | Unverified Access |
|---------|------------------|
| View dashboard | Yes (read-only) |
| View profile settings | Yes |
| Edit profile settings | Yes |
| Connect brokers | **No** -- "Please verify your email first." |
| Execute trades (live or paper) | **No** -- "Please verify your email first." |
| Create API keys | **No** -- "Please verify your email first." |
| View existing data | Yes |

#### Business Rules

- BR-011: Rate limit for resend: maximum 3 resend requests per hour.
- BR-012: Verification link expires after 24 hours.
- BR-013: OAuth-registered users (Google, GitHub) are automatically verified because the OAuth provider has already verified their email.

#### Error Handling

| Error Condition | User-Facing Message |
|----------------|---------------------|
| Expired verification link | "This verification link has expired." with "Send new verification email" button |
| Already verified user clicks link | Redirect to `/dashboard` with toast: "Your email is already verified." |
| Resend rate limit exceeded | "You've requested too many verification emails. Please try again in 1 hour." |

---

### 3.6 FR-006: Password Reset Flow

**Source:** PRD AU-FR-006 | **Phase:** 2 | **Priority:** P0

#### Description

The system provides a secure password reset mechanism. The flow never reveals whether an email address is registered.

#### Inputs

**Request phase:**

| Field | Type | Validation | Required |
|-------|------|-----------|----------|
| email | string | RFC 5322 format | Yes |

**Reset phase:**

| Field | Type | Validation | Required |
|-------|------|-----------|----------|
| new_password | string | Same rules as registration (8+ chars, uppercase, lowercase, digit, special char) | Yes |
| confirm_password | string | Must match new_password | Yes |

#### Processing Logic

1. User clicks "Forgot password?" on the `/login` page.
2. System displays an email input form at `/forgot-password`.
3. On submit, system calls `supabase.auth.resetPasswordForEmail(email, { redirectTo: 'https://app.trendedge.io/auth/reset-password' })`.
4. **Always display** (regardless of whether the email exists): "If an account exists with that email, you will receive a password reset link."
5. If the email is registered, Supabase sends a reset email with a link to `/auth/reset-password?token=<token>`.
6. Reset link expires after 1 hour.
7. The reset password page (`/auth/reset-password`) renders two fields: new password and confirm password, with a real-time strength indicator.
8. Strength indicator levels: "Weak" (red), "Fair" (orange), "Strong" (green), "Very Strong" (green, bold).
9. On submit, the frontend calls `supabase.auth.updateUser({ password: newPassword })`.
10. On success: Display "Password updated successfully." and redirect to `/login`.
11. All existing sessions for this user are invalidated upon password reset.

#### Business Rules

- BR-014: The response message MUST be identical whether the email exists or not (prevents email enumeration).
- BR-015: Reset link expires after 1 hour.
- BR-016: Reset links are single-use. Using a link invalidates it.
- BR-017: Rate limit: maximum 3 reset requests per email per hour.
- BR-018: New password must be different from the current password.
- BR-019: On successful password reset, ALL existing sessions for the user are invalidated. The user must log in again with the new password.

#### Error Handling

| Error Condition | User-Facing Message |
|----------------|---------------------|
| Expired reset token | "This reset link has expired. Request a new one." with "Request new link" button |
| Already-used reset token | "This reset link has already been used." |
| New password matches old | "New password must be different from your current password." |
| New password fails validation | Same validation messages as registration (FR-001) |
| Passwords do not match | "Passwords do not match." |
| Rate limit (3+ requests/hour) | "Too many reset requests. Please try again later." |

#### Edge Cases

- **User requests multiple resets:** Only the most recent reset link is valid. Previous links are invalidated.
- **User is already logged in and navigates to forgot password:** Redirect to `/settings/account` with option to change password directly (requires current password).
- **User's account is soft-deleted:** The generic message is still shown (no information leakage). No email is sent.

---

### 3.7 FR-010: JWT Token Handling

**Source:** PRD AU-FR-010 | **Phase:** 1 | **Priority:** P0

#### Description

The system uses Supabase-issued JWTs for all authenticated API requests. Access tokens are short-lived (15 minutes) and stored in memory. Refresh tokens are long-lived (7 days) and stored in HTTP-only cookies.

#### Processing Logic

1. On successful authentication (any method), Supabase issues:
   - **Access token:** JWT, 15-minute lifetime, stored in JavaScript memory (never `localStorage` or `sessionStorage`).
   - **Refresh token:** Opaque token, 7-day lifetime, stored in an HTTP-only, Secure, SameSite=Lax cookie.
2. Every API request to the FastAPI backend includes the access token: `Authorization: Bearer <access_token>`.
3. The FastAPI backend validates the JWT on every request by:
   - Verifying the signature against `SUPABASE_JWT_SECRET`.
   - Checking the `exp` claim (reject if expired with HTTP 401).
   - Checking the `aud` claim matches the expected audience value.
   - Extracting the `sub` claim (user UUID).
4. After validation, the backend sets the PostgreSQL session variable for RLS enforcement: `SET request.jwt.claim.sub = '<user_id>'`.
5. All subsequent database queries in that request automatically apply RLS policies filtering by `auth.uid()`.

#### Business Rules

- BR-020: Access tokens are NEVER stored in `localStorage`, `sessionStorage`, cookies, or any persistent client-side storage. Memory-only.
- BR-021: Refresh tokens are stored exclusively in HTTP-only, Secure, SameSite=Lax cookies.
- BR-022: JWT validation is stateless (no database call required for valid tokens), achieving <50ms p95 latency.
- BR-023: Roles are verified from the database, NEVER from JWT claims alone (prevents privilege escalation via JWT manipulation).

#### Error Handling

| Error Condition | HTTP Status | Response Body |
|----------------|-------------|--------------|
| Missing Authorization header | 401 | `{"error": "authentication_required", "message": "Authentication required."}` |
| Malformed token | 401 | `{"error": "invalid_token", "message": "Invalid authentication token."}` |
| Expired access token | 401 | `{"error": "token_expired", "message": "Token has expired. Please refresh."}` |
| Invalid signature (tampered) | 401 | `{"error": "invalid_token", "message": "Invalid authentication token."}` |
| Audience mismatch | 401 | `{"error": "invalid_token", "message": "Invalid authentication token."}` |

---

### 3.8 FR-011: Refresh Token Rotation

**Source:** PRD AU-FR-011 | **Phase:** 1 | **Priority:** P0

#### Description

The system implements refresh token rotation. On each token refresh, the old refresh token is invalidated and a new one is issued. Reuse of an invalidated refresh token triggers automatic revocation of all sessions for that user.

#### Processing Logic

1. Access tokens expire after 15 minutes (900 seconds).
2. Refresh tokens expire after 7 days (604,800 seconds).
3. The Supabase client SDK automatically refreshes the access token when it is within 60 seconds of expiry.
4. On each refresh, the old refresh token is invalidated and a new refresh token + access token pair is issued.
5. **Theft detection:** If a previously-invalidated refresh token is used (indicating the token was copied before rotation), ALL sessions for that user are revoked immediately.
6. The user receives an email notification: "We detected suspicious activity on your account. All sessions have been signed out for your protection."
7. **Cross-tab coordination:** The Supabase client SDK uses `BroadcastChannel` API to coordinate refresh across browser tabs. Only one tab performs the refresh; other tabs receive the new token via the channel.

#### Business Rules

- BR-024: On stolen token detection, ALL sessions (every device, every browser) are revoked.
- BR-025: The security notification email is sent regardless of the user's notification preferences.
- BR-026: After forced sign-out due to theft detection, the user must re-authenticate with a primary method (password, OAuth, or magic link).

#### Edge Cases

- **Browser does not support BroadcastChannel:** Each tab refreshes independently. This may cause one tab's refresh token to be invalidated by another tab's refresh. The Supabase SDK handles this gracefully by retrying the refresh with the newly issued token.
- **User is offline when token expires:** On reconnection, the refresh token is used. If the refresh token has also expired (>7 days offline), the user is redirected to `/login` with message: "Your session has expired. Please sign in again."

---

### 3.9 FR-012: Session Expiry and Inactivity Timeout

**Source:** PRD AU-FR-012 | **Phase:** 1 (basic) / 2 (full) | **Priority:** P0

#### Configuration

| Parameter | Default Value | Configurable By |
|-----------|--------------|----------------|
| Access token lifetime | 900 seconds (15 min) | Environment variable |
| Refresh token lifetime | 604,800 seconds (7 days) | Environment variable |
| Inactivity timeout | 30 minutes | User setting (Phase 2) |
| Maximum session age | 30 days | Environment variable |

#### Processing Logic -- Inactivity Timeout

1. The frontend tracks user interaction events: click, keypress, scroll, mouse movement.
2. An inactivity timer starts from the last interaction event.
3. After 25 minutes of inactivity, display a modal overlay:
   - Title: "Session Timeout Warning"
   - Body: "Your session will expire in 5 minutes due to inactivity."
   - Buttons: [Stay signed in]
   - A visible countdown timer from 5:00 to 0:00.
4. Clicking "Stay signed in" resets the inactivity timer to 30 minutes and triggers a token refresh.
5. If no action is taken after 30 minutes total, the frontend:
   - Calls `supabase.auth.signOut()`.
   - Preserves any unsaved form data in `sessionStorage` (keyed by route path).
   - Redirects to `/login` with message: "You were signed out due to inactivity."
6. On re-login, if `sessionStorage` contains preserved form data for the current route, restore it and show a toast: "Your unsaved changes have been restored."

#### Edge Cases

- **Multiple tabs open:** The inactivity timer tracks globally. Activity in any tab resets the timer for all tabs (via `BroadcastChannel` or `localStorage` event).
- **User is watching a long video or reading without interaction:** The modal appears at 25 minutes. This is by design for security. Users who want longer sessions can click "Stay signed in."

---

### 3.10 FR-013: Multi-Device Session Management

**Source:** PRD AU-FR-013 | **Phase:** 2 | **Priority:** P1

#### Description

Users can view and manage active sessions across devices from the security settings page.

#### Processing Logic

1. User navigates to `/settings/security/sessions`.
2. The page displays a list of active sessions with the following metadata per session:
   - **Device type:** Desktop, Mobile, or Tablet (parsed from User-Agent string).
   - **Browser:** Name and major version (e.g., "Chrome 120", "Safari 17").
   - **IP address:** Partially masked for privacy (e.g., `192.168.xxx.xxx` -- last two octets hidden).
   - **Location:** City and country derived from IP geolocation.
   - **Last active:** Relative timestamp ("Active now", "2 hours ago", "3 days ago").
   - **Current session indicator:** The session matching the current device/browser is labeled "(this device)".
3. Each session except the current one has a "Revoke" button.
4. Clicking "Revoke" opens a confirmation modal: "Are you sure you want to revoke this session? The device will need to log in again. [Cancel] [Revoke]"
5. On confirmation, the backend calls `supabase.auth.admin.deleteSession(sessionId)` via a server-side proxy endpoint.
6. A "Revoke all other sessions" button at the top revokes every session except the current one.
7. After revocation, the revoked device's next API request returns HTTP 401, forcing re-authentication.

#### Business Rules

- BR-027: Users cannot revoke their own current session from this page. They must use the "Sign out" action in the navigation menu.
- BR-028: Session revocation is logged in the audit log with: `user_id`, `session_id`, `revoked_by: 'self'`, timestamp.
- BR-029: The session list refreshes automatically every 60 seconds while the page is active.

---

## 4. Data Specifications

### 4.1 Users Table (Auth-Relevant Columns)

**Table:** `public.users`

The full users table is defined across FSD-008a through FSD-008d. The columns relevant to authentication are:

| Column | Type | Constraints | Default | Description |
|--------|------|------------|---------|-------------|
| id | UUID | PK, FK -> auth.users(id) ON DELETE CASCADE | N/A | Matches Supabase auth user ID |
| email | TEXT | NOT NULL | from auth | User's email address |
| role | TEXT | NOT NULL, CHECK IN ('user','admin') | 'user' | Platform role (verified from DB, not JWT) |
| subscription_tier | TEXT | NOT NULL, CHECK IN ('free','trader','pro','team') | 'free' | Current subscription tier |
| onboarding_completed | BOOLEAN | NOT NULL | false | Whether wizard is complete |
| onboarding_step | INTEGER | NOT NULL | 0 | Last completed wizard step |
| created_at | TIMESTAMPTZ | NOT NULL | NOW() | Account creation timestamp |
| updated_at | TIMESTAMPTZ | NOT NULL | NOW() | Last profile update |
| last_login_at | TIMESTAMPTZ | nullable | null | Most recent login |
| deleted_at | TIMESTAMPTZ | nullable | null | Soft delete timestamp |

For full table definition including profile, settings, and team columns, see **FSD-008b** (profile columns) and **FSD-008d** (team/authorization columns).

### 4.2 Database Trigger: New User Setup

```sql
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.users (id, email, subscription_tier, settings, role, created_at, updated_at)
  VALUES (
    NEW.id,
    NEW.email,
    'free',
    '{
      "trading_preferences": {
        "default_instruments": [],
        "default_timeframe": "4H",
        "risk_per_trade_percent": 1.0,
        "max_daily_loss": 500.00,
        "max_concurrent_positions": 3,
        "paper_trading_mode": true
      },
      "notification_preferences": {
        "telegram_enabled": false,
        "email_digest": "daily",
        "alert_on_fill": true,
        "alert_on_trendline": true,
        "alert_on_risk_breach": true
      },
      "display_preferences": {
        "theme": "system",
        "currency_display": "USD",
        "date_format": "MM/DD/YYYY",
        "compact_mode": false
      }
    }'::jsonb,
    'user',
    NOW(),
    NOW()
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
```

### 4.3 Audit Logs Table (Auth Events)

**Table:** `public.audit_logs`

| Column | Type | Constraints | Default | Description |
|--------|------|------------|---------|-------------|
| id | UUID | PK | gen_random_uuid() | Log entry identifier |
| user_id | UUID | FK -> users(id) ON DELETE SET NULL, INDEX | null | Acting user (null for system events) |
| event_type | TEXT | NOT NULL, INDEX | N/A | Event type identifier |
| event_data | JSONB | NOT NULL | '{}' | Event-specific data |
| ip_address | INET | nullable | null | Source IP address |
| user_agent | TEXT | nullable | null | Browser/client user agent |
| created_at | TIMESTAMPTZ | NOT NULL, INDEX | NOW() | Event timestamp |

**Auth-specific audit event types:**

| Event Type | Data Captured |
|-----------|-------------|
| `user_registered` | user_id, email (hashed), IP, user_agent, timestamp |
| `login_success` | user_id, method (password/magic-link/oauth), IP, user_agent, timestamp |
| `login_failure` | email (hashed), method, IP, user_agent, failure_reason, timestamp |
| `password_reset_requested` | email (hashed), IP, timestamp |
| `password_changed` | user_id, IP, timestamp |
| `email_changed` | user_id, old_email (hashed), new_email (hashed), timestamp |
| `session_revoked` | user_id, session_id, revoked_by (self or admin), timestamp |
| `rate_limit_triggered` | IP, endpoint, count, timestamp |

**Retention:** 2 years. Logs older than 2 years are archived to cold storage before deletion.

**RLS:** Users can read only their own audit entries. Admins can read all entries. See FSD-008d for full RLS specification.

### 4.4 Auth-Related Indexes

```sql
CREATE INDEX idx_audit_logs_user_id ON public.audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON public.audit_logs(event_type);
CREATE INDEX idx_audit_logs_created_at ON public.audit_logs(created_at);
CREATE INDEX idx_users_deleted_at ON public.users(deleted_at);
```

---

## 5. API Specifications

### 5.1 Authentication Endpoints (Public)

#### POST /auth/register

**Phase:** 1 | **Auth:** None | **Rate Limit:** 5/IP/hour

**Request:**
```json
{
  "email": "user@example.com",
  "password": "SecureP@ss1"
}
```

**Response 201 (Success):**
```json
{
  "user": {
    "id": "uuid",
    "email": "user@example.com",
    "email_verified": false
  },
  "session": {
    "access_token": "jwt...",
    "refresh_token": "opaque...",
    "expires_in": 900,
    "token_type": "bearer"
  },
  "message": "Check your email to verify your account."
}
```

**Response 200 (Production -- email exists or not):**
```json
{
  "message": "If this email is not already registered, you will receive a verification email."
}
```

**Response 422 (Validation Error):**
```json
{
  "error": "validation_error",
  "details": [
    {"field": "password", "message": "Password must be at least 8 characters with 1 uppercase, 1 lowercase, 1 number, and 1 special character."}
  ]
}
```

**Response 429 (Rate Limited):**
```json
{
  "error": "rate_limit_exceeded",
  "retry_after": 3600,
  "message": "Too many attempts. Please try again in 60 minutes."
}
```

---

#### POST /auth/login

**Phase:** 1 | **Auth:** None | **Rate Limit:** 10/IP/min, 10/email/15min

**Request:**
```json
{
  "email": "user@example.com",
  "password": "SecureP@ss1"
}
```

**Response 200 (Success):**
```json
{
  "user": {
    "id": "uuid",
    "email": "user@example.com",
    "email_verified": true,
    "role": "user",
    "subscription_tier": "free"
  },
  "session": {
    "access_token": "jwt...",
    "refresh_token": "opaque...",
    "expires_in": 900,
    "token_type": "bearer"
  }
}
```

**Response 401 (Invalid credentials):**
```json
{
  "error": "invalid_credentials",
  "message": "Invalid email or password."
}
```

**Response 423 (Account locked):**
```json
{
  "error": "account_locked",
  "message": "Account temporarily locked. Try again in 15 minutes or use a magic link.",
  "retry_after": 900
}
```

---

#### POST /auth/magic-link

**Phase:** 2 | **Auth:** None | **Rate Limit:** 3/email/15min

**Request:**
```json
{
  "email": "user@example.com"
}
```

**Response 200 (Always, regardless of email existence):**
```json
{
  "message": "Check your email for a login link. The link expires in 1 hour."
}
```

---

#### GET /auth/callback

**Phase:** 2 | **Auth:** None

Handles OAuth and magic link callbacks. Query parameters vary by flow. Frontend-rendered page that exchanges tokens and redirects.

---

#### POST /auth/reset-password

**Phase:** 2 | **Auth:** None | **Rate Limit:** 3/email/hour

**Request:**
```json
{
  "email": "user@example.com"
}
```

**Response 200 (Always):**
```json
{
  "message": "If an account exists with that email, you will receive a password reset link."
}
```

---

#### POST /auth/update-password

**Phase:** 2 | **Auth:** Authenticated (via reset token)

**Request:**
```json
{
  "password": "NewSecureP@ss2"
}
```

**Response 200:**
```json
{
  "message": "Password updated successfully."
}
```

**Response 422:**
```json
{
  "error": "validation_error",
  "message": "New password must be different from your current password."
}
```

---

#### POST /auth/logout

**Phase:** 1 | **Auth:** Authenticated

**Response 200:**
```json
{
  "message": "Signed out successfully."
}
```

---

### 5.2 Session Endpoints (Authenticated)

#### GET /api/sessions

**Phase:** 2 | **Auth:** Bearer JWT

**Response 200:**
```json
{
  "sessions": [
    {
      "id": "session-uuid",
      "device_type": "Desktop",
      "browser": "Chrome 120",
      "ip_address": "192.168.xxx.xxx",
      "location": "New York, US",
      "last_active": "2026-02-11T12:00:00Z",
      "is_current": true
    },
    {
      "id": "session-uuid-2",
      "device_type": "Mobile",
      "browser": "Safari 17",
      "ip_address": "10.0.xxx.xxx",
      "location": "Chicago, US",
      "last_active": "2026-02-10T08:30:00Z",
      "is_current": false
    }
  ]
}
```

---

#### DELETE /api/sessions/:id

**Phase:** 2 | **Auth:** Bearer JWT

**Response 200:** `{"message": "Session revoked successfully."}`
**Response 403:** `{"error": "forbidden", "message": "Cannot revoke your current session from here. Use sign out instead."}`
**Response 404:** `{"error": "not_found", "message": "Session not found."}`

---

#### DELETE /api/sessions

**Phase:** 2 | **Auth:** Bearer JWT

Revokes all sessions except the current one.

**Response 200:** `{"message": "All other sessions have been revoked.", "revoked_count": 3}`

---

### 5.3 Common Response Headers (All Auth Endpoints)

Every API response includes:
```
X-RateLimit-Limit: <max requests>
X-RateLimit-Remaining: <remaining requests>
X-RateLimit-Reset: <unix timestamp>
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
Content-Security-Policy: <see section 7.5>
X-Content-Type-Options: nosniff
X-Frame-Options: DENY
Referrer-Policy: strict-origin-when-cross-origin
Permissions-Policy: camera=(), microphone=(), geolocation=()
Cache-Control: no-store
```

---

## 6. UI/UX Specifications

### 6.1 Registration Page (`/register`)

**Layout:** Centered card on a minimal background. TrendEdge logo at top.

**Form fields:**
1. Email input -- placeholder: "Enter your email address"
2. Password input -- placeholder: "Create a password", with show/hide toggle icon
3. Confirm password input -- placeholder: "Confirm your password", with show/hide toggle icon
4. Password strength indicator -- colored bar below password field (red/orange/green)
5. "Create Account" button -- full width, disabled until all validations pass
6. Divider: "or"
7. "Continue with Google" button (Phase 2) -- Google branded
8. "Continue with GitHub" button (Phase 2) -- GitHub branded
9. Footer link: "Already have an account? [Log in]"

**Validation display:** Inline error messages appear below each field in red text, with a 300ms debounce on input validation.

### 6.2 Login Page (`/login`)

**Layout:** Same centered card as registration.

**Form fields:**
1. Email input
2. Password input with show/hide toggle
3. "Log in" button -- full width
4. "Forgot password?" link -- right-aligned below password field
5. "Sign in with magic link" link -- below login button
6. Divider: "or"
7. "Continue with Google" button (Phase 2)
8. "Continue with GitHub" button (Phase 2)
9. Footer link: "Don't have an account? [Register]"

### 6.3 Forgot Password Page (`/forgot-password`)

**Layout:** Same centered card.

**Form fields:**
1. Email input -- placeholder: "Enter your email address"
2. "Send reset link" button
3. Back link: "Back to login"

**After submit:** Show green success message (same regardless of email existence).

### 6.4 Reset Password Page (`/auth/reset-password`)

**Layout:** Same centered card. Only accessible via valid reset link.

**Form fields:**
1. New password input with strength indicator
2. Confirm password input
3. "Update password" button

### 6.5 Email Verification Banner

**Location:** Top of dashboard, below main navigation bar. Full width.
**Color:** Blue background, white text.
**Content:** "Please verify your email to unlock all features. Didn't receive the email? [Resend]"
**Behavior:** Disappears immediately when `onAuthStateChange` reports verified status. No page reload.

### 6.6 Session Timeout Warning Modal

**Trigger:** 25 minutes of inactivity.
**Type:** Modal overlay with dimmed background. Cannot be dismissed by clicking outside.
**Content:**
- Title: "Session Timeout Warning"
- Body: "Your session will expire in 5:00 due to inactivity."
- Countdown timer that updates every second.
- Button: [Stay signed in] -- full width, primary color.

---

## 7. Security Specifications

### 7.1 Rate Limiting

All authentication endpoints are protected by rate limits using Redis sliding window counters.

| Endpoint | Rate Limit | Window | Lockout Action |
|----------|-----------|--------|----------------|
| POST /auth/register | 5 requests | per IP per hour | 1-hour IP block |
| POST /auth/login | 10 requests | per IP per minute | 15-minute IP block |
| POST /auth/login (per account) | 10 requests | per email per 15 min | 15-minute account lock; 1-hour lock after 50 attempts |
| POST /auth/magic-link | 3 requests | per email per 15 min | 15-minute block |
| POST /auth/reset-password | 3 requests | per email per hour | 1-hour block |
| POST /auth/verify-email/resend | 3 requests | per email per hour | 1-hour block |

**Response on rate limit exceeded:**
- HTTP 429 with body: `{"error": "rate_limit_exceeded", "retry_after": <seconds>}`
- Headers: `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset` on every response.

**Redis key patterns:**

| Pattern | Key Format | TTL | Purpose |
|---------|-----------|-----|---------|
| Rate limit (IP) | `ratelimit:ip:{ip}:{endpoint}` | Varies by endpoint | Sliding window counter |
| Rate limit (email) | `ratelimit:email:{email_hash}:{endpoint}` | Varies by endpoint | Per-account rate limiting |
| Failed login counter | `failed_login:{email_hash}` | 1 hour | Brute force protection |
| Failed login counter (IP) | `failed_login_ip:{ip}` | 1 hour | IP-based protection |
| Token blacklist | `blacklist:{token_jti}` | Until original token expiry | Revoked token tracking |

**Fallback:** If Redis is unavailable, rate limiting degrades to in-memory counters (per-process, not distributed). A warning is logged every 60 seconds until Redis connectivity is restored.

### 7.2 Brute Force Protection

**Account lockout policy:**

| Failed Attempts | Action |
|----------------|--------|
| 5 consecutive | Display hCaptcha challenge on next attempt |
| 10 consecutive | Lock account for 15 minutes. Message: "Account temporarily locked. Try again in 15 minutes or use a magic link." |
| 50 consecutive (across lockout periods) | Lock account for 1 hour. Send email: "Multiple failed login attempts detected on your TrendEdge account. If this wasn't you, reset your password immediately." |
| Successful login | Reset failed attempt counter to 0 |

**IP-based protection:**

| Failed Attempts (any email) | Action |
|----------------------------|--------|
| 20 from single IP | Temporary IP block for 15 minutes |
| 100 from single IP per hour | IP block for 1 hour |

Lockout is per-email (not per-IP) for account lockout, preventing attackers from using different IPs to brute-force a single account. IP blocks are a separate, additional layer.

### 7.3 hCaptcha Integration (Phase 2)

**Provider:** hCaptcha
**Purpose:** Bot protection on login after 5 failed attempts
**Environment:** `HCAPTCHA_SITE_KEY`, `HCAPTCHA_SECRET_KEY`
**Trigger:** After 5 consecutive failed login attempts for a given email
**Verification:** Backend verifies the hCaptcha response token via `POST https://hcaptcha.com/siteverify`
**Fallback:** If hCaptcha service is unavailable, proceed without CAPTCHA but maintain rate limits

### 7.4 CSRF Protection

1. **SameSite cookies:** All auth cookies set with `SameSite=Lax`, preventing CSRF on cross-origin POST requests.
2. **CSRF tokens:** For server-rendered forms (if any), a CSRF token is included in a hidden field and validated server-side.
3. **Origin validation:** FastAPI backend validates the `Origin` header on all state-changing requests. Accepted origins: `https://app.trendedge.io`, `https://trendedge.io`.
4. **JWT Bearer tokens:** Provide implicit CSRF protection because they are not automatically sent by browsers in cross-origin requests (unlike cookies).

### 7.5 XSS Prevention

1. **Content Security Policy (CSP):**
   ```
   Content-Security-Policy: default-src 'self'; script-src 'self' 'nonce-{random}'; style-src 'self' 'unsafe-inline'; img-src 'self' https://r2.trendedge.io; connect-src 'self' https://api.trendedge.io wss://api.trendedge.io; frame-ancestors 'none';
   ```
2. **Input sanitization:** All user text is sanitized server-side using `bleach` before storage. Auth-related fields (email, password) are parameterized by the Supabase SDK.
3. **Output encoding:** React's JSX escaping is used for all user content. `dangerouslySetInnerHTML` is NEVER used with user-provided content.
4. **Additional headers:**
   - `X-Content-Type-Options: nosniff`
   - `X-Frame-Options: DENY`
   - `X-XSS-Protection: 0` (deprecated; CSP preferred)
   - `Referrer-Policy: strict-origin-when-cross-origin`

### 7.6 Session Fixation Prevention

1. On every successful authentication, a new session token is generated. Any pre-existing session token is invalidated.
2. Session tokens are NEVER accepted from URL parameters or form fields -- only from HTTP-only cookies or Authorization headers.
3. Session tokens are bound to the user agent string. If the user agent changes, the session is invalidated.
4. Session tokens are regenerated after any privilege change (email verification, role change).

### 7.7 Security Headers

All responses include:

| Header | Value | Purpose |
|--------|-------|---------|
| Strict-Transport-Security | `max-age=31536000; includeSubDomains; preload` | Force HTTPS for 1 year |
| Content-Security-Policy | See section 7.5 | Prevent XSS |
| X-Content-Type-Options | `nosniff` | Prevent MIME type sniffing |
| X-Frame-Options | `DENY` | Prevent clickjacking |
| Referrer-Policy | `strict-origin-when-cross-origin` | Limit referrer information leakage |
| Permissions-Policy | `camera=(), microphone=(), geolocation=()` | Disable unused browser APIs |
| Cache-Control | `no-store` | Prevent caching of auth responses |

### 7.8 Audit Logging (Auth Events)

All security-relevant authentication events are logged in the append-only `audit_logs` table. The table has NO UPDATE or DELETE policies (insert-only via service role). See section 4.3 for schema and event types.

---

## 8. Integration Specifications

### 8.1 Supabase Auth Integration

**Provider:** Supabase
**Purpose:** Authentication, JWT issuance, email verification, password reset, OAuth flows
**Environment:**
- `SUPABASE_URL` -- Supabase project URL
- `SUPABASE_ANON_KEY` -- Public key for client-side operations
- `SUPABASE_SERVICE_ROLE_KEY` -- Service role key for backend operations (bypasses RLS)
- `SUPABASE_JWT_SECRET` -- JWT secret for signature verification

**SDK Usage:**
- Frontend: `@supabase/supabase-js` (JavaScript SDK)
- Backend: `supabase-py` (Python SDK) for admin operations; direct JWT verification for request validation

**Error Handling:**

| Supabase Error | Our Response |
|---------------|-------------|
| 401 Invalid credentials | "Invalid email or password." |
| 422 User already registered | Generic message (production) |
| 429 Rate limited | "Too many attempts. Please try again in [X] seconds." |
| 500 Server error | "Something went wrong. Please try again later." Log full error. |
| Network timeout | "Unable to connect. Please check your connection and try again." |

### 8.2 Redis (Upstash) Integration

**Provider:** Upstash Redis
**Purpose:** Rate limiting, failed login counters, token blacklist
**Environment:** `REDIS_URL`

See section 7.1 for complete Redis key patterns and TTLs.

### 8.3 Email Service Integration (SendGrid/Resend)

**Provider:** SendGrid or Resend
**Purpose:** Transactional email delivery for auth flows
**Environment:** `SENDGRID_API_KEY`

**Auth-related email types:**

| Email | Trigger | Template |
|-------|---------|----------|
| Verification email | Registration (FR-001) | Handled by Supabase |
| Password reset | Reset request (FR-006) | Handled by Supabase |
| Magic link | Magic link request (FR-002) | Handled by Supabase |
| Security notification (stolen token) | Refresh token reuse (FR-011) | Custom template |
| Brute force alert | 50+ failed logins | Custom template |

**Error Handling:**

| Error | Our Response |
|-------|-------------|
| 401 Bad API key | Log CRITICAL, alert ops. Email queued for retry. |
| 429 Rate limited | Exponential backoff: 1s, 2s, 4s. Max 3 retries. |
| 500 Provider outage | Queue locally. Retry every 5 minutes. Alert after 3 failures. |
| Timeout (>10s) | Retry once, then queue for background processing. |

---

## 9. Performance Specifications

### 9.1 Authentication Latency

| Operation | Target (p95) | Measurement Point |
|-----------|-------------|-------------------|
| Email/password login | < 200ms | From request receipt to JWT issuance |
| Magic link generation | < 200ms | From request receipt to email queued |
| OAuth callback processing | < 200ms | From callback receipt to session created (excludes provider redirect time) |
| Token refresh | < 100ms | From refresh request to new token issued |
| JWT validation (per request) | < 50ms | From middleware entry to RLS context set |

### 9.2 Session Validation

JWT validation achieves < 50ms p95 through:
1. **Local signature verification:** No database call for valid tokens. The JWT secret is loaded in memory at application startup.
2. **Redis permission cache:** User role and permissions are cached in Redis with a 5-minute TTL. Cache hit rate target: > 95%.
3. **Connection pool reuse:** PostgreSQL connection pool (`asyncpg`) reuses connections for RLS context setting.

### 9.3 Concurrent Session Support

| Metric | Target |
|--------|--------|
| Concurrent authenticated sessions | 5,000+ |
| Authentication requests per second | 100+ |
| Token refresh requests per second | 500+ |
| Session store memory (Redis) | < 500MB at 5,000 sessions |

### 9.4 Availability

**Target:** 99.9% availability (< 8.76 hours downtime per year).

**Resilience design:**
1. Supabase Auth provides built-in redundancy.
2. JWT validation is stateless -- works even if Supabase is temporarily unreachable, as long as tokens are not expired.
3. Refresh token rotation degrades gracefully: if Supabase is down, existing valid access tokens continue to work until expiry (15 minutes).
4. Redis unavailability degrades to in-memory rate limiting (less accurate but functional).

---

## 10. Testing Specifications

### 10.1 Registration Tests

| Test ID | Test Case | Input | Expected Outcome | Type |
|---------|-----------|-------|-----------------|------|
| T-001 | Valid registration | `email: "test@example.com"`, `password: "SecureP@ss1"` | 201, user created in auth.users and public.users, verification email queued | Automated |
| T-002 | Duplicate email (production) | Existing email | 200, generic message, no duplicate created | Automated |
| T-003 | Weak password -- too short | `password: "Ab1!"` (4 chars) | 422, password validation error | Automated |
| T-004 | Weak password -- no uppercase | `password: "securep@ss1"` | 422, password validation error | Automated |
| T-005 | Weak password -- no lowercase | `password: "SECUREP@SS1"` | 422, password validation error | Automated |
| T-006 | Weak password -- no digit | `password: "SecureP@ss"` | 422, password validation error | Automated |
| T-007 | Weak password -- no special char | `password: "SecurePass1"` | 422, password validation error | Automated |
| T-008 | Invalid email format | `email: "not-an-email"` | 422, "Please enter a valid email address" | Automated |
| T-009 | Empty fields | `email: ""`, `password: ""` | 422, field-level validation errors | Automated |
| T-010 | SQL injection in email | `email: "'; DROP TABLE users;--"` | Input rejected, no SQL execution | Automated |
| T-011 | XSS in display name (post-reg) | `display_name: "<script>alert('xss')</script>"` | Input sanitized, script not stored/executed | Automated |
| T-012 | Default user settings | New registration | User row has all defaults: free tier, user role, paper_trading_mode=true, all default JSONB settings | Automated |
| T-013 | Registration rate limit | 6 requests from same IP in 1 hour | 6th request returns 429 | Automated |

### 10.2 Login Tests

| Test ID | Test Case | Input | Expected Outcome | Type |
|---------|-----------|-------|-----------------|------|
| T-020 | Valid login | Correct email + password | 200, JWT issued, session created, redirect to dashboard | Automated |
| T-021 | Invalid password | Correct email, wrong password | 401, "Invalid email or password" | Automated |
| T-022 | Non-existent email | Unregistered email | 401, "Invalid email or password" (same message) | Automated |
| T-023 | Unverified email login | Correct credentials, unverified account | 200, login succeeds, verification banner shown, features restricted | Automated |
| T-024 | Magic link login | Valid email | 200, "Check your email" message, email sent | Automated |
| T-025 | Expired magic link | Link older than 1 hour | "This link has expired" with resend option | Automated |
| T-026 | Used magic link | Click same link twice | Second click: "This link has already been used" | Automated |
| T-027 | Google OAuth login | Valid Google account | Session created, redirect to dashboard | E2E |
| T-028 | GitHub OAuth login | Valid GitHub account | Session created, redirect to dashboard | E2E |
| T-029 | OAuth consent denied | User cancels on provider | Redirect to login with cancellation message | E2E |
| T-030 | Account locked (10 failures) | 10 wrong passwords then correct | 11th attempt returns 423 locked message | Automated |
| T-031 | hCaptcha after 5 failures | 5 wrong passwords | 6th attempt requires hCaptcha | Automated |

### 10.3 Password Reset Tests

| Test ID | Test Case | Input | Expected Outcome | Type |
|---------|-----------|-------|-----------------|------|
| T-040 | Valid reset request | Registered email | 200, generic message, reset email sent | Automated |
| T-041 | Non-existent email reset | Unregistered email | 200, same generic message (no info leak) | Automated |
| T-042 | Valid reset token + strong password | Valid token, new password meeting requirements | Password updated, all sessions invalidated | Automated |
| T-043 | Expired reset token | Token older than 1 hour | "This link has expired" with request new link option | Automated |
| T-044 | Reused reset token | Already-used token | "This link has already been used" | Automated |
| T-045 | Same password as current | Current password as new password | "New password must be different from your current password" | Automated |
| T-046 | Session invalidation on reset | Reset password, then use old token | Old token returns 401 | Automated |
| T-047 | Reset rate limit | 4 requests in 1 hour | 4th returns 429 | Automated |

### 10.4 Session Management Tests

| Test ID | Test Case | Setup | Expected Outcome | Type |
|---------|-----------|-------|-----------------|------|
| T-080 | Token expiry and auto-refresh | Wait 15+ min without manual refresh | Client auto-refreshes, new token works | Automated |
| T-081 | Refresh token rotation | Use refresh token | Old refresh token invalidated, new pair issued | Automated |
| T-082 | Stolen refresh token detection | Use previously-invalidated refresh token | ALL sessions revoked, security email sent | Automated |
| T-083 | Inactivity timeout | No interaction for 30 min | User signed out, redirect to login with inactivity message | E2E |
| T-084 | Multi-device login | Login from two browsers | Both sessions active simultaneously | Automated |
| T-085 | Session revocation | Revoke session from device A | Device A's next request returns 401 | Automated |
| T-086 | Password change invalidation | Change password | All OTHER sessions invalidated | Automated |
| T-087 | Inactivity warning modal | No interaction for 25 min | Warning modal appears with 5-min countdown | E2E |

### 10.5 Security / Penetration Tests

| Test ID | Category | Test | Pass Criteria | Type |
|---------|----------|------|--------------|------|
| T-120 | Auth Bypass | API access without token | HTTP 401 on all protected endpoints | Automated |
| T-121 | Token Manipulation | Modify JWT payload (change user_id) | Signature verification fails, HTTP 401 | Automated |
| T-122 | Privilege Escalation | Change role claim in JWT | Signature fails; role always verified from DB | Automated |
| T-123 | SQL Injection | SQL in all auth input fields | No SQL execution; parameterized queries only | Automated |
| T-124 | XSS | Scripts in auth fields | Input sanitized; CSP blocks execution | Automated |
| T-125 | CSRF | Cross-origin POST to auth endpoints | CSRF protection blocks; SameSite cookies prevent | Automated |
| T-126 | Session Fixation | Set session token before auth | Token regenerated on login; old token invalid | Automated |
| T-127 | Brute Force | >10 login attempts in 1 minute | Account locked, 429 response | Automated |
| T-128 | Credential Exposure | Search logs, errors, API responses | No credentials, tokens, or secrets in any output | Automated |

### 10.6 OWASP Authentication Compliance

| OWASP Test ID | Test Name | Verification | Pass Criteria |
|--------------|-----------|-------------|--------------|
| OTG-AUTHN-001 | Encrypted channel | Check all auth endpoints | All require HTTPS; HSTS header present |
| OTG-AUTHN-002 | Default credentials | Check for default accounts | No default accounts; admin bootstrap is manual DB insert |
| OTG-AUTHN-003 | Account lockout | Trigger lockout | 10 failures -> 15-min lock; 50 -> 1-hour lock |
| OTG-AUTHN-004 | Auth bypass | Test every API route | Auth middleware on all protected routes |
| OTG-AUTHN-005 | Session timeout | Check token lifetimes | Refresh: 7 days; inactivity: 30 min; max age: 30 days |
| OTG-AUTHN-006 | Browser cache | Check cache headers | `Cache-Control: no-store` on all auth responses |
| OTG-AUTHN-007 | Password policy | Test weak passwords | 8+ chars, uppercase, lowercase, digit, special char |
| OTG-AUTHN-008 | Security questions | Verify not used | Not implemented; magic link provides passwordless recovery |
| OTG-AUTHN-009 | Password change | Test flow | Requires current password; all sessions invalidated |
| OTG-AUTHN-010 | HTTP Authentication | Verify method | JWT Bearer tokens only; no HTTP Basic/Digest |

### 10.7 Load Testing

| Test | Configuration | Pass Criteria |
|------|--------------|--------------|
| Login throughput | 100 concurrent login requests over 60 seconds | p95 latency < 200ms; 0 errors |
| Session validation throughput | 1,000 concurrent authenticated requests | p95 validation < 50ms |
| Token refresh under load | 500 concurrent refresh requests | p95 < 100ms; no token conflicts |
| Concurrent sessions | Simulate 5,000 active sessions | Response times within SLA; Redis < 500MB |

---

## 11. Deployment

### 11.1 Phase 1 Deployment (Auth Scope)

1. **Supabase project setup:**
   - Create Supabase project with PostgreSQL 16.
   - Configure auth settings: email/password enabled, confirm email enabled.
   - Set JWT expiry to 900 seconds, refresh token expiry to 604800 seconds.

2. **Database migrations (run in order):**
   - Create `public.users` table.
   - Create `public.audit_logs` table.
   - Create `handle_new_user()` trigger function.
   - Create `on_auth_user_created` trigger.
   - Enable and force RLS on users and audit_logs tables. (Full RLS spec in FSD-008d.)
   - Create indexes.

3. **Required environment variables:**
   - `SUPABASE_URL`
   - `SUPABASE_ANON_KEY`
   - `SUPABASE_SERVICE_ROLE_KEY`
   - `SUPABASE_JWT_SECRET`
   - `REDIS_URL`

4. **Verification:**
   - Register a test user -> verify `public.users` row created with defaults.
   - Login -> verify JWT issued and API requests work.
   - Verify JWT validation rejects expired/tampered tokens.

### 11.2 Phase 2 Deployment (Auth Scope)

1. **Additional environment variables:**
   - `GOOGLE_OAUTH_CLIENT_ID`, `GOOGLE_OAUTH_CLIENT_SECRET`
   - `GITHUB_OAUTH_CLIENT_ID`, `GITHUB_OAUTH_CLIENT_SECRET`
   - `HCAPTCHA_SITE_KEY`, `HCAPTCHA_SECRET_KEY`
   - `SENDGRID_API_KEY`
   - `APP_DOMAIN`

2. **Supabase configuration:**
   - Enable Google OAuth provider with client ID/secret.
   - Enable GitHub OAuth provider with client ID/secret.
   - Configure redirect URLs: `https://app.trendedge.io/auth/callback`
   - Configure email templates for verification, reset, magic link.

3. **Redis setup:**
   - Verify sliding window rate limiting is operational.
   - Configure key TTLs per rate limit specification.

4. **Verification:**
   - All Phase 1 tests still pass.
   - Magic link flow works end-to-end.
   - Google OAuth flow works.
   - GitHub OAuth flow works.
   - Password reset flow works.
   - Email verification enforces feature restrictions.
   - Rate limiting blocks excessive requests.
   - All security headers present on responses.
   - Penetration test checklist passes.

---

## 12. User Account State Diagram

```
                    +--------------+
                    |  Registered  |
                    |  (Unverified)|
                    +------+-------+
                           |
                    Email verified
                           |
                    +------v-------+
              +---->|    Active     |<----+
              |     +------+-------+     |
              |            |             |
         Unlocked    Account locked   Restored
              |     (brute force)    (within 30d)
              |            |             |
              |     +------v-------+     |
              |     |    Locked     |     |
              |     +------+-------+     |
              |            |             |
              +--  Lockout expires       |
                                         |
                    +------+-------+     |
                    |   Deleted     +-----+
                    | (Soft, 30d)  |
                    +------+-------+
                           |
                    30 days elapsed
                           |
                    +------v-------+
                    | Hard Deleted  |
                    | (Irreversible)|
                    +--------------+
```

Note: Account deletion and restoration flows are specified in **FSD-008d**.

---

## 13. Open Questions & Assumptions

### 13.1 Assumptions

| ID | Assumption | Impact if Wrong |
|----|-----------|----------------|
| A-001 | Supabase Auth is reliable at 99.9%+ availability | Need fallback auth provider or local JWT issuance |
| A-002 | Redis (Upstash) is available for rate limiting | Degrade to in-memory counters; rate limiting less accurate in multi-instance deployments |
| A-007 | Email delivery via SendGrid/Resend is reliable within 30 seconds | Need monitoring and fallback provider |

### 13.2 Open Questions

| ID | Question | Impact | Decision Needed By |
|----|---------|--------|-------------------|
| Q-001 | Should we support 2FA/MFA (TOTP, SMS, or hardware keys)? | High security improvement, but adds complexity. Not in current PRD. | Phase 2 planning |
| Q-007 | What email service (SendGrid vs. Resend) will be used in production? | Affects API integration code and templates. | Before Phase 2 development |
| Q-008 | Should admin actions require 2FA in addition to re-authentication? | Higher security for admin operations. | Phase 2 planning |

---

## 14. Cross-Reference Index

| FSD-008a Section | Parent FSD Section | PRD Requirement | Phase |
|-----------------|-------------------|----------------|-------|
| FR-001 (Registration) | 3.1 | AU-FR-001 | 1 |
| FR-002 (Magic Link) | 3.2 | AU-FR-002 | 2 |
| FR-003 (Google OAuth) | 3.3 | AU-FR-003 | 2 |
| FR-004 (GitHub OAuth) | 3.4 | AU-FR-004 | 2 |
| FR-005 (Email Verification) | 3.5 | AU-FR-005 | 2 |
| FR-006 (Password Reset) | 3.6 | AU-FR-006 | 2 |
| FR-010 (JWT Handling) | 3.7 | AU-FR-010 | 1 |
| FR-011 (Refresh Token Rotation) | 3.8 | AU-FR-011 | 1 |
| FR-012 (Session Expiry) | 3.9 | AU-FR-012 | 1/2 |
| FR-013 (Multi-Device Sessions) | 3.10 | AU-FR-013 | 2 |

---

*This document is FSD-008a, a sub-specification of FSD-008 (Authentication & User Management). It covers the complete authentication layer for TrendEdge. For related specifications, see FSD-008b (User Profiles & Settings), FSD-008c (Broker Connection Management), and FSD-008d (Authorization & Multi-Tenancy).*
