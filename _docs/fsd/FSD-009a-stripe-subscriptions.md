# FSD-009a: Stripe Integration & Subscription Lifecycle

**TrendEdge -- AI-Powered Futures Trading Platform**

| Field | Value |
|---|---|
| FSD ID | FSD-009a |
| Source | FSD-009 (Billing & Subscriptions) |
| Title | Stripe Integration & Subscription Lifecycle |
| Version | 1.0 |
| Status | Draft |
| Author | Generated by Claude |
| Created | 2026-02-11 |

---

## 1. Introduction

### 1.1 Purpose

This sub-FSD specifies the Stripe payment integration and complete subscription lifecycle management for TrendEdge. It covers everything from Stripe product/price configuration to checkout, plan changes, cancellation with retention offers, pause/resume, reactivation, webhook processing, dunning management, and the subscription state machine.

This is the payment backbone of the billing system. It interacts with:

- **FSD-009b (Feature Gating & Usage Tracking)**: Consumes tier data produced by this subsystem's webhook handlers to enforce feature access and track usage limits.
- **FSD-009c (Billing Admin & Revenue)**: Provides subscription and payment data for the admin revenue dashboard, refund processing, and promotion code management.

### 1.2 Scope

This document covers:

- **Stripe Configuration**: Product/price setup, environment variables, Customer Portal configuration.
- **Checkout Flow**: Session creation, trial eligibility, redirect handling.
- **Subscription Lifecycle**: Upgrade (with proration), downgrade (with grace period), billing interval changes.
- **Cancellation**: Multi-step flow with retention offers, cancellation reason tracking, metrics.
- **Pause/Resume**: Subscription pausing with Free tier fallback and automatic resume.
- **Reactivation**: Re-subscribing after cancellation with data preservation awareness.
- **Webhook Processing**: Receiver endpoint, signature verification, idempotent event processing, event routing.
- **Dunning Management**: 6-step failed payment recovery sequence with progressive access restriction.
- **14-Day Pro Trial**: Trial eligibility, lifecycle, notification schedule, auto-conversion.
- **Subscription State Machine**: All valid states, transitions, and enforcement rules.
- **Data Models**: `subscriptions`, `stripe_events`, `cancellation_events` tables.
- **Security**: PCI SAQ-A compliance, webhook signature verification, API key management.

### 1.3 Out of Scope

- Feature gating middleware and tier checking engine [see FSD-009b]
- Feature flag registry and usage tracking [see FSD-009b]
- Graceful degradation on limit exceeded [see FSD-009b]
- Invoice access and billing history [see FSD-009c]
- Revenue analytics dashboard [see FSD-009c]
- Refund processing [see FSD-009c]
- Coupon/promotion code administration [see FSD-009c]
- AI cost tracking and usage metering [see FSD-009b]
- User authentication and session management [see FSD-008]

### 1.4 Dependencies

| Dependency | Reference | What This Sub-FSD Needs |
|---|---|---|
| Infrastructure | FSD-001 | PostgreSQL database, Redis cache, Celery task queue, environment variable management, monitoring (Sentry, Axiom) |
| Auth & User Management | FSD-008 | Authenticated user sessions, user ID for subscription records, admin role check, user registration event to trigger Free tier provisioning |
| Feature Gating | FSD-009b | Redis tier cache invalidation interface; `user:{user_id}:tier_features` cache key contract |
| Notification Service | FSD-010 | Email delivery (SendGrid) for dunning emails, trial notifications, receipts; Telegram delivery for payment confirmations |

### 1.5 Tier Structure Reference

| Capability | Free | Trader ($49/mo) | Pro ($99/mo) | Team ($199/mo) |
|---|---|---|---|---|
| Monthly Price | $0 | $49 | $99 | $199 |
| Annual Price | -- | $399/yr (32% off) | $799/yr (33% off) | $1,899/yr (21% off) |
| Tier Level (for comparison) | 0 | 1 | 2 | 3 |

Tier hierarchy for programmatic comparison:

```
free (0) < trader (1) < pro (2) < team (3)
```

---

## 2. System Context

### 2.1 Architecture Overview

The Stripe integration operates as a service layer within the TrendEdge FastAPI backend. Stripe is the sole payment processor. TrendEdge servers never receive, process, or store raw card information. All payment card data flows exclusively through Stripe-hosted pages.

**Component interactions:**

```
User Browser
  |
  |-- POST /api/billing/checkout --> FastAPI Backend --> Stripe API (create Checkout Session)
  |-- POST /api/billing/portal   --> FastAPI Backend --> Stripe API (create Portal Session)
  |-- (redirect to Stripe Checkout / Portal hosted pages)
  |
Stripe Servers
  |-- POST /api/webhooks/stripe --> FastAPI Backend --> Celery Worker (async processing)
  |                                                       |
  |                                                       |--> PostgreSQL (subscription, stripe_events tables)
  |                                                       |--> Redis (invalidate tier cache)
  |                                                       |--> SendGrid (dunning/notification emails)
```

### 2.2 External Service Dependencies

| Service | Purpose | Failure Impact | Fallback |
|---|---|---|---|
| Stripe API | Payment processing, subscription management | Cannot create new subscriptions or process payments | Show "Payment processing is temporarily unavailable. Please try again in a few minutes." Feature gating continues from cached data. |
| Stripe Webhooks | Event-driven subscription lifecycle updates | Local state may become stale | Daily reconciliation job corrects discrepancies. Feature gating continues from last known good state. |
| Redis | Tier data caching (owned by FSD-009b, invalidated by this subsystem) | Feature gate latency increases | Direct PostgreSQL lookup (~100ms vs ~5ms). System continues functioning. |
| SendGrid | Transactional email for dunning, trial, receipts | Emails delayed | Queue emails locally, process when service recovers. No impact on subscription state or feature access. |

---

## 3. Functional Specifications

### 3.1 BL-FR-001: Stripe Product and Price Configuration

**Source:** PRD-009 Section 3.1, BL-FR-001

**Description:** The system configures Stripe products and prices for all four subscription tiers across both billing intervals (monthly and annual). Products and prices are provisioned via a seed script or Stripe Dashboard, not dynamically at runtime.

**Inputs:** None at runtime. Configuration is static.

**Processing Logic:**

1. Four Stripe products are created, one per tier:
   - `prod_trendedge_free` -- Free tier (no associated price; exists for metadata consistency)
   - `prod_trendedge_trader` -- Trader tier subscription
   - `prod_trendedge_pro` -- Pro tier subscription
   - `prod_trendedge_team` -- Team tier subscription

2. Each product includes metadata key `tier_level` with integer value for programmatic comparison:
   - Free: `tier_level = 0`
   - Trader: `tier_level = 1`
   - Pro: `tier_level = 2`
   - Team: `tier_level = 3`

3. Six recurring prices are created:

   | Price | Amount (cents) | Interval | Stripe Price ID Pattern |
   |---|---|---|---|
   | Trader Monthly | 4900 | month | `price_trader_monthly` |
   | Trader Annual | 39900 | year | `price_trader_annual` |
   | Pro Monthly | 9900 | month | `price_pro_monthly` |
   | Pro Annual | 79900 | year | `price_pro_annual` |
   | Team Monthly | 19900 | month | `price_team_monthly` |
   | Team Annual | 189900 | year | `price_team_annual` |

4. All prices use `currency: "usd"` and `recurring` mode.

**Outputs:** Stripe product and price objects. Price IDs stored in environment variables.

**Business Rules:**
- Price IDs MUST be stored in environment configuration variables (see Section 7), never hardcoded in source code.
- Products and prices MUST NOT be created dynamically at runtime. Any change requires a deployment or manual Stripe Dashboard update.
- The `tier_level` metadata on each product enables programmatic tier comparison without hardcoded tier-name-to-level mappings.

**Error Handling:**
- If the seed script detects that products/prices already exist in Stripe (matching by ID pattern), it skips creation and logs: `"Stripe product {product_id} already exists. Skipping creation."`
- If the seed script fails to create a product or price, it aborts with a CRITICAL log: `"Failed to create Stripe product/price: {error}. Billing system cannot start without valid Stripe configuration."`

**Edge Cases:**
- Running the seed script twice must be idempotent -- no duplicate products or prices created.
- If a price amount needs to change (e.g., price increase), a new price must be created in Stripe. The old price is archived. The environment variable is updated to point to the new price ID. Existing subscribers remain on their current price until their next renewal or plan change.

---

### 3.2 BL-FR-002: Checkout Session Creation

**Source:** PRD-009 Section 3.1, BL-FR-002

**Description:** The system creates Stripe Checkout Sessions to process new subscription purchases. The frontend redirects the user to Stripe-hosted checkout pages; on completion, Stripe redirects back and a webhook confirms subscription creation.

**API Endpoint:** `POST /api/billing/checkout`

**Authentication:** Required. User must be authenticated. [See FSD-008]

**Request Body:**

| Field | Type | Required | Validation |
|---|---|---|---|
| `price_id` | string | Yes | Must match one of the six configured Stripe price IDs from environment variables |
| `billing_interval` | string | Yes | Must be `"monthly"` or `"annual"` |

```json
{
  "price_id": "price_pro_monthly",
  "billing_interval": "monthly"
}
```

**Processing Logic:**

1. Validate that the authenticated user does NOT already have an active paid subscription (status `active`, `trialing`, or `past_due` with a non-free tier). If they do, return 409.
2. Validate that the `price_id` matches one of the six configured Stripe price IDs. If not, return 400.
3. Validate that the `billing_interval` is `"monthly"` or `"annual"`. If not, return 400.
4. Validate that the `price_id` and `billing_interval` are consistent (e.g., `price_trader_monthly` with `"monthly"`). If not, return 400.
5. Determine whether the user already has a Stripe customer ID (`stripe_customer_id` on the subscriptions table):
   - If yes: use the existing customer ID in the Checkout Session.
   - If no: pass the user's email as `customer_email` so Stripe creates a new customer.
6. Determine trial eligibility: if the user's `has_used_trial` is `false` AND the selected tier is Pro, set `subscription_data.trial_period_days` to the value of the `BILLING_TRIAL_DAYS` environment variable (default: 14).
7. Create a Stripe Checkout Session with these parameters:
   - `mode`: `"subscription"`
   - `customer`: existing Stripe customer ID (if available)
   - `customer_email`: user's email (if no existing Stripe customer)
   - `line_items`: `[{ price: price_id, quantity: 1 }]`
   - `success_url`: `"{BASE_URL}/billing/success?session_id={CHECKOUT_SESSION_ID}"`
   - `cancel_url`: `"{BASE_URL}/pricing"`
   - `allow_promotion_codes`: `true`
   - `subscription_data.trial_period_days`: 14 (if eligible, as determined in step 6)
   - `subscription_data.metadata`: `{ "user_id": "{user_id}", "tier": "{tier_name}", "source": "checkout" }`
   - `tax_id_collection.enabled`: `true`
   - `billing_address_collection`: `"auto"`
8. Return the Checkout Session URL to the frontend.

**Outputs:**

Success (200 OK):
```json
{
  "checkout_url": "https://checkout.stripe.com/c/pay/cs_xxx..."
}
```

**Error Handling:**

| Condition | HTTP Status | Response Body |
|---|---|---|
| User already has active paid subscription | 409 Conflict | `{ "error": "active_subscription_exists", "message": "You already have an active subscription. Use the billing portal to change plans." }` |
| Invalid `price_id` | 400 Bad Request | `{ "error": "invalid_price_id", "message": "The selected plan is not available. Please choose a valid plan." }` |
| Invalid `billing_interval` | 400 Bad Request | `{ "error": "invalid_billing_interval", "message": "Billing interval must be 'monthly' or 'annual'." }` |
| Mismatched `price_id` and `billing_interval` | 400 Bad Request | `{ "error": "price_interval_mismatch", "message": "The selected price does not match the specified billing interval." }` |
| Stripe API unavailable or error | 503 Service Unavailable | `{ "error": "payment_service_unavailable", "message": "Payment processing is temporarily unavailable. Please try again in a few minutes." }` |
| User not authenticated | 401 Unauthorized | `{ "error": "authentication_required", "message": "You must be logged in to subscribe." }` |

**Edge Cases:**
- If the user navigates away from Stripe Checkout without completing payment, no subscription is created. The user's tier remains unchanged. The abandoned Checkout Session expires after 24 hours automatically (Stripe default).
- If the user has a `cancelled` subscription status, they are treated as eligible for a new checkout (not blocked by the active-subscription check).
- If the user has a `paused` subscription, they should resume via the reactivation flow (BL-FR-010), not create a new checkout. The 409 check covers this since `paused` is an active subscription state.
- If the Stripe Checkout Session creation succeeds but the user never completes checkout, the webhook for `checkout.session.completed` never fires, and no local state changes occur.

---

### 3.3 BL-FR-003: Stripe Customer Portal

**Source:** PRD-009 Section 3.1, BL-FR-003

**Description:** The system integrates the Stripe Customer Portal for self-service billing management. Users can update payment methods, view invoices, change plans, switch billing intervals, cancel subscriptions, and update billing addresses.

**API Endpoint:** `POST /api/billing/portal`

**Authentication:** Required. User must be authenticated and have a `stripe_customer_id`.

**Inputs:** None (the authenticated user's Stripe customer ID is derived from session).

**Processing Logic:**

1. Retrieve the authenticated user's `stripe_customer_id` from the `subscriptions` table.
2. If `stripe_customer_id` is null (Free tier user who has never initiated billing), return 400.
3. Create a Stripe Billing Portal Session with:
   - `customer`: the user's `stripe_customer_id`
   - `return_url`: `"{BASE_URL}/settings/billing"`
   - `configuration`: `STRIPE_PORTAL_CONFIG_ID` environment variable
4. Return the portal session URL.

**Portal Configuration (via Stripe Dashboard):**
- `subscription_update`: enabled, proration behavior `create_prorations`
- `subscription_cancel`: enabled, mode `at_period_end`
- `payment_method_update`: enabled
- `invoice_history`: enabled

**Outputs:**

Success (200 OK):
```json
{
  "portal_url": "https://billing.stripe.com/p/session/xxx..."
}
```

**Error Handling:**

| Condition | HTTP Status | Response Body |
|---|---|---|
| User has no `stripe_customer_id` | 400 Bad Request | `{ "error": "no_billing_account", "message": "You don't have a billing account yet. Subscribe to a paid plan to access billing management." }` |
| Stripe API error | 503 Service Unavailable | `{ "error": "payment_service_unavailable", "message": "Billing portal is temporarily unavailable. Please try again in a few minutes." }` |
| User not authenticated | 401 Unauthorized | `{ "error": "authentication_required", "message": "You must be logged in to access billing." }` |

**Edge Cases:**
- Portal session URLs are single-use and expire after 24 hours.
- If the user performs actions in the portal (e.g., cancels subscription), those actions are communicated back to TrendEdge exclusively via Stripe webhooks. The portal return URL (`/settings/billing`) will show the updated state once the webhook is processed.
- A user cannot access another user's portal session because the session is scoped to their `stripe_customer_id`.

---

### 3.4 BL-FR-004: Payment Method Management

**Source:** PRD-009 Section 3.1, BL-FR-004

**Description:** Payment methods are managed entirely through the Stripe Customer Portal. TrendEdge stores only display-safe metadata (last 4 digits and card brand) for showing in the billing settings UI.

**Inputs:** No direct user input to TrendEdge for payment method operations. All card data flows through Stripe.

**Processing Logic:**

1. When the `payment_method.attached` webhook fires:
   - Extract the payment method's `card.last4` and `card.brand` from the webhook payload.
   - Look up the user by `stripe_customer_id` from the webhook's `customer` field.
   - Update the user record: `payment_method_last4 = last4`, `payment_method_brand = brand`.

2. When the `payment_method.detached` webhook fires:
   - Look up the user by `stripe_customer_id`.
   - If the detached payment method was the user's default (matching stored last4/brand), clear both fields to null.

**Stored Fields (on `subscriptions` table):**

| Field | Type | Description |
|---|---|---|
| `stripe_customer_id` | varchar(255), nullable, unique | Stripe customer identifier |
| `payment_method_last4` | varchar(4), nullable | Last 4 digits of default card |
| `payment_method_brand` | varchar(20), nullable | Card brand (visa, mastercard, amex, etc.) |

**Outputs:** Updated local cache of payment method display info.

**Business Rules:**
- No raw card data (full card number, CVV, full expiration) ever touches TrendEdge servers. This is a PCI compliance requirement.
- The billing settings page displays: card brand icon, last 4 digits, and a "Manage" button that redirects to the Stripe Customer Portal.

**Error Handling:**
- If the `payment_method.attached` webhook contains a `customer` that does not match any local user, log a WARNING: `"Received payment_method.attached for unknown customer {customer_id}. Skipping."` and return 200 OK.
- If the payment method type is not a card (e.g., bank account), log the event but do not update display fields (only card brand/last4 are supported for display).

**Edge Cases:**
- If a user has multiple payment methods, only the most recently attached one is stored for display. The Stripe Customer Portal handles selecting the default payment method.
- If a user removes their only payment method, `payment_method_last4` and `payment_method_brand` are set to null. The billing settings UI shows "No payment method on file. Add one to continue your subscription." with a link to the Customer Portal.

---

### 3.5 BL-FR-005: Free Tier Provisioning

**Source:** PRD-009 Section 3.2, BL-FR-005

**Description:** New users receive full Free tier access immediately upon registration without providing any payment information.

**Inputs:** User registration event. [See FSD-008 for user registration flow]

**Processing Logic:**

1. When a new user completes registration, the system creates a subscription record:
   - `user_id`: the new user's ID
   - `tier`: `"free"`
   - `status`: `"active"`
   - `billing_interval`: `"none"`
   - `stripe_subscription_id`: null
   - `stripe_customer_id`: null
   - `has_used_trial`: false
   - `payment_status`: `"current"`
   - `dunning_step`: 0

2. No Stripe customer object is created at this point. Stripe customer creation is deferred until the user initiates a paid action (checkout or trial).

**Outputs:** A subscription record with `tier: "free"` and `status: "active"`.

**Business Rules:**
- Free tier has no expiration. Users can remain on Free indefinitely.
- Free tier users see non-blocking upgrade prompts when they approach or hit tier limits [see FSD-009b for specific messages].
- Free tier users who hit limits are never blocked from accessing existing data -- only from creating new resources beyond limits.

**Error Handling:**
- If the subscription record creation fails during registration (database error), the user registration itself must be rolled back. A user must not exist without a corresponding subscription record. Log CRITICAL: `"Failed to create subscription record for user {user_id}. Registration rolled back."`

**Edge Cases:**
- If a previously paid user's subscription is cancelled and their data retention period passes, they become a Free tier user. This uses the existing subscription record (updated by webhook), not a new record creation.
- If a user registers with an email that previously had a Stripe customer object (e.g., from a deleted account), the system does not automatically link to the old Stripe customer. A new Stripe customer is created on their first paid action.

---

### 3.6 BL-FR-006: Upgrade Flow

**Source:** PRD-009 Section 3.2, BL-FR-006

**Description:** The system supports upgrades from any lower tier to any higher tier. Upgrades from Free to Paid go through Stripe Checkout. Upgrades from Paid to Higher Paid process via the Stripe API with immediate proration.

**Valid Upgrade Paths:**
- Free -> Trader, Free -> Pro, Free -> Team
- Trader -> Pro, Trader -> Team
- Pro -> Team

**Processing Logic:**

**Path A: Free to Paid**
1. User clicks "Upgrade" on the pricing page or from a feature gate prompt.
2. System redirects to Stripe Checkout (BL-FR-002).
3. On successful payment, the `checkout.session.completed` webhook fires.
4. Webhook handler updates the subscription record: tier, status, Stripe IDs.
5. Redis tier cache is invalidated immediately.
6. Welcome email sent.

**Path B: Paid to Higher Paid**
1. User clicks "Upgrade" -- system displays plan comparison showing current plan vs. target plan with highlighted new features.
2. System calls Stripe API to preview proration: `stripe.Invoice.upcoming()` with the new price.
3. System displays prorated cost to user: "You'll be charged ${prorated_amount} today for the remainder of this billing period."
4. User confirms upgrade.
5. System updates the Stripe subscription via `stripe.Subscription.modify()` with:
   - `items`: new price ID replacing the current price
   - `proration_behavior`: `"create_prorations"`
   - `payment_behavior`: `"pending_if_incomplete"`
6. Stripe charges the prorated amount immediately.
7. The `customer.subscription.updated` webhook fires with the new tier.
8. Webhook handler updates the local subscription record immediately.
9. Redis tier cache is invalidated.
10. User gains immediate access to new tier features.

**Billing interval preservation:** If a user is on Trader Monthly and upgrades to Pro, they remain on monthly billing unless they explicitly choose to switch. The upgrade only changes the tier, not the interval.

**Outputs:**

Proration preview (for Paid-to-Paid):
```json
{
  "current_plan": "Trader Monthly",
  "target_plan": "Pro Monthly",
  "prorated_charge": 2500,
  "prorated_charge_display": "$25.00",
  "explanation": "You'll be charged $25.00 today for the remainder of this billing period. Your next full charge of $99.00 will be on 2026-04-01.",
  "new_features": [
    "Unlimited instruments with real-time detection",
    "Up to 3 broker connections and 5 accounts",
    "AI-powered trade reviews",
    "Advanced analytics with Monte Carlo simulations",
    "Priority support (24h response)"
  ]
}
```

**Business Rules:**
- Upgrades are never deferred -- tier access is granted immediately upon successful payment.
- If the proration charge fails (e.g., card declined), the upgrade is NOT applied. The user remains on their current tier. The system displays: "Your upgrade could not be processed. Please update your payment method and try again."
- The upgrade confirmation UI shows a brief confetti animation (2 seconds) followed by: "Welcome to {tier_name}! You now have access to all {tier_name} features."

**Error Handling:**

| Condition | Response |
|---|---|
| Target tier is same or lower than current tier | `400 Bad Request`: `"You can only upgrade to a higher tier. To change to a lower plan, use the downgrade option."` |
| Proration charge fails (card declined) | `402 Payment Required`: `"Your upgrade could not be processed. Please update your payment method and try again."` |
| Stripe API error during subscription update | `503 Service Unavailable`: `"We couldn't process your upgrade right now. Please try again in a few minutes."` |

**Edge Cases:**
- If a user upgrades and then immediately upgrades again within the same billing period (e.g., Trader -> Pro -> Team), both prorations are calculated correctly by Stripe based on the remaining time and price difference at each transition.
- If a user has a pending downgrade and then upgrades instead, the pending downgrade is cancelled automatically by the Stripe subscription update.
- If a user upgrades during a trial, the trial ends immediately and they are charged the prorated amount for the new tier.

---

### 3.7 BL-FR-007: Downgrade Flow with Grace Period

**Source:** PRD-009 Section 3.2, BL-FR-007

**Description:** The system supports downgrades from any paid tier to any lower tier. Downgrades take effect at the end of the current billing period. Users retain full access until then.

**Inputs:**

| Field | Type | Required | Validation |
|---|---|---|---|
| `target_tier` | string | Yes | Must be a tier lower than the current tier |

**Valid Downgrade Paths:**
- Team -> Pro, Team -> Trader, Team -> Free
- Pro -> Trader, Pro -> Free
- Trader -> Free

**Processing Logic:**

1. User clicks "Change Plan" in billing settings.
2. System validates that the target tier is lower than the current tier (using `tier_level` comparison: team=3 > pro=2 > trader=1 > free=0).
3. System displays an impact analysis showing exactly what features and limits will change.
4. User confirms the downgrade.
5. For Paid-to-Lower-Paid downgrades:
   - System updates the Stripe subscription to schedule the plan change at period end via `stripe.Subscription.modify()` with `proration_behavior: "none"` and scheduling the price change for the next billing cycle.
6. For Paid-to-Free downgrades:
   - System sets `cancel_at_period_end: true` on the Stripe subscription (cancelling reverts to Free).
7. System updates the local subscription record:
   - `pending_downgrade_tier`: target tier name
   - The `tier` field does NOT change yet (user retains current tier access).
8. System displays banner: "Your plan will change to {target_tier} on {period_end_date}. You have full access until then."
9. At period end, the `customer.subscription.updated` or `customer.subscription.deleted` webhook fires, and the webhook handler updates the local tier.

**Impact Analysis Display:**

```json
{
  "current_tier": "Pro",
  "target_tier": "Trader",
  "effective_date": "2026-04-01",
  "features_losing": [
    "AI-powered trade reviews",
    "Advanced analytics and Monte Carlo simulations",
    "Priority support (24h -> 48h response)",
    "Broker connections reduced from 3 to 1",
    "Accounts reduced from 5 to 1"
  ],
  "features_keeping": [
    "Real-time trendline detection (10 instruments)",
    "Unlimited journal entries",
    "Up to 5 custom playbooks",
    "Full analytics dashboard",
    "Email and Telegram notifications"
  ],
  "data_impact": "Your historical data (trades, journal entries, analytics) will be preserved. Features exceeding the new tier limits will become read-only."
}
```

**Data Handling on Downgrade (at effective date):**

| Data Type | Behavior |
|---|---|
| Historical trade data | Never deleted. Fully accessible read-only. |
| Journal entries | Never deleted. Existing entries remain readable. New entries subject to new tier limits. |
| Analytics history | Never deleted. Historical analytics remain viewable. New analytics limited to new tier capabilities. |
| Excess playbooks (e.g., user has 8, new limit is 5) | All 8 remain visible and functional. User cannot create new playbooks until count is at or below 5. |
| Excess broker connections (e.g., user has 3, new limit is 1) | All 3 connections preserved. User cannot add new connections. Orders from connections beyond the limit are rejected with: "This broker connection exceeds your Trader plan limit. Upgrade to Pro to use additional broker connections." |
| Excess instruments (e.g., user has unlimited, new limit is 10) | The 10 most recently active instruments continue monitoring. All others are paused with: "Instrument monitoring paused -- you are at your plan limit of 10 instruments." |
| AI-generated trade reviews | Previously generated reviews remain accessible in the journal. New AI review requests are gated with: "AI Trade Review is available on Pro and above." |

**Business Rules:**
- No refund is issued for the remaining billing period on downgrade. The user has paid and retains access until the period ends.
- A pending downgrade can be cancelled at any time before the effective date. Cancelling a pending downgrade removes the `pending_downgrade_tier` value and the scheduled Stripe subscription change.
- If the user's billing period ends and they have a pending downgrade, the downgrade is applied automatically via webhook.

**Error Handling:**

| Condition | Response |
|---|---|
| Target tier is same or higher than current | `400 Bad Request`: `"You can only downgrade to a lower tier. To upgrade, use the upgrade option."` |
| User is already on Free tier | `400 Bad Request`: `"You are already on the Free plan."` |
| User already has a pending downgrade | `409 Conflict`: `"You already have a pending plan change to {pending_tier} on {date}. Cancel it first to choose a different plan."` |
| Stripe API error | `503 Service Unavailable`: `"We couldn't process your plan change right now. Please try again in a few minutes."` |

**Edge Cases:**
- If a user downgrades and then upgrades before the downgrade takes effect, the upgrade cancels the pending downgrade. The user is on the new (higher) tier immediately.
- If a user requests a downgrade on the last day of their billing period, the downgrade takes effect at the next renewal (which is imminent). The system processes this normally.
- Downgrade from Team to Free skips intermediate tiers -- the user goes directly to Free at period end, not through Pro or Trader.

---

### 3.8 BL-FR-008: Cancellation Flow with Retention Offers

**Source:** PRD-009 Section 3.2, BL-FR-008

**Description:** The system implements a multi-step cancellation flow designed to reduce churn through targeted retention offers while respecting the user's intent to cancel.

**Inputs:**

Step 1 -- Reason selection:

| Field | Type | Required | Valid Values |
|---|---|---|---|
| `cancellation_reason` | string | Yes | `"too_expensive"`, `"not_using"`, `"missing_features"`, `"competitor"`, `"technical_issues"`, `"temporary_pause"`, `"other"` |
| `cancellation_reason_text` | string | No (required if reason is `"other"`) | Free text, max 500 characters |

Step 3 -- Confirmation:

| Field | Type | Required |
|---|---|---|
| `confirm_cancellation` | boolean | Yes, must be `true` |

**Processing Logic:**

**Step 1 -- Reason Survey:**
1. User clicks "Cancel Subscription" in billing settings.
2. System displays a modal with the cancellation reason options (listed above).
3. User selects a reason. If "Other" is selected, a text input appears for details.
4. System records the reason and proceeds to Step 2.

**Step 2 -- Retention Offer (conditional on reason):**

| Reason | Retention Offer Displayed | Action if Accepted |
|---|---|---|
| `too_expensive` | "Would a 25% discount for 3 months help? That's {tier_name} for ${discounted_price}/mo." | Apply coupon `retention_25pct_3mo` via Stripe API. Cancel the cancellation flow. Display: "Great! Your discount has been applied. You'll pay ${discounted_price}/mo for the next 3 months." |
| `not_using` | "Would switching to a lower plan work better? [comparison table of lower tiers]" | Redirect to downgrade flow (BL-FR-007). Cancel the cancellation flow. |
| `missing_features` | "Tell us what you need -- we prioritize features based on user feedback." with a link to a feature request form. | Open feature request form in new tab. User can still proceed to cancel. |
| `competitor` | "We're sorry to see you go. Your data will be preserved for 90 days if you'd like to return." | No special action. Proceed to Step 3. |
| `technical_issues` | "We're sorry you've had issues. Would you like to speak with our support team before cancelling?" with a link to support. | Open support contact. User can still proceed to cancel. |
| `temporary_pause` | "Would you prefer to pause your subscription for up to 3 months instead? You can resume anytime." | Redirect to pause flow (BL-FR-009). Cancel the cancellation flow. |
| `other` | "We're sorry to see you go. Your data will be preserved for 90 days if you'd like to return." | No special action. Proceed to Step 3. |

Discounted price calculations for the `too_expensive` retention offer:
- Trader: $49 * 0.75 = $36.75/mo
- Pro: $99 * 0.75 = $74.25/mo
- Team: $199 * 0.75 = $149.25/mo

**Step 3 -- Confirmation (if user declines retention offer or clicks "Continue Cancellation"):**
1. System displays: "Are you sure you want to cancel? Your {tier_name} access will continue until {period_end_date}. After that, your account will revert to the Free plan. Your data will be preserved for 90 days."
2. User clicks "Cancel My Subscription" to confirm.
3. System sets `cancel_at_period_end: true` on the Stripe subscription.
4. System updates local subscription record:
   - `status`: `"cancelling"`
   - `cancel_at_period_end`: `true`
   - `cancelled_at`: current timestamp
   - `cancellation_reason`: selected reason
5. System sends cancellation confirmation email containing: cancellation effective date, data retention period (90 days), reactivation instructions.
6. System displays banner on dashboard: "Your {tier_name} plan will end on {date}. You have full access until then. Changed your mind? [Reactivate]"

**Post-Cancellation (at period end):**
1. Stripe fires `customer.subscription.deleted` webhook.
2. Webhook handler updates local subscription record:
   - `status`: `"cancelled"`
   - `tier`: `"free"`
   - `cancel_at_period_end`: `false`
   - `stripe_subscription_id`: retained for reference
3. User reverts to Free tier limits immediately.
4. Data retention countdown begins (90 days from cancellation effective date).
5. At 90 days post-cancellation: send "final reminder" email: "Your TrendEdge data will be permanently deleted in 30 days. Reactivate your subscription to keep your data."
6. At 120 days post-cancellation: permanent data deletion per privacy policy.

**Cancellation can be reversed at any time before the period ends** -- see BL-FR-010 Reactivation Flow.

**Outputs:**

Cancellation confirmation (200 OK):
```json
{
  "status": "cancelling",
  "effective_date": "2026-04-01T00:00:00Z",
  "message": "Your Pro plan will end on April 1, 2026. You have full access until then.",
  "data_retention_days": 90,
  "reactivation_available": true
}
```

**Cancellation Metrics Tracking:**

Log every cancellation attempt in the `cancellation_events` table (see Section 4.3):

| Column | Type |
|---|---|
| id | bigint |
| user_id | uuid |
| reason | varchar(50) |
| reason_text | text (nullable) |
| retention_offer_shown | boolean |
| retention_offer_type | varchar(50) (nullable) |
| retention_offer_accepted | boolean |
| cancellation_completed | boolean |
| created_at | timestamptz |

**Error Handling:**

| Condition | Response |
|---|---|
| User is on Free tier | `400 Bad Request`: `"You don't have an active paid subscription to cancel."` |
| User already has a pending cancellation | `409 Conflict`: `"Your subscription is already scheduled for cancellation on {date}."` |
| Stripe API error | `503 Service Unavailable`: `"We couldn't process your cancellation right now. Please try again in a few minutes."` |
| Retention coupon application fails | Log error, proceed with cancellation. Do not block cancellation due to coupon failure. Display: "We couldn't apply the discount, but you can contact support for assistance. Would you still like to cancel?" |

**Edge Cases:**
- If a user cancels during a trial period, the trial continues until the trial end date. No charge is made. After the trial end date, the user reverts to Free.
- If the retention coupon `retention_25pct_3mo` has already been used by this user (repeat cancellation attempt), the "too expensive" retention offer is still shown, but with a note: "This discount can only be applied once per account." The user can only proceed to cancel or choose a different option.
- If a user cancels with an annual subscription, they retain access for the remainder of the annual period (which could be months away).

---

### 3.9 BL-FR-009: Subscription Pause

**Source:** PRD-009 Section 3.2, BL-FR-009

**Description:** The system supports pausing subscriptions for up to 3 months (90 days). During the pause, no invoices are generated and the user reverts to Free tier limits.

**API Endpoint:** `POST /api/billing/pause`

**Inputs:**

| Field | Type | Required | Validation |
|---|---|---|---|
| `pause_duration_days` | integer | Yes | Minimum 1, maximum 90 |

**Processing Logic:**

1. Validate that the user has an active paid subscription (status `active`). If not, return 400.
2. Validate that `pause_duration_days` is between 1 and 90. If not, return 400.
3. Calculate `pause_resumes_at` = current timestamp + `pause_duration_days`.
4. Call Stripe API: `stripe.Subscription.modify()` with `pause_collection` set to `{ "behavior": "void" }` (no invoices generated during pause).
5. Update local subscription record:
   - `status`: `"paused"`
   - `pause_starts_at`: current timestamp
   - `pause_resumes_at`: calculated resume date
6. Invalidate Redis tier cache for this user.
7. User access immediately reverts to Free tier limits.
8. Send pause confirmation email: "Your {tier_name} subscription has been paused until {resume_date}. You'll have Free plan access during this time. You can resume anytime."

**Resume behavior:**
- User can resume at any time by calling `POST /api/billing/resume`.
- On resume: system calls `stripe.Subscription.modify()` to remove `pause_collection`, updates `status` to `"active"`, restores tier, invalidates Redis cache.
- The billing cycle restarts from the resume date (the user is charged for a new period starting from resume).
- If the pause expires without manual resume, the subscription automatically resumes and billing restarts.

**Outputs:**

Pause confirmation (200 OK):
```json
{
  "status": "paused",
  "pause_starts_at": "2026-03-15T00:00:00Z",
  "pause_resumes_at": "2026-06-13T00:00:00Z",
  "message": "Your Pro subscription has been paused until June 13, 2026. You have Free plan access during this time. Resume anytime from your billing settings."
}
```

**Business Rules:**
- Pause counts toward the subscription period for annual plans. Pausing does not extend the annual term.
- Maximum one active pause at a time. A paused subscription cannot be paused again.
- A paused subscription cannot be upgraded or downgraded. The user must resume first.

**Error Handling:**

| Condition | Response |
|---|---|
| User is on Free tier | `400 Bad Request`: `"You don't have an active paid subscription to pause."` |
| User is already paused | `409 Conflict`: `"Your subscription is already paused. It will resume on {resume_date}."` |
| User is in cancelling state | `400 Bad Request`: `"You cannot pause a subscription that is scheduled for cancellation. Cancel the cancellation first, then pause."` |
| `pause_duration_days` < 1 or > 90 | `400 Bad Request`: `"Pause duration must be between 1 and 90 days."` |
| Stripe API error | `503 Service Unavailable`: `"We couldn't pause your subscription right now. Please try again in a few minutes."` |

---

### 3.10 BL-FR-010: Reactivation Flow

**Source:** PRD-009 Section 3.2, BL-FR-010

**Description:** The system allows cancelled users to reactivate their subscription, with different behaviors depending on how long ago they cancelled.

**API Endpoint:** `POST /api/billing/reactivate`

**Inputs:** None (system determines the reactivation path based on subscription state).

**Processing Logic:**

| Scenario | Detection | Behavior |
|---|---|---|
| **Cancel pending** (before period end) | `status == "cancelling"` AND `cancel_at_period_end == true` | Reverse cancellation via `stripe.Subscription.modify()` with `cancel_at_period_end: false`. Subscription continues uninterrupted. No new charge. Update local: `status = "active"`, `cancel_at_period_end = false`, `cancelled_at = null`, `cancellation_reason = null`. Display: "Your subscription has been reactivated! You'll continue with {tier_name} as usual." |
| **Recently cancelled** (< 90 days) | `status == "cancelled"` AND `cancelled_at` is within 90 days | Redirect to Checkout with previous tier pre-selected. On successful checkout, restore previous tier immediately. Historical data intact. Display: "Welcome back! Your {tier_name} subscription is active and all your data has been restored." |
| **Long-cancelled** (> 90 days) | `status == "cancelled"` AND `cancelled_at` is more than 90 days ago | Standard new subscription flow via Checkout. Data may have been deleted per retention policy. Display: "Welcome back to TrendEdge! Note: some of your previous data may no longer be available due to our data retention policy." |

**Outputs:**

For cancel-pending reactivation (200 OK):
```json
{
  "status": "active",
  "tier": "pro",
  "message": "Your subscription has been reactivated! You'll continue with Pro as usual.",
  "next_billing_date": "2026-04-01T00:00:00Z"
}
```

For recently-cancelled or long-cancelled (200 OK):
```json
{
  "checkout_url": "https://checkout.stripe.com/c/pay/cs_xxx...",
  "pre_selected_tier": "pro",
  "message": "Complete checkout to reactivate your Pro subscription."
}
```

**Post-reactivation:** Send reactivation confirmation email with plan details, next billing date, and restored access summary.

**Error Handling:**

| Condition | Response |
|---|---|
| User has an active subscription (not cancelled or cancelling) | `400 Bad Request`: `"Your subscription is already active."` |
| User is on Free tier and has never had a paid subscription | `400 Bad Request`: `"You don't have a previous subscription to reactivate. Visit our pricing page to subscribe."` |
| Stripe API error during reactivation | `503 Service Unavailable`: `"We couldn't reactivate your subscription right now. Please try again in a few minutes."` |

---

### 3.11 BL-FR-011: Annual vs. Monthly Billing Toggle

**Source:** PRD-009 Section 3.2, BL-FR-011

**Description:** The system supports switching between monthly and annual billing intervals for active subscriptions.

**Processing Logic:**

**Monthly to Annual:**
1. User selects "Switch to Annual" in billing settings.
2. System calls `stripe.Invoice.upcoming()` to preview the proration.
3. System displays net charge: "You'll be charged ${annual_price - credit} today (annual price of ${annual_price} minus ${credit} credit for {remaining_days} remaining days on your monthly plan). Save {savings_percent}% with annual billing!"
4. User confirms.
5. System updates Stripe subscription with new annual price ID and `proration_behavior: "create_prorations"`.
6. Switch takes effect immediately. User is charged the net amount.
7. New annual billing cycle starts from today.

**Annual to Monthly:**
1. User selects "Switch to Monthly" in billing settings.
2. System displays: "Your billing will switch to monthly (${monthly_price}/mo) at the end of your current annual period on {annual_period_end_date}. You retain full access until then. No partial refund is issued for the remaining annual term."
3. User confirms.
4. System schedules the price change on the Stripe subscription for the end of the current period with `proration_behavior: "none"`.
5. At period end, Stripe switches to monthly billing and the `customer.subscription.updated` webhook fires.
6. Local subscription record updated: `billing_interval = "monthly"`.

**Outputs:**

Monthly-to-Annual preview:
```json
{
  "switch_type": "monthly_to_annual",
  "current_plan": "Pro Monthly ($99/mo)",
  "new_plan": "Pro Annual ($799/yr)",
  "credit_amount": 4950,
  "credit_display": "$49.50",
  "charge_amount": 74950,
  "charge_display": "$749.50",
  "savings_percent": 33,
  "effective": "immediate"
}
```

Annual-to-Monthly preview:
```json
{
  "switch_type": "annual_to_monthly",
  "current_plan": "Pro Annual ($799/yr)",
  "new_plan": "Pro Monthly ($99/mo)",
  "effective_date": "2027-02-11T00:00:00Z",
  "message": "Your billing will switch to monthly on February 11, 2027. No changes until then."
}
```

**Error Handling:**
- If user is already on the target billing interval: `400 Bad Request`: `"You are already on {interval} billing."`
- If proration charge fails: `402 Payment Required`: `"Your billing switch could not be processed. Please update your payment method and try again."`

---

### 3.12 BL-FR-016: Stripe Webhook Receiver

**Source:** PRD-009 Section 3.4, BL-FR-016

**Description:** The system receives and processes Stripe webhook events for subscription and payment lifecycle management.

**Endpoint:** `POST /api/webhooks/stripe`
**Authentication:** None (public endpoint). Protected by signature verification (BL-FR-017).

**Processing Logic:**

1. Receive raw request body and `Stripe-Signature` header.
2. Verify signature (BL-FR-017). If invalid, return `400 Bad Request` immediately.
3. Parse the event. Check idempotency (BL-FR-018). If already processed, return `200 OK`.
4. Acknowledge receipt by returning `200 OK` to Stripe.
5. Dispatch event to background Celery task queue for asynchronous processing.
6. Background worker processes the event based on type (see table below).

**Handled Events and Actions:**

| Stripe Event | Background Processing Actions |
|---|---|
| `checkout.session.completed` | 1. Extract `customer` and `subscription` from the session. 2. Look up user by `user_id` in session metadata. 3. Update subscriptions table: set `stripe_customer_id`, `stripe_subscription_id`, `tier` (from metadata), `status = "active"` or `"trialing"`, `billing_interval`, `current_period_start/end`. 4. Set `has_used_trial = true` if trial was included. 5. Invalidate Redis tier cache. 6. Send `welcome_paid` or `welcome_trial` email. |
| `customer.subscription.created` | 1. Update subscription status to `active`. 2. Update tier. 3. Log event in audit trail. |
| `customer.subscription.updated` | 1. Compare previous and current subscription attributes. 2. If tier changed: update local tier, invalidate Redis cache. 3. If billing interval changed: update local `billing_interval`. 4. If status changed (e.g., `past_due`): update local status. 5. If `cancel_at_period_end` changed: update local field. 6. If pending downgrade completed (new tier is lower): update tier, clear `pending_downgrade_tier`. |
| `customer.subscription.deleted` | 1. Set `tier = "free"`. 2. Set `status = "cancelled"`. 3. Clear `pending_downgrade_tier`. 4. Invalidate Redis cache. 5. Send `cancellation_effective` email. |
| `customer.subscription.paused` | 1. Set `status = "paused"`. 2. Revert tier enforcement to Free limits (but do NOT change `tier` field -- preserve the "real" tier for resume). 3. Invalidate Redis cache. |
| `customer.subscription.resumed` | 1. Restore tier from subscription record. 2. Set `status = "active"`. 3. Invalidate Redis cache. |
| `customer.subscription.trial_will_end` | 1. Send `trial_ending` email: "Your Pro trial ends in 3 days. Your card ending in {last4} will be charged $99/mo. Cancel anytime before {trial_end_date}." |
| `invoice.payment_succeeded` | 1. Update `last_payment_date` on subscription. 2. Reset dunning state: `payment_status = "current"`, `dunning_step = 0`, `dunning_started_at = null`. 3. Store invoice metadata in `invoices` table [see FSD-009c]. 4. Send `invoice_receipt` email. |
| `invoice.payment_failed` | 1. Extract `attempt_count` from invoice. 2. Update `payment_status = "past_due"`. 3. Trigger dunning sequence (BL-FR-020): increment `dunning_step`, send appropriate dunning email. 4. If 7 days since first failure: restrict to Free tier limits. |
| `invoice.finalized` | 1. Store invoice ID and PDF URL in `invoices` table [see FSD-009c]. |
| `payment_method.attached` | 1. Update `payment_method_last4` and `payment_method_brand` on user record (see BL-FR-004). |
| `payment_method.detached` | 1. Clear `payment_method_last4` and `payment_method_brand` if it was the default (see BL-FR-004). |
| `customer.updated` | 1. Sync billing email, name, or address changes if applicable. |

**Unhandled events:** Log to monitoring system with event type and ID at INFO level. Return `200 OK`. Do not error on unknown event types.

---

### 3.13 BL-FR-017: Webhook Signature Verification

**Source:** PRD-009 Section 3.4, BL-FR-017

**Description:** All incoming Stripe webhooks are verified for authenticity using HMAC-SHA256 signature verification before any processing occurs.

**Processing Logic:**

1. Read the raw request body (do NOT parse JSON first -- signature is computed on the raw bytes).
2. Read the `Stripe-Signature` header.
3. Call `stripe.Webhook.construct_event(payload=raw_body, sig_header=signature_header, secret=STRIPE_WEBHOOK_SECRET)`.
4. If verification succeeds: proceed with event processing.
5. If verification fails: return `400 Bad Request` with no additional details. Log a WARNING: `"Webhook signature verification failed. IP: {ip_address}."` Do NOT reveal the reason for rejection in the response body.

**Business Rules:**
- `STRIPE_WEBHOOK_SECRET` is stored in environment variables, never in source code or configuration files committed to version control.
- Separate webhook secrets for test mode and live mode.
- Stripe's timestamp tolerance is 5 minutes. Events with timestamps older than 5 minutes are rejected.
- Webhook signing secret should be rotated annually or immediately upon suspected compromise.

**Rate Limiting:** The webhook endpoint is rate-limited to 100 requests/second to prevent DoS attacks. Requests exceeding this limit receive `429 Too Many Requests`.

---

### 3.14 BL-FR-018: Idempotent Event Processing

**Source:** PRD-009 Section 3.4, BL-FR-018

**Description:** Each webhook event is processed exactly once, even if Stripe delivers it multiple times due to retries or network issues.

**Processing Logic:**

1. Before processing any event, check the `stripe_events` table for the `event_id`:
   - If found with `status = "processed"`: return `200 OK` immediately. Do not process again. Log: `"Skipping duplicate event {event_id} (already processed)."`
   - If found with `status = "failed"`: re-attempt processing. Update `status` to `"processing"`.
   - If found with `status = "processing"`: another worker is currently processing this event. Return `200 OK`. (Handles concurrent webhook deliveries.)
   - If not found: insert a new record with `status = "processing"`.
2. Process the event within a database transaction:
   - If processing succeeds: update `status = "processed"`, set `processed_at`.
   - If processing fails: update `status = "failed"`, set `error_message` with the exception details.
3. For failed events, retry logic: failed events are retried up to 3 times with exponential backoff (1 minute, 5 minutes, 30 minutes). After 3 retries, the event remains as `"failed"` and triggers a CRITICAL alert for manual investigation.

**Data Retention:** Processed events are retained for 90 days, then archived/deleted. Failed events are retained until manually resolved.

---

### 3.15 BL-FR-019 & BL-FR-020: Failed Payment and Dunning Management

**Source:** PRD-009 Section 3.4, BL-FR-019 and BL-FR-020

**Description:** The system handles failed payment retries (managed by Stripe Smart Retries) and implements a dunning email sequence to maximize payment recovery.

**Stripe Retry Configuration:**
- Smart Retries enabled (Stripe's ML-optimized retry timing).
- Maximum retry attempts: 4 over 3 weeks.
- After all retries exhausted: Stripe cancels the subscription.

**Local Dunning State Machine:**

| Dunning Step | Trigger | Timing | Email Template | Access Impact |
|---|---|---|---|---|
| 0 | No failure | N/A | N/A | Full tier access |
| 1 | First `invoice.payment_failed` | Immediately | `payment_failed_1`: "Your payment of ${amount} failed. Please update your payment method to avoid service interruption." CTA: "Update Payment Method" -> Customer Portal | Full tier access (grace period) |
| 2 | Second failure (Stripe retry) | ~3 days after first | `payment_failed_2`: "We're still unable to process your payment. Your access will be limited on {grace_end_date}." CTA: "Update Payment Method" | Full tier access (grace period) |
| 3 | Grace period ending | 6 days after first failure | `payment_grace_ending`: "Action required: Update your payment method by tomorrow to maintain your {tier} access." Urgent tone. CTA: "Update Payment Method" | Full tier access (last day of grace) |
| 4 | Access restricted | 7 days after first failure | `access_restricted`: "Your account has been restricted to Free tier access. Update your payment method to restore full access immediately." CTA: "Restore Access" | **Restricted to Free tier limits** (data preserved) |
| 5 | Final warning | 3 days before Stripe cancellation | `payment_final_warning`: "Your subscription will be cancelled on {cancel_date}. All {tier} features will be permanently removed. Your data will be preserved for 90 days." CTA: "Keep My Subscription" | Free tier limits |
| (cancelled) | Stripe cancels subscription | After all retries exhausted | `cancellation_effective`: "Your subscription has been cancelled. Your data will be preserved for 90 days. You can reactivate anytime." CTA: "Reactivate" | Free tier (subscription ended) |

**Processing Logic:**

1. On `invoice.payment_failed` webhook:
   a. Look up user by `stripe_customer_id`.
   b. If `dunning_step == 0`: set `dunning_started_at = now()`, `payment_status = "past_due"`.
   c. Increment `dunning_step`.
   d. Send the email for the current dunning step.
   e. Each email is tracked (stored in `stripe_events` or a separate `dunning_emails` log) to prevent duplicates.

2. Scheduled job (runs hourly): check all subscriptions with `payment_status = "past_due"`:
   a. If `dunning_started_at` + 6 days <= now AND `dunning_step < 3`: send step 3 email, set `dunning_step = 3`.
   b. If `dunning_started_at` + 7 days <= now AND `dunning_step < 4`: restrict access to Free tier limits, send step 4 email, set `dunning_step = 4`.
   c. If subscription has an upcoming Stripe cancellation date AND cancellation_date - 3 days <= now AND `dunning_step < 5`: send step 5 email, set `dunning_step = 5`.

3. On `invoice.payment_succeeded` webhook (recovery):
   a. Reset: `payment_status = "current"`, `dunning_step = 0`, `dunning_started_at = null`.
   b. If access was restricted: restore full tier access immediately.
   c. Invalidate Redis tier cache.
   d. Send `payment_recovered` email: "Great news! Your payment has been processed successfully. Your {tier} access has been fully restored."

**Business Rules:**
- During the 7-day grace period, the user retains FULL access to their current tier. Access is NOT degraded during grace.
- After 7 days, access is restricted to Free tier limits, but ALL user data is preserved and accessible (read-only for features beyond Free limits).
- The `payment_status` field drives access restriction, separate from the `tier` field. The `tier` remains the user's paid tier until Stripe cancels the subscription.

---

### 3.16 BL-FR-023: 14-Day Pro Trial

**Source:** PRD-009 Section 3.7, BL-FR-023

**Description:** New users can try the Pro tier free for 14 days. The trial requires a payment method on file and automatically converts to a paid subscription unless cancelled.

**Trial Eligibility:**
- User's `has_used_trial` must be `false`.
- User must not have ever had a paid subscription.
- One trial per account, enforced by the `has_used_trial` boolean.

**Processing Logic:**

1. User selects "Start Free Trial" on the Pro plan.
2. System checks `has_used_trial`. If `true`: return `400 Bad Request` with message: "You've already used your free trial. Subscribe to Pro for $99/month."
3. System creates a Stripe Checkout Session with `subscription_data.trial_period_days: 14` (see BL-FR-002).
4. User enters payment method on Stripe Checkout (required for trial).
5. On `checkout.session.completed` webhook:
   - Set `status = "trialing"`, `tier = "pro"`.
   - Set `trial_start` and `trial_end` dates.
   - Set `has_used_trial = true`.
   - Send `welcome_trial` email.
6. During trial: full Pro tier access.
7. Day 7: send `trial_midpoint` email with usage summary.
8. Day 11 (3 days before end): `customer.subscription.trial_will_end` webhook fires. Send `trial_ending` email.
9. Day 14 -- trial ends:
   - If payment method valid: Stripe charges $99.00. `customer.subscription.updated` webhook fires with status `active`. Send `trial_converted` email.
   - If payment fails: subscription enters dunning flow (BL-FR-020).
10. If user cancels during trial:
    - Access remains Pro until trial end date.
    - No charge is made.
    - After trial end: `customer.subscription.deleted` webhook fires. User reverts to Free. Send `trial_expired` email.

**Trial Notification Schedule:**

| Timing | Template | Key Content |
|---|---|---|
| Trial start | `welcome_trial` | "Welcome to your 14-day Pro trial! Here's what you can do: [feature list]. Your trial ends on {trial_end_date}." |
| Day 7 | `trial_midpoint` | "You're halfway through your Pro trial. Here's what you've accomplished: {usage_summary}." |
| Day 11 | `trial_ending` | "Your Pro trial ends in 3 days on {trial_end_date}. Your card ending in {last4} will be charged $99/mo. Cancel anytime before {trial_end_date}." |
| Trial auto-converts | `trial_converted` | "Your trial has ended. Welcome to TrendEdge Pro! You've been charged $99.00." |
| Trial cancelled/expired | `trial_expired` | "Your Pro trial has ended. You're now on the Free plan. Upgrade anytime to get Pro features back." |

---

### 3.17 BL-FR-027 & BL-FR-028: Subscription State Machine

**Source:** PRD-009 Sections 3.11 and 3.12

**Description:** The local `subscriptions` table is the primary local record of subscription state, synchronized with Stripe via webhooks. The state machine enforces valid state transitions.

**Valid Transitions:**

| From State | Event | To State | Actions |
|---|---|---|---|
| (none) | user_registers | active (free) | Create subscription record: `tier="free"`, `status="active"`. |
| active (free) | checkout_completed | active (paid) | Update tier, set Stripe IDs, send welcome email. |
| active (free) | trial_started | trialing | Set `tier="pro"`, set trial dates, send trial welcome. |
| trialing | trial_ended_payment_success | active (paid) | `status="active"`, send conversion email. |
| trialing | trial_ended_payment_failed | past_due | Begin dunning sequence. |
| trialing | user_cancels | cancelling | `cancel_at_period_end=true`, retain access until trial end. |
| active (paid) | upgrade_completed | active (paid) | Update tier, proration charged, send upgrade confirmation. |
| active (paid) | downgrade_requested | active (paid) | Set `pending_downgrade_tier`. No immediate tier change. |
| active (paid) | billing_interval_changed | active (paid) | Update interval, process proration if applicable. |
| active (paid) | payment_failed | past_due | `payment_status="past_due"`, begin dunning. |
| active (paid) | user_cancels | cancelling | `cancel_at_period_end=true`, retention offer shown. |
| active (paid) | pause_requested | paused | Set pause dates, revert to Free limits, void invoices. |
| past_due | payment_succeeded | active (paid) | Reset dunning, restore full access. |
| past_due | all_retries_exhausted | cancelled | Cancel subscription, revert to Free, send email. |
| past_due | user_updates_payment | active (paid) | Retry charge; if successful, reset dunning. |
| paused | resume_requested | active (paid) | Resume billing, restore tier. |
| paused | pause_expired | active (paid) | Auto-resume, restart billing cycle. |
| cancelling | period_ends | cancelled | Revert to Free, begin data retention countdown. |
| cancelling | user_reactivates | active (paid) | Remove `cancel_at_period_end`, continue subscription. |
| cancelled | user_resubscribes | active (paid) | New Checkout, create new subscription, restore data if within retention. |

**Invalid transitions** are rejected with a logged ERROR and a user-facing message: "This action cannot be performed on your current subscription status. Current status: {status}." HTTP status: `409 Conflict`.

**Lifecycle Diagram:**

```
                                    +------------------+
                                    |    (new user)    |
                                    +--------+---------+
                                             |
                                      user_registers
                                             |
                                             v
                                    +------------------+
                          +-------->|  active (free)   |<---------+
                          |         +--------+---------+          |
                          |                  |                    |
                    period_ends      checkout_completed    all_retries_exhausted
                    (from cancelling)  OR trial_started    (from past_due)
                          |                  |                    |
                          |         +--------v---------+          |
                          |         | active (paid) /  |          |
                          |         |    trialing      |          |
                          |         +--+----+----+--+--+          |
                          |            |    |    |  |             |
                          |   payment_ |    | user_ | pause_     |
                          |   failed   |    | cancels| requested |
                          |            v    |    v  |  v          |
                          |     +------+--+ | +--+------+  +-----+----+
                          |     | past_due| | |cancelling|  |  paused  |
                          |     +----+----+ | +----+-----+  +----+-----+
                          |          |      |      |             |
                          |  payment_|      | period_ends   resume/expire
                          |  succeeded      |      |             |
                          |          |      |      v             |
                          |          +------+ +----+------+      |
                          |                   | cancelled |      |
                          |                   +-----+-----+      |
                          |                         |             |
                          +--- user_resubscribes ---+             |
                          +--- user_reactivates (from cancelling)-+
                          +--- resume_requested (from paused) ----+
```

---

## 4. Data Specifications

### 4.1 `subscriptions` Table Schema

| Column | Type | Constraints | Description |
|---|---|---|---|
| id | bigint | PK, AUTO_INCREMENT | Primary key |
| user_id | uuid | FK to users, UNIQUE, NOT NULL | One subscription per user |
| stripe_subscription_id | varchar(255) | UNIQUE, NULLABLE | Null for Free tier |
| stripe_customer_id | varchar(255) | NULLABLE | Null for Free tier before first paid action |
| tier | varchar(20) | NOT NULL, DEFAULT 'free' | `free`, `trader`, `pro`, `team` |
| status | varchar(20) | NOT NULL, DEFAULT 'active' | `active`, `trialing`, `past_due`, `paused`, `cancelling`, `cancelled` |
| billing_interval | varchar(10) | NOT NULL, DEFAULT 'none' | `monthly`, `annual`, `none` |
| current_period_start | timestamptz | NULLABLE | Start of current billing period |
| current_period_end | timestamptz | NULLABLE | End of current billing period |
| trial_start | timestamptz | NULLABLE | Trial start date |
| trial_end | timestamptz | NULLABLE | Trial end date |
| cancel_at_period_end | boolean | NOT NULL, DEFAULT false | Cancellation pending |
| cancelled_at | timestamptz | NULLABLE | When cancellation was requested |
| cancellation_reason | varchar(50) | NULLABLE | From cancellation survey |
| pending_downgrade_tier | varchar(20) | NULLABLE | Tier to downgrade to at period end |
| payment_status | varchar(20) | NOT NULL, DEFAULT 'current' | `current`, `past_due`, `unpaid` |
| dunning_step | integer | NOT NULL, DEFAULT 0 | Current dunning step (0-5) |
| dunning_started_at | timestamptz | NULLABLE | When dunning began |
| has_used_trial | boolean | NOT NULL, DEFAULT false | Trial usage flag |
| pause_starts_at | timestamptz | NULLABLE | Pause start date |
| pause_resumes_at | timestamptz | NULLABLE | Pause auto-resume date |
| payment_method_last4 | varchar(4) | NULLABLE | Display only |
| payment_method_brand | varchar(20) | NULLABLE | Display only |
| created_at | timestamptz | NOT NULL, DEFAULT now() | Record creation |
| updated_at | timestamptz | NOT NULL, DEFAULT now() | Last update |

**Indexes:**
- `idx_subscriptions_user_id` (unique)
- `idx_subscriptions_stripe_subscription_id` (unique, partial: WHERE stripe_subscription_id IS NOT NULL)
- `idx_subscriptions_stripe_customer_id`
- `idx_subscriptions_status`
- `idx_subscriptions_tier`

### 4.2 `stripe_events` Table Schema

| Column | Type | Constraints | Description |
|---|---|---|---|
| event_id | varchar(255) | PK | Stripe event ID (e.g., `evt_xxx`) |
| event_type | varchar(100) | NOT NULL | e.g., `invoice.payment_succeeded` |
| processed_at | timestamptz | NULLABLE | When processing completed |
| status | varchar(20) | NOT NULL, DEFAULT 'processing' | `processing`, `processed`, `failed`, `skipped` |
| error_message | text | NULLABLE | Error details if processing failed |
| raw_payload | jsonb | NOT NULL | Full event payload for debugging |

### 4.3 `cancellation_events` Table Schema

| Column | Type | Constraints | Description |
|---|---|---|---|
| id | bigint | PK, AUTO_INCREMENT | Primary key |
| user_id | uuid | FK to users, NOT NULL | User identifier |
| reason | varchar(50) | NOT NULL | Cancellation reason code |
| reason_text | text | NULLABLE | Free-text reason (for "other") |
| retention_offer_shown | boolean | NOT NULL | Whether retention offer was displayed |
| retention_offer_type | varchar(50) | NULLABLE | Type of retention offer shown |
| retention_offer_accepted | boolean | NOT NULL | Whether user accepted the offer |
| cancellation_completed | boolean | NOT NULL | Whether cancellation was finalized |
| created_at | timestamptz | NOT NULL, DEFAULT now() | Event timestamp |

### 4.4 Redis Cache Keys (owned by FSD-009b, invalidated by this subsystem)

| Key Pattern | Invalidation Trigger (this subsystem) |
|---|---|
| `user:{user_id}:tier_features` | On any webhook that changes tier, status, or payment_status |

This subsystem calls `redis.delete(f"user:{user_id}:tier_features")` after processing any subscription-changing webhook event. The cache structure and TTL are defined in FSD-009b.

---

## 5. API Specifications

### 5.1 Subscription Lifecycle Endpoints

| Method | Path | Auth | Rate Limit | Description |
|---|---|---|---|---|
| POST | `/api/billing/checkout` | Required | 10/min/user | Create Stripe Checkout Session |
| POST | `/api/billing/portal` | Required | 10/min/user | Create Stripe Customer Portal Session |
| POST | `/api/billing/pause` | Required | 10/min/user | Pause subscription |
| POST | `/api/billing/resume` | Required | 10/min/user | Resume paused subscription |
| POST | `/api/billing/reactivate` | Required | 10/min/user | Reactivate cancelled subscription |
| GET | `/api/billing/subscription` | Required | 60/min/user | Get current subscription details |
| POST | `/api/webhooks/stripe` | None (signature verified) | 100/sec | Stripe webhook receiver |

### 5.2 Key API Response Formats

**GET `/api/billing/subscription` Response (200 OK):**
```json
{
  "tier": "pro",
  "status": "active",
  "billing_interval": "monthly",
  "current_period_start": "2026-03-01T00:00:00Z",
  "current_period_end": "2026-03-31T23:59:59Z",
  "cancel_at_period_end": false,
  "pending_downgrade_tier": null,
  "payment_status": "current",
  "payment_method": {
    "brand": "visa",
    "last4": "4242"
  },
  "trial": null,
  "next_invoice_amount": "$99.00",
  "next_invoice_date": "2026-04-01"
}
```

---

## 6. Integration Specifications

### 6.1 Stripe Integration

**Provider:** Stripe
**API Version:** 2023-10-16 or later
**SDK:** `stripe` Python package (latest stable version)

**Stripe Resources Used:**

| Resource | Operations | Purpose |
|---|---|---|
| Products | Create, Retrieve | Tier product definitions |
| Prices | Create, Retrieve, List | Monthly and annual price configurations |
| Customers | Create, Retrieve, Update | One-to-one mapping with TrendEdge users |
| Subscriptions | Create, Retrieve, Update, Cancel | Subscription lifecycle management |
| Checkout Sessions | Create | New subscription and trial checkout |
| Billing Portal Sessions | Create | Self-service billing management |
| Invoices | Retrieve, Upcoming | Proration preview |
| Coupons | Retrieve | Retention coupon application |
| Webhooks | Receive | Event-driven subscription management |
| Payment Methods | Retrieve | Display card info (last4, brand) |

**Stripe API Endpoints Reference:**

| Stripe Call | TrendEdge Context |
|---|---|
| `stripe.Product.create()` | Seed script only |
| `stripe.Price.create()` | Seed script only |
| `stripe.Customer.create()` | On first paid action |
| `stripe.Customer.retrieve()` | Health check, admin lookup |
| `stripe.checkout.Session.create()` | Checkout flow |
| `stripe.billing_portal.Session.create()` | Portal flow |
| `stripe.Subscription.retrieve()` | Reconciliation job |
| `stripe.Subscription.modify()` | Upgrade, downgrade, pause, resume, cancel |
| `stripe.Invoice.upcoming()` | Proration preview |
| `stripe.Webhook.construct_event()` | Webhook signature verification |
| `stripe.Account.retrieve()` | Health check |

**Error Handling for Stripe API Calls:**

| Error Type | HTTP Status from Stripe | TrendEdge Response |
|---|---|---|
| `CardError` | 402 | Forward decline message to user: "Your card was declined: {decline_message}" |
| `RateLimitError` | 429 | Retry with exponential backoff: 1s, 2s, 4s. Max 3 retries. If still failing: `503 Service Unavailable` |
| `InvalidRequestError` | 400 | Log ERROR with full details. Return `400 Bad Request` with generic message. |
| `AuthenticationError` | 401 | Log CRITICAL: "Stripe API key invalid." Alert ops. Return `503 Service Unavailable`. |
| `APIConnectionError` | N/A (network) | Retry once after 2s. If still failing: `503 Service Unavailable`. |
| `StripeError` (generic) | 500 | Log ERROR. Return `503 Service Unavailable`: "Payment processing is temporarily unavailable." |

**Fallback Behavior:**
- If Stripe is unavailable for > 5 minutes: feature gating continues from cached data. New subscriptions and changes are blocked. Health check endpoint `/api/health/billing` reports Stripe as degraded.
- Queued webhook events (from Stripe retries) are processed when connectivity is restored.

### 6.2 SendGrid Email Templates (triggered by this subsystem)

| Template ID | Trigger | Key Variables |
|---|---|---|
| `welcome_paid` | Subscription created | `tier_name`, `features_list`, `next_billing_date` |
| `welcome_trial` | Trial started | `tier_name`, `trial_end_date`, `cancel_instructions` |
| `trial_midpoint` | Day 7 of trial | `usage_summary`, `days_remaining` |
| `trial_ending` | 3 days before trial end | `trial_end_date`, `charge_amount`, `last4`, `cancel_url` |
| `trial_converted` | Trial auto-converts | `tier_name`, `charge_amount`, `next_billing_date` |
| `trial_expired` | Trial cancelled/expired | `upgrade_url` |
| `upgrade_confirmation` | Upgrade processed | `new_tier`, `prorated_charge`, `new_features` |
| `downgrade_scheduled` | Downgrade requested | `effective_date`, `lost_features`, `cancel_downgrade_url` |
| `downgrade_effective` | Downgrade takes effect | `new_tier`, `feature_changes`, `upgrade_url` |
| `cancellation_confirmation` | Cancellation requested | `access_end_date`, `data_retention_days`, `reactivate_url` |
| `cancellation_effective` | Subscription cancelled | `reactivate_url`, `data_retention_timeline` |
| `payment_failed_1` | First payment failure | `amount`, `update_payment_url` |
| `payment_failed_2` | Second failure | `amount`, `grace_end_date`, `update_payment_url` |
| `payment_grace_ending` | 6 days after first failure | `tier_name`, `update_payment_url` |
| `access_restricted` | 7 days after first failure | `restore_access_url` |
| `payment_final_warning` | 3 days before cancellation | `cancel_date`, `tier_name`, `keep_subscription_url` |
| `payment_recovered` | Successful retry | `tier_name`, `amount` |
| `invoice_receipt` | Payment succeeded | `amount`, `invoice_url`, `next_billing_date` |
| `reactivation_confirmation` | Subscription reactivated | `tier_name`, `next_billing_date`, `features_restored` |
| `pause_confirmation` | Subscription paused | `resume_date`, `free_access_note` |
| `pause_resuming` | 3 days before auto-resume | `resume_date`, `billing_restart_note` |

Email delivery failures NEVER block subscription state changes. If SendGrid is unavailable, emails are queued for retry.

### 6.3 Environment Variables

| Variable | Description | Required | Default |
|---|---|---|---|
| `STRIPE_SECRET_KEY` | Stripe API secret key (live or test) | Yes | None |
| `STRIPE_PUBLISHABLE_KEY` | Stripe publishable key for client-side | Yes | None |
| `STRIPE_WEBHOOK_SECRET` | Webhook endpoint signing secret | Yes | None |
| `STRIPE_PRICE_TRADER_MONTHLY` | Price ID for Trader monthly | Yes | None |
| `STRIPE_PRICE_TRADER_ANNUAL` | Price ID for Trader annual | Yes | None |
| `STRIPE_PRICE_PRO_MONTHLY` | Price ID for Pro monthly | Yes | None |
| `STRIPE_PRICE_PRO_ANNUAL` | Price ID for Pro annual | Yes | None |
| `STRIPE_PRICE_TEAM_MONTHLY` | Price ID for Team monthly | Yes | None |
| `STRIPE_PRICE_TEAM_ANNUAL` | Price ID for Team annual | Yes | None |
| `STRIPE_PORTAL_CONFIG_ID` | Customer portal configuration ID | Yes | None |
| `BILLING_TRIAL_DAYS` | Trial period in days | No | 14 |
| `BILLING_DUNNING_GRACE_DAYS` | Grace period before access restriction | No | 7 |
| `BILLING_DATA_RETENTION_DAYS` | Days to retain cancelled user data | No | 90 |
| `BASE_URL` | Application base URL for Stripe redirect URLs | Yes | None |

---

## 7. Security Specifications

### 7.1 PCI DSS Compliance

TrendEdge is classified as **PCI SAQ-A** (Self-Assessment Questionnaire A), the simplest PCI compliance level. All cardholder data is handled exclusively by Stripe.

**Mandatory requirements:**
- No credit card numbers, CVVs, or full card data SHALL be transmitted to, processed by, or stored on TrendEdge servers at any time, in any form (database, log, cache, file, memory dump).
- All payment forms use Stripe Checkout (hosted pages). Card data never transits TrendEdge servers.
- Stripe.js is loaded directly from `js.stripe.com` -- it MUST NOT be self-hosted or bundled.
- TrendEdge servers communicate with Stripe only via server-side API using the `STRIPE_SECRET_KEY` over HTTPS.
- The system stores only: Stripe customer ID, last 4 digits of card, card brand, and expiration month/year (for display purposes only).
- Annual PCI SAQ-A self-assessment must be completed and documented.

**Prohibited actions (hard requirements):**
- NEVER log raw card numbers, even partially (beyond last 4).
- NEVER store CVV/CVC values in any form.
- NEVER transmit card data through TrendEdge API endpoints.
- NEVER render card input fields on TrendEdge-hosted pages (use Stripe Checkout or Stripe Elements only).

### 7.2 Stripe API Key Security

| Key Type | Storage | Access |
|---|---|---|
| `STRIPE_SECRET_KEY` | Environment variable only | Server-side code only. Never exposed to client. |
| `STRIPE_PUBLISHABLE_KEY` | Environment variable, exposed to frontend | Client-side JavaScript only. Safe to expose. |
| `STRIPE_WEBHOOK_SECRET` | Environment variable only | Webhook handler only. |

**Key management rules:**
- Stripe API keys MUST NOT appear in source code, configuration files committed to version control, client-side JavaScript (secret key), log output at any level (including DEBUG), error messages or stack traces returned to users, or database records.
- Separate keys for test mode and live mode environments.
- Key rotation: immediately upon suspected compromise. Proactively at least annually.
- If a `STRIPE_SECRET_KEY` is detected in source code or logs, treat as a security incident: rotate immediately, audit access logs, notify security team.

### 7.3 Webhook Security

**Signature verification:**
- All webhook requests are verified using Stripe's HMAC-SHA256 signature scheme before any processing occurs (BL-FR-017).
- Invalid signatures result in `400 Bad Request` with no additional details. The response body MUST NOT indicate why the request was rejected.
- Webhook signing secret is rotated annually or immediately upon suspected compromise.
- Separate webhook signing secrets for test and live modes.

**Rate limiting:**
- Webhook endpoint is rate-limited to 100 requests/second to mitigate DoS attacks.
- Requests exceeding this limit receive `429 Too Many Requests`.

**Timestamp validation:**
- Events with timestamps older than 5 minutes (300 seconds) are rejected per Stripe's tolerance window.

### 7.4 API Endpoint Security

**Authentication:**
- All billing API endpoints (except the webhook receiver) require a valid JWT token. [See FSD-008 for JWT authentication details]

**Authorization:**
- Users can only access their own billing data. The `user_id` is extracted from the JWT, not from request parameters.

**Rate limiting:**
- Mutation endpoints (checkout, cancel, upgrade, pause, resume, reactivate): 10 requests/minute per user.
- Read endpoints (subscription): 60 requests/minute per user.
- Rate limit exceeded: `429 Too Many Requests` with `Retry-After` header.

### 7.5 Webhook Payload Logging

- Webhook payloads are logged for debugging purposes but with PII redaction.
- Redacted fields: `customer.email`, `customer.name`, `customer.address`, `payment_method.billing_details`.
- Retained fields: `event.type`, `event.id`, `subscription.id`, `subscription.status`, `invoice.id`, `invoice.amount_paid`.

### 7.6 Audit Trail

All subscription lifecycle actions are logged in an audit trail:

| Field | Type | Description |
|---|---|---|
| id | bigint | Primary key |
| user_id | uuid | User who performed or was affected by the action |
| action | varchar(50) | e.g., `subscription_created`, `upgrade_completed`, `cancellation_requested` |
| actor_id | uuid | User who initiated the action (same as user_id for self-service, admin_id for admin actions) |
| details | jsonb | Action-specific details (tier change, amount, reason, etc.) |
| ip_address | inet | IP address of the requester |
| timestamp | timestamptz | When the action occurred |

**Audit events logged by this subsystem:**
- Subscription created, updated, cancelled, paused, resumed, reactivated
- Upgrade and downgrade requests and completions
- Payment succeeded, failed, recovered
- Billing portal session created
- Webhook events processed (event type and outcome)

**Retention:** Audit logs are retained for 7 years (consistent with financial record retention requirements).

---

## 8. Performance Specifications

### 8.1 Webhook Processing

| Metric | Target |
|---|---|
| Acknowledgment time (HTTP 200) | < 5 seconds from receipt |
| Background processing completion (p99) | < 30 seconds from acknowledgment |
| Burst capacity | 100 events/second with zero drops |
| Event queue backlog tolerance | Up to 10,000 events queued without degradation |

**Implementation constraints:**
- Webhook handler performs only signature verification and idempotency check synchronously.
- All business logic (tier updates, email sending, database writes) is dispatched to the Celery task queue.
- Celery workers auto-scale based on queue depth: minimum 2 workers, maximum 10 workers.

### 8.2 Checkout Session Creation

| Metric | Target |
|---|---|
| API response time (p99) | < 2 seconds |
| Concurrent session creation | 50 simultaneous sessions |

### 8.3 Database Query Performance

| Query | Target | Index Used |
|---|---|---|
| Look up subscription by user_id | < 1ms | `idx_subscriptions_user_id` (unique) |
| Look up subscription by stripe_subscription_id | < 1ms | `idx_subscriptions_stripe_subscription_id` |
| Look up stripe_event by event_id | < 1ms | PK on `event_id` |

### 8.4 Scalability

The subscription lifecycle system SHALL support up to 10,000 concurrent subscribers without performance degradation.

| Component | Capacity |
|---|---|
| PostgreSQL | 10,000 subscription records with indexed queries < 5ms |
| Celery workers | Auto-scaling 2-10 workers based on queue depth |
| Webhook processing | 100 events/second sustained |

---

## 9. Testing Specifications

### 9.1 BL-TEST-001: Stripe Test Mode End-to-End Testing

All development and staging environments SHALL use Stripe test mode with test API keys.

**Test card scenarios:**

| Test Case | Stripe Test Card | Expected Result |
|---|---|---|
| Successful checkout | `4242 4242 4242 4242` | Subscription created, tier updated within 10 seconds, welcome email sent, status `active`. |
| Card declined | `4000 0000 0000 0002` | Checkout fails, user shown "Your payment could not be processed. Please try a different payment method.", no subscription created, tier remains `free`. |
| Insufficient funds | `4000 0000 0000 9995` | Payment fails, dunning sequence initiated, `payment_status` set to `past_due`, dunning email 1 sent. |
| 3D Secure required | `4000 0025 0000 3155` | 3DS challenge presented in Stripe Checkout, subscription created on successful 3DS completion. |
| Card expires during subscription | `4000 0000 0000 0341` | Renewal fails, dunning email sent, 7-day grace period starts, `payment_status` set to `past_due`. |
| Disputed payment | `4000 0000 0000 0259` | Dispute webhook received, admin alerted via monitoring, event logged. |

**Test automation:**
- Integration tests use Stripe test mode API directly (not mocks) for checkout, subscription changes, and webhook delivery.
- Webhook tests use Stripe CLI (`stripe trigger {event_type}`) or construct test events programmatically with `stripe.Webhook.construct_event()`.
- CI/CD pipeline runs billing integration tests on every PR that touches files in the billing module.

### 9.2 BL-TEST-002: Webhook Security Testing

| Test Case | Input | Expected Result |
|---|---|---|
| Valid signature, valid payload | Properly signed event | Event processed successfully, `200 OK`, event recorded in `stripe_events` with status `processed`. |
| Invalid signature | Tampered `Stripe-Signature` header | `400 Bad Request`, event NOT processed, WARNING log entry. |
| Missing signature header | No `Stripe-Signature` header | `400 Bad Request`, event NOT processed. |
| Expired timestamp (> 5 min old) | Valid signature but old timestamp | `400 Bad Request`, event NOT processed. |
| Valid signature, malformed JSON payload | Corrupted body after signing | `400 Bad Request`, error logged. |
| Replay attack (duplicate event ID) | Same valid event delivered twice | Second delivery returns `200 OK`, no duplicate processing, no duplicate emails, no duplicate tier changes. |

### 9.3 BL-TEST-003: Subscription State Machine Testing

Every valid state transition in the state machine (Section 3.17) SHALL have at least one automated test.

**Required test coverage:**

| Transition | Test Verifies |
|---|---|
| (none) -> active (free) | Registration creates subscription with `tier="free"`, `status="active"` |
| active (free) -> active (paid) | Checkout completion updates tier, sets Stripe IDs, sends email |
| active (free) -> trialing | Trial checkout sets `status="trialing"`, `tier="pro"`, `has_used_trial=true` |
| trialing -> active (paid) | Payment success changes status to `active`, sends conversion email |
| trialing -> past_due | Payment failure starts dunning |
| trialing -> cancelling | Cancel sets `cancel_at_period_end=true` |
| active (paid) -> active (paid) [upgrade] | Tier changes immediately, proration charged |
| active (paid) -> active (paid) [downgrade requested] | `pending_downgrade_tier` set, tier unchanged |
| active (paid) -> past_due | Payment failure updates `payment_status` |
| active (paid) -> cancelling | `cancel_at_period_end=true`, retention offer tracked |
| active (paid) -> paused | Pause dates set, access reverts to Free limits |
| past_due -> active (paid) | Payment recovery resets dunning, restores access |
| past_due -> cancelled | All retries exhausted, tier reverts to Free |
| paused -> active (paid) | Resume restores tier and billing |
| cancelling -> cancelled | Period end reverts to Free |
| cancelling -> active (paid) | Reactivation removes cancel flag |
| cancelled -> active (paid) | New checkout creates new subscription |

**Additional state machine tests:**
- Invalid transition attempt (e.g., `paused` -> `cancelling`) returns `409 Conflict`.
- Concurrent state change attempts handled correctly without data corruption.
- Upgrade and downgrade within the same billing period calculates prorations correctly.
- Cancel and reactivate multiple times does not corrupt subscription state.
- Subscription expires exactly at billing period boundary (midnight UTC edge case).

### 9.4 BL-TEST-005: Proration Verification

| Scenario | Expected Proration (approximate) | Tolerance |
|---|---|---|
| Trader Monthly -> Pro Monthly at mid-cycle (day 15 of 30) | Credit: ~$24.50, Charge: ~$49.50, Net: ~$25.00 | +/- $0.01 |
| Pro Monthly -> Team Monthly at day 1 of 30 | Credit: ~$99.00, Charge: ~$199.00, Net: ~$100.00 | +/- $0.01 |
| Pro Monthly -> Team Monthly at day 29 of 30 | Credit: ~$3.30, Charge: ~$6.63, Net: ~$3.33 | +/- $0.01 |
| Monthly -> Annual switch at mid-cycle | Credit remaining monthly, charge full annual | Stripe calculates exact |

Tests verify that Stripe's proration preview (`Invoice.upcoming()`) matches expected values within the specified tolerance.

### 9.5 BL-TEST-006: Dunning Sequence Testing

| Step | Test Verification |
|---|---|
| First failure | Dunning email 1 sent, `payment_status = "past_due"`, `dunning_step = 1`, user retains full tier access. |
| Second failure (retry) | Dunning email 2 sent, `dunning_step = 2`, user retains full tier access. |
| 6 days after first failure | Dunning email 3 (grace ending) sent, `dunning_step = 3`. |
| 7 days after first failure | Access restricted to Free tier limits, dunning email 4 sent, `dunning_step = 4`. Verify user cannot access Pro/Team features. |
| Payment recovery at day 5 | Card updated, retry succeeds, full access restored within 10 seconds, `dunning_step = 0`, `payment_status = "current"`, recovery email sent. |
| Payment recovery at day 10 (after restriction) | Card updated, retry succeeds, full tier access restored, dunning reset. |
| All retries exhausted | Subscription cancelled by Stripe, tier reverts to `free`, cancellation email sent, data preserved for 90 days. |

### 9.6 BL-TEST-007: Idempotency Testing

| Test Case | Expected Result |
|---|---|
| Same event delivered twice within 1 second | Second delivery returns `200 OK`, exactly one processing occurs. No duplicate tier changes, no duplicate emails. |
| Same event delivered 10 times rapidly | All return `200 OK`, exactly one processing. `stripe_events` table has one record with `status = "processed"`. |
| Event processing fails on first attempt, delivered again | Second attempt processes successfully, final state is correct. |
| Two different events for same subscription delivered simultaneously | Both processed without conflict, final state reflects both changes in correct order. |

### 9.7 BL-TEST-008: Load Testing (Subscription-relevant subset)

| Scenario | Target | Pass Criteria |
|---|---|---|
| Webhook burst processing | 100 events/second sustained for 60 seconds | All events acknowledged within 5s, all processed within 30s, zero drops |
| Concurrent checkout sessions | 50 simultaneous session creations | All sessions created within 2s, no Stripe API errors |

---

## 10. Scheduled Jobs

| Job | Schedule | Purpose | Failure Behavior |
|---|---|---|---|
| Dunning check | Every hour | Send grace-ending and access-restricted emails for past-due subscriptions | Retry on next cycle. Critical alert if missed for > 3 hours. |
| Daily reconciliation | Daily at 03:00 UTC | Compare local subscription state with Stripe API | CRITICAL alert on any discrepancy. Auto-correct local state to match Stripe. |
| Stripe events cleanup | Weekly, Sunday 02:00 UTC | Delete processed events older than 90 days | Retry next week. Non-critical. |
| Pause expiration check | Daily at 00:30 UTC | Auto-resume paused subscriptions past their `pause_resumes_at` date | Retry on next cycle. Alert if subscriptions remain paused past expiry for > 24 hours. |
| Data retention enforcement | Daily at 04:00 UTC | Delete data for cancelled users past 120-day retention window | CRITICAL alert on failure. Manual intervention required. |

---

## 11. Deployment

### 11.1 Phase Mapping

- **Phase 1 & 2**: Billing NOT required. Implement `can_access(feature)` abstraction returning `True` for all features. Use dependency injection for billing integration drop-in.
- **Phase 3 (Weeks 15-22)**: Full implementation per this sub-FSD.

| Week | Deliverables |
|---|---|
| 15 | Stripe product/price setup (BL-FR-001). Create `subscriptions`, `stripe_events`, `cancellation_events` tables. |
| 15-16 | Checkout flow (BL-FR-002). Webhook receiver with signature verification and idempotency (BL-FR-016, BL-FR-017, BL-FR-018). Free tier enforcement (BL-FR-005). |
| 17-18 | Upgrade and downgrade flows (BL-FR-006, BL-FR-007). Proration handling (BL-FR-011). Customer Portal integration (BL-FR-003). |
| 18-19 | Cancellation flow with retention offers (BL-FR-008). Dunning management (BL-FR-020). Subscription pause (BL-FR-009). |
| 19-20 | Trial period support (BL-FR-023). Reactivation flow (BL-FR-010). |
| 21-22 | End-to-end testing (BL-TEST-001 through BL-TEST-008). Daily reconciliation jobs. Bug fixes. |

### 11.2 Database Migration Plan

**Migration order (Phase 3, Week 15):**

1. `001_create_subscriptions_table.sql` -- Create `subscriptions` table with all columns and indexes.
2. `002_create_stripe_events_table.sql` -- Create `stripe_events` table.
3. `007_create_cancellation_events_table.sql` -- Create `cancellation_events` table.
4. `009_seed_free_subscriptions.sql` -- For all existing users (from Phase 2), create subscription records with `tier="free"`, `status="active"`.

**Rollback plan:** Each migration has a corresponding down migration that drops the table. Since these are new tables (not modifications to existing tables), rollback is safe and non-destructive.

### 11.3 Stripe Setup Checklist

Before deploying the billing system to any environment:

1. Create Stripe account (or verify existing account).
2. Enable test mode for development/staging.
3. Create 4 products with `tier_level` metadata (via Dashboard or seed script).
4. Create 6 prices (via Dashboard or seed script).
5. Configure Customer Portal with allowed actions (subscription update, cancel, payment method update, invoice history).
6. Configure webhook endpoint URL pointing to `{BASE_URL}/api/webhooks/stripe`.
7. Subscribe to required webhook events (all events listed in BL-FR-016).
8. Retrieve and store webhook signing secret in `STRIPE_WEBHOOK_SECRET`.
9. Create system-generated coupons: `retention_25pct_3mo`, `annual_switch_10pct`, `referral_1mo_free`.
10. Configure Stripe Smart Retries: enable ML-optimized retries, max 4 attempts over 3 weeks, cancel on final failure.
11. Configure Stripe Tax (basic, default settings).
12. Store all environment variables (Section 6.3).
13. Verify end-to-end flow with test card `4242 4242 4242 4242`.

### 11.4 Health Check Endpoint

**Endpoint:** `GET /api/health/billing`

**Response (200 OK when healthy):**
```json
{
  "status": "healthy",
  "components": {
    "database": { "status": "ok", "latency_ms": 2 },
    "redis": { "status": "ok", "latency_ms": 1 },
    "stripe_api": { "status": "ok", "latency_ms": 150 }
  },
  "timestamp": "2026-03-15T10:30:00Z"
}
```

**Health check logic:**
- Database: execute `SELECT 1` and measure latency.
- Redis: execute `PING` and measure latency.
- Stripe: execute `stripe.Account.retrieve()` (lightweight API call) and measure latency.
- If any component fails: report `"degraded"` with 503 status.

---

## 12. Open Questions & Assumptions

### 12.1 Open Questions

| # | Question | Impact | Status |
|---|---|---|---|
| OQ-1 | Should the retention discount coupon (`retention_25pct_3mo`) be limited to once per user, or offered on subsequent cancellation attempts? | Affects revenue and churn metrics. Current assumption: once per user. | Open |
| OQ-4 | What is the exact behavior when a user in dunning (access restricted) attempts to upgrade? Should they resolve the failed payment first? | Edge case in upgrade flow. Current assumption: user must resolve payment before plan changes. | Open |
| OQ-6 | How should the system handle a Stripe webhook that references a `customer` ID not found in our database? | Data integrity. Current assumption: log WARNING and skip processing. | Open |

### 12.2 Assumptions

| # | Assumption | Rationale |
|---|---|---|
| A-1 | Stripe is the sole payment processor. No other payment methods (PayPal, crypto, bank transfer) at launch. | Per PRD scope. Simplifies implementation and PCI compliance. |
| A-2 | All prices are in USD. No multi-currency support at launch. | Per PRD scope. Reduces pricing complexity. |
| A-3 | One subscription per user. Users cannot have multiple active subscriptions simultaneously. | Simplifies data model and feature gating logic. |
| A-4 | Free tier users do not have a Stripe customer object until they initiate a paid action. | Reduces Stripe API calls and customer object clutter. |
| A-6 | Stripe Smart Retries handles payment retry timing. TrendEdge does not implement custom retry logic. | Stripe's ML-optimized retries are more effective than custom schedules. |
| A-7 | The daily reconciliation job corrects local state to match Stripe. Stripe is the source of truth for billing state. | Clear ownership model prevents conflicting states. |
| A-8 | Email delivery failures do not block subscription state changes. | Subscription state must be reliable regardless of email delivery. |
| A-9 | The `payment_method_last4` and `payment_method_brand` fields are for display only and may be slightly stale (up to 60 seconds). | Acceptable UX tradeoff for cache simplicity. |
| A-10 | Data deletion at 120 days post-cancellation is a hard delete from the database. | Per PRD privacy policy. |
