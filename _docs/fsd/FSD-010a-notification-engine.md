# FSD-010a: Notification Engine & Preferences

**TrendEdge — AI-Powered Futures Trading Platform**

| Field | Value |
|---|---|
| FSD ID | FSD-010a |
| Source | FSD-010 (Notifications & Integrations) |
| Title | Notification Engine & Preferences |
| Version | 1.0 |
| Status | Draft |
| Author | Generated by Claude |
| Created | 2026-02-12 |

---

## 1. Introduction

### 1.1 Purpose

This sub-FSD specifies the central notification dispatch engine and user preferences management for the TrendEdge platform. It covers event subscription, the 6-step channel routing pipeline, template rendering, delivery status tracking with state transitions, retry logic with backoff schedule, per-channel rate limiting, quiet hours / do-not-disturb, circuit breaker pattern, and the notification preferences UI (channel cards, per-event toggle matrix, quiet hours configuration).

A developer should be able to implement the complete notification engine and preferences system using only this document, with cross-references to sibling sub-FSDs for channel-specific delivery adapters and inbound integrations.

### 1.2 Scope

**In Scope:**

- Event subscription via Redis Pub/Sub and Celery workers (section 3.1)
- Event catalog: 15 domain event types with criticality levels (section 3.1)
- 6-step channel routing pipeline: event disable check, quiet hours check, tier resolution, preference resolution, channel connectivity check, dispatch (section 3.2)
- Template rendering engine with per-channel formatting and fallback behavior (section 3.3)
- Delivery status tracking with `notification_log` state machine (section 3.4)
- Retry logic with 6-attempt exponential backoff schedule and critical event fallback (section 3.5)
- Circuit breaker pattern: open/half-open/closed state transitions (section 3.5)
- Per-user per-channel rate limiting with Redis sliding windows and critical event bypass (section 3.6)
- Quiet hours / do-not-disturb with overnight range support and deferred notification batching (section 3.7)
- In-app notification center: WebSocket delivery, notification panel, badge count, read/unread management (section 3.8)
- Notification preferences UI: channel cards, per-event toggle matrix, quiet hours config, digest scheduling (section 3.9)
- Tier gating enforcement for notification channels (section 3.10)

**Out of Scope (see sibling sub-FSDs):**

- Telegram bot integration: linking, commands, manual trade entry (see FSD-010b)
- Discord webhook integration: embed formatting, daily/weekly summaries (see FSD-010b)
- Email integration: transactional emails, digest emails, SendGrid/Resend provider details (see FSD-010b)
- TradingView webhook receiver: inbound signal ingestion, validation, symbol mapping (see FSD-010c)
- Market data integration: yfinance, real-time broker data, caching, contract calendar (see FSD-010c)
- Custom webhook delivery (Team tier) (see FSD-010b)

### 1.3 Sibling Sub-FSDs

| Sub-FSD | Title | Relationship |
|---|---|---|
| FSD-010b | Channel Integrations | Consumes dispatch tasks from this engine; implements channel-specific adapters (Telegram, Discord, Email, Custom Webhook) |
| FSD-010c | Market Data & TradingView | Provides inbound signals that generate notification events; market data integration |

### 1.4 Architecture Context

| Layer | Technology | Role |
|---|---|---|
| Event Bus | Redis Pub/Sub | Domain event distribution |
| Task Queue | Celery (Redis broker) | Async dispatch, retry, scheduling |
| Scheduler | Celery Beat | Quiet hours flush, deferred queue check, retention cleanup |
| Backend API | FastAPI (Python 3.12+) | Preferences endpoints, notification history, in-app delivery |
| Database | PostgreSQL 16 (Supabase) | notification_log, notifications (in-app), preferences |
| Cache | Redis (Upstash) | Rate limit counters, circuit breaker state, deferred queues, idempotency tracking |
| Real-time | Supabase Realtime (PostgreSQL LISTEN/NOTIFY) | In-app WebSocket delivery |
| Frontend | Next.js 14+ (App Router) + TypeScript + Tailwind + shadcn/ui | Notification bell, panel, preferences UI |

### 1.5 Cross-References

| FSD | Events Consumed |
|---|---|
| FSD-002 | `trendline.alert`, `trendline.invalidated` |
| FSD-003 | `trade.fill`, `trade.rejected`, `trade.closed` |
| FSD-006 | `risk.limit_breach`, `risk.warning` |
| FSD-008 | User identity, tier resolution, JWT auth |
| FSD-009 | `subscription.changed` |
| Broker Adapters | `account.connection_lost`, `account.connection_restored` |

---

## 2. System Overview

### 2.1 Component Flow

```
Domain Events                   NOTIFICATION ENGINE                    Channel Adapters
(from other modules)                                                  (FSD-010b)
                        ┌─────────────────────────────────┐
trade.fill ─────────────►  1. Event Subscription           │
trade.closed ───────────►     (Redis Pub/Sub + Celery)     │
risk.limit_breach ──────►                                  │
trendline.alert ────────►  2. Channel Router               ├──► Telegram Adapter
account.connection_lost ►     (6-step pipeline)            │
subscription.changed ───►                                  ├──► Discord Adapter
digest.daily ───────────►  3. Template Renderer            │
                        │     (per-channel formatting)     ├──► Email Adapter
                        │                                  │
                        │  4. Rate Limiter                 ├──► In-App (WebSocket)
                        │     (Redis sliding window)       │
                        │                                  ├──► Custom Webhook
                        │  5. Celery Dispatch Workers      │
                        │     (retry, circuit breaker)     │
                        │                                  │
                        │  6. Notification Log             │
                        │     (PostgreSQL status tracking)  │
                        └─────────────────────────────────┘
```

---

## 3. Functional Specifications

### 3.1 Event Subscription

**Source:** NT-FR-001, NT-FR-002, NT-FR-003

**Description:** The notification engine subscribes to domain events via Redis Pub/Sub. When a domain event is published, a Celery worker picks it up from the `notifications` queue, validates the payload, resolves the user, and passes to the channel routing pipeline.

**Event Catalog:**

| Event | Source Module | Criticality | Behavior on Receipt |
|---|---|---|---|
| `trade.fill` | Execution engine | Critical | Render fill template, dispatch to all enabled channels. At-least-once delivery required. |
| `trade.rejected` | Execution engine | Critical | Render rejection template with reason. Dispatch immediately. |
| `trade.closed` | Execution engine | Critical | Render close template with P&L. Dispatch immediately. |
| `risk.limit_breach` | Risk engine | Critical | Render breach template. Dispatch immediately. Bypass rate limits and quiet hours (unless user opted out). |
| `risk.warning` | Risk engine | High | Render warning template showing current vs. limit. |
| `trendline.alert` | Trendline engine | High | Render alert template with grade, touch count, slope. |
| `trendline.invalidated` | Trendline engine | Medium | Render invalidation template. |
| `webhook.received` | Webhook receiver | Medium | Render confirmation with mapped symbol. |
| `webhook.error` | Webhook receiver | High | Render error template with failure reason. |
| `account.connection_lost` | Broker adapter | Critical | Render connection lost template. Bypass rate limits and quiet hours. |
| `account.connection_restored` | Broker adapter | High | Render restoration template with downtime duration. |
| `digest.daily` | Celery Beat scheduler | Low | Trigger daily digest generation pipeline. |
| `digest.weekly` | Celery Beat scheduler | Low | Trigger weekly digest generation pipeline. |
| `system.maintenance` | Admin | Medium | Render maintenance window template. |
| `subscription.changed` | Billing | Medium | Update channel availability; render tier change template. |
| `paper.milestone` | Analytics engine | Low | Render milestone template. |

**Critical Events** are those requiring at-least-once delivery with fallback: `trade.fill`, `trade.rejected`, `trade.closed`, `risk.limit_breach`, `account.connection_lost`.

**Event Payload Schema (required fields):**

| Field | Type | Constraints | Description |
|---|---|---|---|
| `event_type` | string | Must match a value from the event catalog | Identifies the event |
| `user_id` | UUID | Must reference an existing user | Target user |
| `timestamp` | string | ISO 8601 UTC (e.g., `2026-02-11T19:32:05Z`) | When the event occurred |
| `payload` | object | Event-specific | Event data |
| `correlation_id` | UUID | Unique per event chain | For distributed tracing |

**Processing Logic:**

1. Celery worker dequeues event from `notifications` queue.
2. **Idempotency check:** Check Redis set `processed_events` (TTL: 1 hour) for `correlation_id`. If found, skip processing (duplicate). If not found, add to set.
3. Validate event payload schema. If invalid, log error with `correlation_id` and discard. Do NOT retry malformed events.
4. Look up user by `user_id`. If user not found, log warning and discard.
5. Proceed to channel routing (section 3.2).

**Error Handling:**

| Condition | Behavior |
|---|---|
| Redis Pub/Sub connection lost | Celery worker reconnects with exponential backoff (1s, 2s, 4s, 8s, max 30s). Events published during disconnection are lost by Pub/Sub; mitigated by event outbox pattern (producing modules write events to PostgreSQL `event_outbox` table). |
| Celery worker crash | Celery uses `acks_late=True`: unacknowledged tasks are re-delivered to another worker. |
| Unknown `event_type` | Log warning `"Unknown event type: {event_type}, correlation_id: {correlation_id}"`, discard. Do NOT raise an exception. |
| Duplicate event (same `correlation_id`) | Skip processing silently. |
| User account deleted between emission and processing | Discard silently; log at debug level. |
| Event payload missing optional fields | Templates handle gracefully using dash (`---`) as placeholder. |

**Event Bus Details:**

- Redis Pub/Sub channel pattern: `events:{event_type}` (e.g., `events:trade.fill`)
- Message format: JSON-serialized event payload
- All subscribers receive all messages on a channel.

---

### 3.2 Channel Routing (6-Step Pipeline)

**Source:** NT-FR-004, NT-FR-005, NT-FR-006, NT-FR-007

**Description:** After receiving and validating an event, the engine determines which channels to dispatch to based on the user's preferences, subscription tier, quiet hours status, and channel connectivity.

**Processing Logic (executed in strict order):**

```
Step 1: EVENT DISABLED CHECK
  IF user has explicitly disabled this event_type entirely
  THEN log "Event {event_type} disabled by user {user_id}", STOP.

Step 2: QUIET HOURS CHECK
  IF quiet hours are active for this user (see section 3.7)
  AND event criticality is NOT "Critical"
  THEN set notification status = "deferred", store in deferred queue, STOP.

  IF quiet hours are active
  AND event criticality IS "Critical"
  AND user has bypass_critical = true (default)
  THEN proceed to Step 3.

  IF quiet hours are active
  AND event criticality IS "Critical"
  AND user has bypass_critical = false
  THEN set notification status = "deferred", store in deferred queue, STOP.

Step 3: TIER RESOLUTION
  Resolve user's current subscription tier from the users table.
  Determine available channels for this tier:
    - Free:   [email, in_app]
    - Trader: [email, in_app, telegram]
    - Pro:    [email, in_app, telegram, discord]
    - Team:   [email, in_app, telegram, discord, custom_webhook]

Step 4: PREFERENCE RESOLUTION
  For each available channel:
    IF user has explicitly set a preference for this (event_type, channel) pair
    THEN use that preference (enabled/disabled).
    ELSE use the default preference from the defaults table (section 3.9.5).

Step 5: CHANNEL CONNECTIVITY CHECK
  For each enabled channel:
    - telegram: verify user has a linked telegram_chat_id
    - discord: verify user has at least one configured webhook_url
    - email: verify user has a verified email address
    - in_app: always available
    - custom_webhook: verify user has at least one configured webhook URL
  Skip channels that are not connected/configured.

Step 6: DISPATCH
  For each resolved channel:
    Create a notification_log entry with status = "queued".
    Render the channel-specific template (section 3.3).
    Enqueue a channel-specific Celery dispatch task.
```

**Tier Change Handling:**

*Downgrade:*
1. Determine which channels are no longer available on the new tier.
2. For each newly unavailable channel, set all preferences for that channel to `disabled`.
3. Send a single email: Subject `"Your TrendEdge notification channels have been updated"`, body listing disabled channels with upgrade URL.
4. Log preference changes in audit log.

*Upgrade:*
1. Determine which channels are newly available.
2. Apply default preferences for those channels (do NOT auto-enable; let user configure).
3. Send notification via email and in-app: `"New notification channels available! Your {new_tier} plan includes {channel_list}. Configure them in Settings > Notifications."`

**Error Handling:**

| Condition | Behavior |
|---|---|
| Tier lookup fails (database error) | Log error, retry entire event via Celery retry. Do NOT partially dispatch. |
| Preference lookup fails | Fall back to default preferences for the user's tier. |
| Event has no template for a channel | Skip that channel, log warning `"No template for event {event_type} on channel {channel}"`. |

**Edge Cases:**

| Scenario | Behavior |
|---|---|
| New user with no preferences | Use complete default preference set (section 3.9.5). |
| Subscription in grace period (expired but not yet downgraded) | Treat as previous tier until billing module emits `subscription.changed`. |

---

### 3.3 Template Rendering

**Source:** NT-FR-008 through NT-FR-012

**Description:** Each event type has a dedicated template per channel. Templates are rendered with event payload data before dispatch.

**Template Storage:**

| Channel | Format | Location |
|---|---|---|
| Email HTML | Jinja2 | `templates/notifications/email/` |
| Telegram | Python format strings | `templates/notifications/telegram/` |
| Discord | Python format strings producing JSON embeds | `templates/notifications/discord/` |
| In-App | Jinja2 (Markdown output) | `templates/notifications/in_app/` |

**Template Variable Categories:**

| Category | Variables | Formatting Rules |
|---|---|---|
| Trade | `symbol`, `direction`, `quantity`, `entry_price`, `exit_price`, `stop_loss`, `take_profit`, `pnl_dollars`, `pnl_ticks`, `r_multiple`, `slippage_ticks` | Monetary: `$X,XXX.XX` with comma separators and 2 decimal places. Ticks: instrument tick-size precision. R-multiple: 2 decimal places with sign. |
| Trendline | `instrument`, `touch_count`, `slope_degrees`, `duration_days`, `grade`, `alert_type` | Grade: letter grade (e.g., `A+`). Slope: 1 decimal. Duration: integer days. |
| Account | `daily_pnl`, `weekly_pnl`, `open_positions_count`, `unrealized_pnl`, `daily_loss_remaining` | All monetary values with sign prefix (`+$425.00` or `-$125.00`). |
| Risk | `limit_type`, `current_value`, `limit_value`, `percent_used` | Percent: integer with `%` suffix. Values: monetary format. |
| Meta | `timestamp_utc`, `timestamp_user_tz`, `platform_url`, `trade_id`, `signal_source` | Timestamps: `YYYY-MM-DD HH:MM:SS TZ` (e.g., `2026-02-11 14:32:05 ET`). |

**Signal Source Display Mapping:**

| `signal_source` Value | Display Text |
|---|---|
| `tradingview_webhook` | `TradingView Webhook` |
| `trendline_engine` | `Trendline Engine` |
| `manual_telegram` | `Manual (Telegram)` |
| `manual_dashboard` | `Manual (Dashboard)` |
| (unknown/null) | `Unknown Source` |

**Fallback Behavior:**

- Every template MUST have a plain-text fallback version.
- If a template variable is missing from the event payload, the template SHALL use a dash (`---`) as placeholder rather than raising an error.
- If a template file is not found, log error `"Template not found: {event_type}/{channel}"` and skip that channel dispatch. Do NOT crash the worker.

---

### 3.4 Delivery Status Tracking

**Source:** NT-FR-013, NT-FR-014, NT-FR-015

**`notification_log` Table Schema:**

| Field | Type | Constraints | Default | Description |
|---|---|---|---|---|
| `id` | UUID | PK | `gen_random_uuid()` | Primary key |
| `user_id` | UUID | FK -> users.id, NOT NULL, INDEX | -- | Target user |
| `event_type` | VARCHAR(50) | NOT NULL, INDEX | -- | Event that triggered this notification |
| `channel` | VARCHAR(20) | NOT NULL, CHECK IN ('telegram','discord','email','in_app','custom_webhook') | -- | Delivery channel |
| `status` | VARCHAR(20) | NOT NULL, CHECK IN ('queued','dispatched','delivered','failed','deferred'), INDEX | `'queued'` | Current delivery status |
| `payload` | JSONB | NOT NULL | -- | Rendered notification content |
| `attempt_count` | INTEGER | NOT NULL | `0` | Number of delivery attempts |
| `max_attempts` | INTEGER | NOT NULL | `6` | Maximum attempts (1 initial + 5 retries) |
| `last_error` | TEXT | NULLABLE | `NULL` | Error message from most recent failed attempt |
| `created_at` | TIMESTAMPTZ | NOT NULL, INDEX | `NOW()` | When the notification was created |
| `dispatched_at` | TIMESTAMPTZ | NULLABLE | `NULL` | When sent to the channel adapter |
| `delivered_at` | TIMESTAMPTZ | NULLABLE | `NULL` | When delivery was confirmed |
| `correlation_id` | UUID | NOT NULL, INDEX | -- | Links to originating event |

**State Machine:**

```
                          ┌─────────┐
    Event received  ────► │ queued  │ ◄─── Retry scheduled (attempts remain)
    Prefs resolved        └────┬────┘
                               │
                    Worker picks up task
                               │
                          ┌────▼──────┐
                          │dispatched │
                          └────┬──────┘
                               │
                    ┌──────────┼──────────┐
                    │          │          │
              API success   API error   All retries
                    │          │        exhausted
              ┌─────▼────┐    │          │
              │delivered │    │    ┌─────▼───┐
              └──────────┘    │    │ failed  │
                              │    └─────────┘
                              │
                         Back to queued
                        (retry scheduled)


    Quiet hours active ──► ┌──────────┐ ──► Quiet hours end ──► queued
                           │ deferred │
                           └──────────┘
```

**State Transitions:**

| From State | Event | To State | Action |
|---|---|---|---|
| -- | Event received, preferences resolved | `queued` | Create log entry |
| `queued` | Worker picks up dispatch task | `dispatched` | Set `dispatched_at`, increment `attempt_count` |
| `dispatched` | Channel API returns success (2xx) | `delivered` | Set `delivered_at` |
| `dispatched` | Channel API returns error | `queued` | Set `last_error`, schedule retry (if attempts remain) |
| `dispatched` | All retry attempts exhausted | `failed` | Set `last_error`, trigger fallback for Critical events |
| -- | Quiet hours active for this notification | `deferred` | Store in deferred queue |
| `deferred` | Quiet hours end | `queued` | Re-enqueue for dispatch |

**Retention Policy:**

| Category | Retention |
|---|---|
| Standard notifications | 90 days, then archived to S3/R2 cold storage |
| Critical event notifications (`trade.fill`, `trade.rejected`, `trade.closed`, `risk.limit_breach`, `account.connection_lost`) | 1 year |
| Archival schedule | Daily Celery Beat task at 03:00 UTC |
| Archive process | Records removed from PostgreSQL after confirmed S3/R2 upload |

---

### 3.5 Retry Logic & Circuit Breaker

**Source:** NT-FR-016 through NT-FR-019

#### 3.5.1 Retry Schedule

| Attempt | Type | Delay After Failure | Cumulative Elapsed |
|---|---|---|---|
| 1 | Initial attempt | -- | 0s |
| 2 | 1st retry | 10 seconds | 10s |
| 3 | 2nd retry | 30 seconds | 40s |
| 4 | 3rd retry | 2 minutes | 2m 40s |
| 5 | 4th retry | 10 minutes | 12m 40s |
| 6 | 5th retry (final) | 30 minutes | 42m 40s |

**Implementation:** Celery task with `max_retries=5`, `acks_late=True`. Countdown values: `[10, 30, 120, 600, 1800]`.

#### 3.5.2 After All Retries Exhausted

**For Critical events** (`trade.fill`, `trade.rejected`, `trade.closed`, `risk.limit_breach`, `account.connection_lost`):

1. Mark notification as `failed` in `notification_log`.
2. Attempt fallback delivery through the next available channel in priority order: **Telegram > In-App > Email**.
3. Fallback notification includes prefix: `"[DELAYED] "` before the normal message content.
4. If all fallback channels also fail, log a critical alert to Sentry: `"CRITICAL: All delivery channels failed for user {user_id}, event {event_type}, correlation_id {correlation_id}"`.

**For non-Critical events:**

1. Mark as `failed` in `notification_log`.
2. No fallback delivery.
3. Log at warning level.

#### 3.5.3 Circuit Breaker

| Parameter | Value |
|---|---|
| Failure threshold | 5 consecutive failures across any user within a 5-minute window per channel |
| Open duration | 2 minutes (all dispatches to that channel are paused) |
| Half-open behavior | After 2 minutes, allow 1 test dispatch. If it succeeds, close the breaker. If it fails, re-open for another 2 minutes. |
| State tracking | Redis key: `circuit_breaker:{channel}` with values `closed`, `open`, `half_open` |
| Monitoring | Every state change emits a metric and triggers an alert |

**Circuit Breaker State Machine:**

```
  ┌────────┐   5 failures    ┌──────┐   2 min elapsed   ┌───────────┐
  │ closed │ ──── in 5 min ──► open │ ────────────────── ► half_open │
  └────┬───┘                  └──────┘                    └─────┬─────┘
       │                         ▲                              │
       │                         │                    ┌─────────┼─────────┐
       │                    test fails                │         │         │
       │                         │              test succeeds  test fails │
       │                    ┌────┴────┐              │                   │
       │                    │re-open  │              │                   │
       │                    └─────────┘              │                   │
       │                                             │                   │
       ◄─────────────────────────────────────────────┘                   │
       (resume all dispatches)                    re-open for 2 min ────┘
```

| From | Condition | To | Action |
|---|---|---|---|
| `closed` | 5 failures in 5 min | `open` | Pause all dispatches for channel, log alert, start 2-min timer |
| `open` | 2 minutes elapsed | `half_open` | Allow 1 test dispatch |
| `half_open` | Test dispatch succeeds | `closed` | Resume all dispatches, log recovery |
| `half_open` | Test dispatch fails | `open` | Re-pause, restart 2-min timer |

**Edge Cases:**

| Scenario | Behavior |
|---|---|
| Worker crashes mid-retry | Celery `acks_late=True` ensures task re-delivery. |
| Channel returns ambiguous response (HTTP 200 but body indicates error) | Each channel adapter must parse response body to determine true success/failure. |
| Retry fires during circuit breaker open state | Task re-queued with delay equal to remaining breaker open duration. |

---

### 3.6 Rate Limiting

**Source:** NT-FR-020, NT-FR-021, NT-FR-022

**Per-User Per-Channel Rate Limits:**

| Channel | Hourly Limit | Burst Limit (per minute) | Critical Event Bypass |
|---|---|---|---|
| Telegram | 20 messages | 5 | Yes |
| Discord | 10 messages | 3 | N/A (no critical events go to Discord by default) |
| Email | 5 emails | 2 | Yes |
| In-App | 60 notifications | No burst limit | N/A |
| Custom Webhook | 30 requests | 5 | Yes |

**Implementation:**

- Redis sliding window counters.
- Key format: `ratelimit:{user_id}:{channel}:hourly` (TTL: 3600s) and `ratelimit:{user_id}:{channel}:burst` (TTL: 60s).
- Before each dispatch, check both hourly and burst counters. If either is exceeded, the notification is rate-limited.

**Rate-Limited Notification Behavior:**

- **Non-Critical:** Queued into Redis list `ratelimit_queue:{user_id}:{channel}`. When the rate limit window resets (detected via Celery Beat task running every minute), all queued notifications are batched into a single summary message.
- **Summary message format (Telegram example):** `"You have {count} notifications that were batched due to rate limiting:\n- {notification_1_title}\n- {notification_2_title}\n..."`
- If batch contains more than 10 notifications, show first 10 and append: `"...and {remaining_count} more. View all in your dashboard."`
- **Critical events** (`trade.fill`, `risk.limit_breach`, `account.connection_lost`): Bypass rate limits entirely. Always dispatched immediately.

**Edge Cases:**

| Scenario | Behavior |
|---|---|
| Redis unavailable | Fail open (allow dispatch) and log warning. Do NOT block notifications because rate limiting is down. |
| Rate limit counter overflow | Cap counter at 10,000; values above indicate a bug. |

---

### 3.7 Quiet Hours / Do Not Disturb

**Source:** NT-FR-023, NT-FR-024, NT-FR-025, NT-FR-026

**Configuration Schema:**

| Field | Type | Constraints | Default |
|---|---|---|---|
| `enabled` | boolean | -- | `false` |
| `start_time` | string | HH:MM format (00:00 to 23:59) | `"22:00"` |
| `end_time` | string | HH:MM format (00:00 to 23:59) | `"07:00"` |
| `timezone` | string | Valid IANA timezone (e.g., `America/New_York`) | User's account timezone |
| `days_of_week` | array of integers | Each: 0-6 (0=Sunday, 6=Saturday) | `[0,1,2,3,4,5,6]` |
| `bypass_critical` | boolean | -- | `true` |

**Evaluation Logic (executed at Step 2 of channel routing):**

```
1. IF quiet_hours.enabled is false -> NOT in quiet hours, proceed.
2. Convert current UTC time to user's quiet_hours.timezone.
3. Get current day_of_week (0=Sunday).
4. IF current day_of_week NOT IN quiet_hours.days_of_week -> NOT in quiet hours, proceed.
5. IF start_time < end_time (same-day range, e.g., 22:00-23:00):
     IF current_time >= start_time AND current_time < end_time -> IN quiet hours.
   IF start_time > end_time (overnight range, e.g., 22:00-07:00):
     IF current_time >= start_time OR current_time < end_time -> IN quiet hours.
   IF start_time == end_time -> NOT in quiet hours (invalid config, treat as disabled).
6. IF in quiet hours AND event is Critical AND bypass_critical is true -> proceed (NOT deferred).
7. IF in quiet hours -> DEFER notification.
```

**Deferred Notification Handling:**

- Deferred notifications stored in Redis list `deferred:{user_id}` with full notification payload and original timestamp.
- Celery Beat task runs **every minute** checking if any user's quiet hours have ended.
- When quiet hours end for a user:
  1. Retrieve all deferred notifications from the Redis list.
  2. Batch them into a single summary message per channel.
  3. Summary format: `"While you were away ({count} notifications):\n\n{timestamp_1}: {title_1}\n{timestamp_2}: {title_2}\n..."`
  4. Dispatch the summary through the normal channel pipeline (subject to rate limiting).
  5. Clear the deferred queue.

**Edge Cases:**

| Scenario | Behavior |
|---|---|
| User changes timezone while quiet hours are active | Apply new timezone immediately on the next evaluation cycle (within 1 minute). |
| User disables quiet hours while notifications are deferred | Immediately flush all deferred notifications as a batch summary. |
| Quiet hours span midnight and cross a day boundary (one day enabled, next not) | Evaluate based on the day when quiet hours *started*, not the current day. |
| No deferred notifications when quiet hours end | Do not send empty summary. |
| Deferred queue exceeds 100 items per user | Oldest deferred notifications are dropped with a log warning. |

---

### 3.8 In-App Notification Center

**Source:** NT-FR-077 through NT-FR-085

#### 3.8.1 Real-Time Delivery

**WebSocket Channel:** `notifications:{user_id}` via Supabase Realtime (PostgreSQL LISTEN/NOTIFY).

**Subscription Lifecycle:**

1. On dashboard mount, frontend subscribes to `notifications:{user_id}`.
2. RLS policies ensure users only receive their own notifications.
3. On dashboard unmount (page close/navigate away), subscription is cleaned up.

**New Notification Arrival Behavior:**

1. Notification bell badge count increments by 1.
2. Toast notification appears in bottom-right corner:
   - Icon: event-type-specific icon
   - Title: notification title (max 50 chars, truncated with `...`)
   - Body: first line of message (max 100 chars, truncated with `...`)
   - Auto-dismiss: 5 seconds
   - Click: navigates to relevant detail page (if deep link available) or opens notification panel.
3. If notification panel is open: new notification prepends to the list with a 1-second highlight animation (subtle background color pulse).

**WebSocket Disconnection Recovery:**

1. Display a subtle indicator near the notification bell: small orange dot with tooltip `"Reconnecting..."`.
2. Reconnect with exponential backoff: 1s, 2s, 4s, 8s, 16s, max 30s.
3. On successful reconnection: remove indicator, fetch missed notifications via `GET /api/notifications?since={last_received_timestamp}`.
4. If reconnection fails after 5 minutes: show persistent banner: `"Live notifications unavailable. Refresh the page to reconnect."` with a "Refresh" button.

#### 3.8.2 Notifications Table

| Field | Type | Constraints | Default | Description |
|---|---|---|---|---|
| `id` | UUID | PK | `gen_random_uuid()` | Primary key |
| `user_id` | UUID | FK, NOT NULL, INDEX | -- | Target user |
| `event_type` | VARCHAR(50) | NOT NULL, INDEX | -- | Event type |
| `title` | VARCHAR(200) | NOT NULL | -- | Notification title |
| `body` | TEXT | NOT NULL | -- | Body (Markdown) |
| `data` | JSONB | NULLABLE | `NULL` | Deep link data |
| `read` | BOOLEAN | NOT NULL, INDEX | `false` | Read status |
| `created_at` | TIMESTAMPTZ | NOT NULL, INDEX | `NOW()` | Creation timestamp |
| `expires_at` | TIMESTAMPTZ | NULLABLE | `NULL` | Expiration (null = default retention) |

**RLS:** `auth.uid() = user_id`

**Deep Linking:**

| `data` Field | Navigation Target |
|---|---|
| `data.trade_id` | `/trades/{trade_id}` |
| `data.trendline_id` | `/trendlines/{trendline_id}` |
| No deep link data | Opens notification panel / marks as read |

**Badge Count:**

- Fetched on page load: `GET /api/notifications/unread-count` returns `{"count": N}`.
- Updated in real time via WebSocket.
- Max display: `99+` (if count > 99).
- Badge hidden when count is 0.

**Retention:**

| Category | Retention | Cleanup |
|---|---|---|
| Standard notifications | 30 days | Daily Celery Beat task at 05:00 UTC |
| Critical notifications (`trade.fill`, `risk.limit_breach`) | 90 days | Same task |

#### 3.8.3 Notification Panel UI

| Feature | Behavior |
|---|---|
| Pagination | Infinite scroll, 20 per page. Load more on scroll to bottom. |
| Filter | Dropdown: All, Trades, Trendlines, Risk, System. Default: All. |
| Mark all as read | Button in panel header. Sets `read = true` for all user's unread notifications. Badge resets to 0. |
| Mark individual as read | Click on notification marks it as read. Visual: bold text becomes normal weight. |
| Swipe to dismiss (mobile) | Marks as read, does NOT delete. Slide animation. |
| Clear all read | Button (secondary style). Hides all `read = true` notifications from panel view. Actual deletion via retention policy. |
| Empty state | `"No notifications yet. Your trade alerts, trendline signals, and system updates will appear here."` |

**Notification Bell Interaction Flow:**

1. Initial page load: Fetch `GET /api/notifications/unread-count`. Display badge if count > 0.
2. Click bell: Open notification panel. Fetch `GET /api/notifications?limit=20`.
3. Loading state: Show skeleton loaders (3 placeholder rows).
4. Loaded: Show notifications list.
5. Scroll to bottom: Fetch next page. Show spinner at bottom.
6. No more: Subtle text `"You've seen all your notifications."`
7. Click notification: Mark as read via API, navigate to deep link if available.
8. Click "Mark all as read": Batch update via API, reset badge to 0.
9. Click outside panel: Close panel.

---

### 3.9 Notification Preferences UI

**Source:** NT-FR-100 through NT-FR-108

#### 3.9.1 Channel Configuration Cards

**Location:** Settings > Notifications (top section)

| Channel | Status States | Configuration | Tier Requirement |
|---|---|---|---|
| Email | Always available, shows verified status | Email address (read-only, from account) | All tiers |
| In-App | Always available | No configuration | All tiers |
| Telegram | Not Connected / Connected (username) | Link/Unlink button | Trader+ |
| Discord | Not Configured / Configured (channel name) | Webhook URL input, test button | Pro+ |
| Custom Webhook | Not Configured / Configured | URL + auth header, test button | Team only |

**Tier Gating UI:**

- If channel is unavailable on user's tier: Card is visually dimmed with a lock icon.
- Overlay text: `"Upgrade to {required_tier} to enable {channel_name} notifications"`
- "Upgrade" button links to billing page.

#### 3.9.2 Per-Event Toggle Matrix

**Matrix Table:**

| Event | Email | In-App | Telegram | Discord |
|---|---|---|---|---|
| Trade Fill (Entry) | toggle | toggle | toggle | toggle |
| Trade Fill (Exit) | toggle | toggle | toggle | toggle |
| Trade Closed (P&L) | toggle | toggle | toggle | toggle |
| Trendline Alert | toggle | toggle | toggle | toggle |
| Trendline Invalidated | toggle | toggle | toggle | toggle |
| Risk Warning | toggle | toggle | toggle | toggle |
| Risk Breach | ON (locked) | ON (locked) | toggle | toggle |
| Daily P&L Digest | toggle | -- | toggle | toggle |
| Weekly Digest | toggle | -- | -- | toggle |
| Webhook Errors | toggle | toggle | toggle | -- |
| Connection Lost | ON (locked) | ON (locked) | toggle | -- |
| System Maintenance | toggle | toggle | -- | -- |

**Locked Toggles:** Risk Breach and Connection Lost have Email and In-App locked to ON. These cannot be disabled. Visual: toggle is ON with a lock icon; clicking shows tooltip: `"This notification cannot be disabled for safety reasons."`

**Unavailable Channel Columns:** Grayed out with lock icon. Hovering shows: `"Available on {tier_name} plan."` Toggles are non-interactive.

**Cell with `--`:** Not applicable for this event/channel combination. No toggle shown.

#### 3.9.3 Quiet Hours Configuration UI

**UI Elements:**

- Enable/disable toggle (label: "Quiet Hours")
- Start time picker (HH:MM, 15-minute increments)
- End time picker (HH:MM, 15-minute increments)
- Timezone selector (IANA timezone database, default: user's account timezone)
- Day-of-week checkboxes (default: all checked)
- Checkbox: "Allow critical alerts during quiet hours" (default: checked)

**Validation:**

- Start time and end time must not be equal. If set equal, show: `"Start and end time cannot be the same."`

#### 3.9.4 Digest Schedule Configuration

**UI Elements:**

- Daily digest: enable/disable toggle, time picker (default: 18:00 user timezone), checkbox "Skip if no trades" (default: unchecked)
- Weekly digest: enable/disable toggle, day selector (default: Sunday), time picker (default: 09:00 user timezone)

#### 3.9.5 Default Preferences for New Users

| Event | Email | In-App | Telegram | Discord |
|---|---|---|---|---|
| Trade fills | ON | ON | ON | OFF |
| Trade closed | ON | ON | ON | ON |
| Trendline alerts | OFF | ON | ON | OFF |
| Risk warnings | ON | ON | ON | OFF |
| Risk breaches | ON (locked) | ON (locked) | ON | ON |
| Daily digest | ON | -- | ON | OFF |
| Weekly digest | ON | -- | OFF | OFF |
| Webhook errors | ON | ON | OFF | -- |
| Connection lost | ON (locked) | ON (locked) | ON | -- |

**Persistence:** Preferences stored in `notification_preferences` JSONB column on the users table. Changes saved immediately on toggle (optimistic UI with rollback on error).

**Optimistic UI Behavior:**

1. User clicks a toggle.
2. UI immediately reflects the new state.
3. API call `PATCH /api/notifications/preferences` fires in background.
4. If API succeeds: no further action.
5. If API fails: revert toggle to previous state, show toast: `"Failed to save preference. Please try again."`

---

### 3.10 Tier Gating for Notification Channels

**Channel Availability by Tier:**

| Channel | Free | Trader ($49/mo) | Pro ($99/mo) | Team ($199/mo) |
|---|---|---|---|---|
| Email | Yes | Yes | Yes | Yes |
| In-App | Yes | Yes | Yes | Yes |
| Telegram | No | Yes | Yes | Yes |
| Discord | No | No | Yes | Yes |
| Custom Webhook | No | No | No | Yes |

**Frontend Enforcement:**

- Unavailable channel cards are visually dimmed with lock icon and upgrade CTA.
- Toggle matrix columns for unavailable channels are grayed out and non-interactive.

**Backend Enforcement:**

- Preferences API rejects attempts to enable channels above the user's tier:
  - HTTP 403: `{"error": "tier_restricted", "message": "Discord notifications require Pro plan or higher."}`
- Channel routing (Step 3) automatically excludes channels unavailable on the user's tier.

**Authorization Matrix:**

| Role | Action | Resource | Allowed |
|---|---|---|---|
| Free user | Read/write | Own preferences (email + in-app only) | Yes |
| Free user | Configure | Telegram/Discord/Custom Webhook | No |
| Trader user | Configure | Telegram | Yes |
| Trader user | Configure | Discord/Custom Webhook | No |
| Pro user | Configure | Telegram, Discord | Yes |
| Pro user | Configure | Custom Webhook | No |
| Team user | Configure | All channels | Yes |
| Any user | Disable | Risk breach email/in-app | No (locked) |
| Any user | Read | Own notification log | Yes |
| Any user | Read | Other users' notifications | No (RLS enforced) |
| Admin | Read | Any notification log | Yes |
| Admin | Write | System maintenance notifications | Yes |

---

## 4. Data Specifications

### 4.1 Entity Relationship Summary

```
users
  |-- notification_preferences (1:1, JSONB column on users table)
  |-- user_integrations (1:many, one per channel) [schema in FSD-010b]
  |-- notification_log (1:many)
  +-- notifications (1:many, in-app)
```

### 4.2 `notification_log` Table

See Section 3.4 for full schema.

**Indexes:**

```sql
CREATE INDEX idx_notification_log_user_id ON notification_log(user_id);
CREATE INDEX idx_notification_log_event_type ON notification_log(event_type);
CREATE INDEX idx_notification_log_status ON notification_log(status);
CREATE INDEX idx_notification_log_created_at ON notification_log(created_at);
CREATE INDEX idx_notification_log_correlation_id ON notification_log(correlation_id);
```

**RLS:**

```sql
ALTER TABLE notification_log ENABLE ROW LEVEL SECURITY;
CREATE POLICY notification_log_user_isolation ON notification_log
  FOR SELECT USING (auth.uid() = user_id);
```

### 4.3 `notifications` Table (In-App)

See Section 3.8.2 for full schema.

**Indexes:**

```sql
CREATE INDEX idx_notifications_user_id ON notifications(user_id);
CREATE INDEX idx_notifications_user_read ON notifications(user_id, read);
CREATE INDEX idx_notifications_user_created ON notifications(user_id, created_at DESC);
CREATE INDEX idx_notifications_event_type ON notifications(event_type);
```

**RLS:**

```sql
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;
CREATE POLICY notifications_user_isolation ON notifications
  FOR ALL USING (auth.uid() = user_id);
```

### 4.4 Redis Key Schema

| Key Pattern | Value | TTL | Purpose |
|---|---|---|---|
| `processed_events` | SET of correlation_ids | 1 hour per entry | Idempotency check |
| `circuit_breaker:{channel}` | `closed` / `open` / `half_open` | None (managed by app) | Circuit breaker state |
| `ratelimit:{user_id}:{channel}:hourly` | Integer counter | 3600s | Hourly rate limit |
| `ratelimit:{user_id}:{channel}:burst` | Integer counter | 60s | Burst rate limit |
| `ratelimit_queue:{user_id}:{channel}` | LIST of notification payloads | None (flushed on reset) | Rate-limited notification batch queue |
| `deferred:{user_id}` | LIST of notification payloads | None (flushed on quiet hours end) | Deferred notifications during quiet hours |

### 4.5 Data Validation Rules

| Field | Rule | Error Message |
|---|---|---|
| Quiet hours start_time | Must be HH:MM format, 00:00-23:59 | `"Invalid time format. Use HH:MM (e.g., 22:00)."` |
| Quiet hours end_time | Must be HH:MM format, 00:00-23:59 | `"Invalid time format. Use HH:MM (e.g., 07:00)."` |
| Quiet hours timezone | Must be valid IANA timezone | `"Invalid timezone. Please select from the list."` |
| Quiet hours days_of_week | Each value 0-6, no duplicates | `"Invalid day selection."` |
| Notification preferences | Valid event_type and channel combinations only | `"Invalid preference combination."` |

---

## 5. API Specifications

All endpoints require JWT authentication via `Authorization: Bearer {token}` header unless otherwise noted.

### 5.1 Notification Endpoints

**GET /api/notifications/unread-count**

- Auth: Bearer token (all tiers)
- Response 200: `{"count": 5}`
- Response 401: `{"error": "unauthorized", "message": "Authentication required"}`

**GET /api/notifications?since={timestamp}&event_type={type}&limit={n}**

- Auth: Bearer token
- Params: `since` (ISO 8601, optional), `event_type` (optional), `limit` (default 20, max 100)
- Response 200: `{"notifications": [...], "has_more": true}`
- Response 401: `{"error": "unauthorized"}`

**PATCH /api/notifications/{id}/read**

- Auth: Bearer token
- Response 200: `{"success": true}`
- Response 404: `{"error": "not_found", "message": "Notification not found"}`

**POST /api/notifications/mark-all-read**

- Auth: Bearer token
- Response 200: `{"updated_count": 12}`

**GET /api/notifications/history?event_type={type}&channel={ch}&status={s}&date_from={d}&date_to={d}&page={n}**

- Auth: Bearer token
- Description: User-facing notification delivery history from `notification_log`.
- Response 200: `{"entries": [...], "total": 150, "page": 1, "pages": 8}`
- Pagination: 20 per page, scoped to authenticated user via RLS.

**GET /api/admin/notifications/log** (Admin only)

- Auth: Bearer token (admin role)
- Filters: `user_id`, `event_type`, `channel`, `status`, `date_from`, `date_to`
- Pagination: 50 per page.

### 5.2 Preferences Endpoints

**GET /api/notifications/preferences**

- Auth: Bearer token
- Response 200: Full preferences JSON object

**PATCH /api/notifications/preferences**

- Auth: Bearer token
- Body: `{"event_type": "trade.fill", "channel": "telegram", "enabled": false}`
- Response 200: `{"success": true}`
- Response 400: `{"error": "invalid_preference", "message": "Risk breach notifications cannot be disabled for email."}`
- Response 403: `{"error": "tier_restricted", "message": "Discord notifications require Pro plan or higher."}`

**GET /api/notifications/preferences/quiet-hours**

- Auth: Bearer token
- Response 200: Quiet hours configuration object

**PUT /api/notifications/preferences/quiet-hours**

- Auth: Bearer token
- Body: Full quiet hours configuration object
- Response 200: `{"success": true}`
- Response 422: `{"error": "validation_error", "message": "Start and end time cannot be the same."}`

### 5.3 API Rate Limiting

| Endpoint Category | Rate Limit | Window |
|---|---|---|
| Notification read/list | 60 requests | Per minute |
| Notification preferences | 30 requests | Per minute |
| Unread count | 120 requests | Per minute |
| Admin log | 30 requests | Per minute |

### 5.4 Error Response Format

All API errors follow this structure:

```json
{
  "error": "error_code",
  "message": "Human-readable description",
  "details": {}
}
```

Standard HTTP codes: 400, 401, 403, 404, 422, 429, 500.

---

## 6. UI/UX Specifications

### 6.1 Component Inventory

| Component | Location | States |
|---|---|---|
| Notification Bell Icon | Dashboard header (always visible) | No notifications (no badge), has unread (badge with count), 99+ (max badge), reconnecting (orange dot) |
| Notification Panel | Slide-out from right side | Empty, loading, populated, filtered, error |
| Toast Notification | Bottom-right overlay | Appear (slide in), visible (5s), dismiss (fade out) |
| Settings > Notifications | Full page | Loading, loaded, saving (per toggle), error |

### 6.2 Responsive Behavior

| Viewport | Notification Panel | Preferences Matrix |
|---|---|---|
| Desktop (>1024px) | Right side panel, 400px wide | Full matrix table |
| Tablet (768-1024px) | Right side panel, 350px wide | Horizontal scroll on matrix |
| Mobile (<768px) | Full-screen overlay | Stacked cards per event type instead of matrix |

### 6.3 Accessibility Requirements

- All toggle switches have associated labels readable by screen readers.
- Toast notifications announced via `aria-live="polite"` region.
- Notification bell badge count announced: `aria-label="{count} unread notifications"`.
- Color is not the only status indicator (icons + text accompany color-coded badges).
- All interactive elements keyboard-navigable (Tab, Enter, Escape to close panel).
- Focus trapped within notification panel when open.

---

## 7. Security Specifications

### 7.1 Data Isolation

All notification queries enforce PostgreSQL Row-Level Security. Users can only access their own notifications and delivery history.

### 7.2 Data Encryption

| Data | At Rest | In Transit |
|---|---|---|
| Notification content | PostgreSQL encryption at rest (Supabase default) | HTTPS (API), WSS (WebSocket) |
| Notification preferences | PostgreSQL encryption at rest | HTTPS |

### 7.3 Audit Logging

| Event | Logged Data | Retention |
|---|---|---|
| Notification preference change | user_id, event_type, channel, old_value, new_value, timestamp | 1 year |
| Circuit breaker activation | channel, timestamp, failure_count | 90 days |
| Tier change affecting channels | user_id, old_tier, new_tier, disabled_channels | 1 year |

---

## 8. Performance Specifications

### 8.1 Response Time Requirements

| Operation | Target (p95) | Target (p99) |
|---|---|---|
| In-app notification delivery (event to WebSocket receipt) | < 2s | < 3s |
| Notification preferences save | < 500ms | < 1s |
| Unread count fetch | < 200ms | < 500ms |
| Notification history page load | < 500ms | < 1s |

### 8.2 Throughput Requirements

| Operation | Sustained | Burst |
|---|---|---|
| Notification dispatch (Celery) | 100 concurrent dispatches | 500 in 1-minute spike |
| WebSocket connections (Supabase Realtime) | 1,000 concurrent | 2,000 concurrent |

### 8.3 Resource Limits

| Resource | Limit | Action on Exceed |
|---|---|---|
| Notification queue depth | Warning at 500, critical at 2,000 | Alert operations; scale Celery workers |
| In-app notifications per user | 10,000 | Retention policy prevents exceeding |
| Deferred notification queue per user | 100 | Oldest deferred dropped with log warning |

---

## 9. Testing Specifications

### 9.1 Channel Routing Tests

| Test ID | Scenario | Expected Behavior |
|---|---|---|
| CR-001 | User has event disabled | No notification dispatched |
| CR-002 | Quiet hours active, non-critical event | Notification deferred |
| CR-003 | Quiet hours active, critical event, bypass=true | Notification dispatched |
| CR-004 | Quiet hours active, critical event, bypass=false | Notification deferred |
| CR-005 | Free user, Telegram event | Telegram channel skipped |
| CR-006 | Trader user, Discord event | Discord channel skipped |
| CR-007 | Pro user, all channels configured | Dispatch to all enabled channels |
| CR-008 | New user, no preferences set | Default preferences applied |
| CR-009 | Subscription in grace period | Treated as previous tier |
| CR-010 | No template for event/channel combo | Channel skipped, warning logged |

### 9.2 Template Rendering Tests

| Test ID | Scenario | Expected Behavior |
|---|---|---|
| TR-001 | Complete payload | All variables populated correctly |
| TR-002 | Missing optional fields | Dash placeholder used, no error |
| TR-003 | Monetary formatting | `$1,250.50` format verified |
| TR-004 | Telegram Markdown V2 escaping | Special characters escaped |
| TR-005 | Template file not found | Channel skipped, error logged, worker not crashed |

### 9.3 Rate Limiting Tests

| Test ID | Scenario | Expected Behavior |
|---|---|---|
| RL-001 | 21st Telegram message in 1 hour | Message queued, not dispatched |
| RL-002 | 6th Telegram message in 1 minute (burst) | Message queued |
| RL-003 | Critical event during rate limit | Message dispatched (bypass) |
| RL-004 | Rate limit resets after window | Batched summary dispatched |
| RL-005 | Redis unavailable during rate check | Fail open, dispatch allowed |

### 9.4 Retry Logic Tests

| Test ID | Scenario | Expected Behavior |
|---|---|---|
| RT-001 | 1st delivery failure | Retry scheduled at 10s delay |
| RT-002 | 2nd delivery failure | Retry scheduled at 30s delay |
| RT-003 | 5th delivery failure (final) | Notification marked `failed` |
| RT-004 | Critical event, all retries exhausted | Fallback channel triggered with [DELAYED] prefix |
| RT-005 | Non-critical event, all retries exhausted | Marked failed, no fallback |
| RT-006 | Worker crashes mid-retry | Task re-delivered via acks_late |

### 9.5 Circuit Breaker Tests

| Test ID | Scenario | Expected Behavior |
|---|---|---|
| CB-001 | 5 failures in 5 minutes for Telegram | Breaker opens, Telegram dispatches paused |
| CB-002 | After 2-min cooldown, test succeeds | Breaker closes, dispatches resume |
| CB-003 | After 2-min cooldown, test fails | Breaker re-opens for another 2 min |
| CB-004 | Retry fires during open state | Task re-queued with remaining open duration delay |
| CB-005 | State change monitoring | Metric emitted and alert triggered on every transition |

### 9.6 Quiet Hours Tests

| Test ID | Scenario | Expected Behavior |
|---|---|---|
| QH-001 | Overnight range (22:00-07:00) at 23:00 | Correctly identified as in quiet hours |
| QH-002 | Overnight range at 08:00 | Correctly identified as NOT in quiet hours |
| QH-003 | Same-day range (13:00-14:00) at 13:30 | In quiet hours |
| QH-004 | Start == end time | Treated as disabled |
| QH-005 | Day-of-week filtering: Tuesday disabled, event on Tuesday | NOT in quiet hours |
| QH-006 | Deferred notifications flushed on quiet hours end | Batch summary dispatched per channel |
| QH-007 | User disables quiet hours while deferred queue has items | Immediate flush |
| QH-008 | No deferred items when quiet hours end | No empty summary sent |
| QH-009 | Deferred queue exceeds 100 items | Oldest dropped, warning logged |

### 9.7 Delivery Status Tracking Tests

| Test ID | Scenario | Expected Behavior |
|---|---|---|
| DS-001 | Successful delivery | Status: queued -> dispatched -> delivered |
| DS-002 | Failed then retried | Status: queued -> dispatched -> queued (retry) -> dispatched -> delivered |
| DS-003 | All retries fail | Status: queued -> dispatched -> ... -> failed |
| DS-004 | Deferred then delivered | Status: deferred -> queued -> dispatched -> delivered |
| DS-005 | Duplicate correlation_id | Second event skipped entirely |

### 9.8 In-App Notification Tests

| Test ID | Scenario | Expected Behavior |
|---|---|---|
| IA-001 | New notification arrives | Badge increments, toast appears, auto-dismisses in 5s |
| IA-002 | Click notification with deep link | Marked as read, navigates to trade/trendline page |
| IA-003 | Mark all as read | All notifications marked read, badge resets to 0 |
| IA-004 | 100+ unread | Badge shows "99+" |
| IA-005 | WebSocket disconnects | Orange dot indicator, exponential backoff reconnect |
| IA-006 | Reconnection after gap | Missed notifications fetched via REST |
| IA-007 | Reconnection fails for 5 min | Persistent "Refresh" banner |

### 9.9 Preferences UI Tests

| Test ID | Scenario | Expected Behavior |
|---|---|---|
| PF-001 | Toggle trade.fill email OFF | Optimistic UI update, API call succeeds |
| PF-002 | API fails on toggle | Toggle reverts, error toast shown |
| PF-003 | Attempt to disable risk breach email | Toggle locked, tooltip explains |
| PF-004 | Free user views Telegram column | Column grayed out with lock + "Available on Trader plan" |
| PF-005 | Quiet hours start == end | Validation error shown |
| PF-006 | Tier upgrade mid-session | New channel cards become available without reload |
| PF-007 | Tier downgrade | Affected channels disabled, email sent to user |

### 9.10 Tier Restriction Tests

| Test ID | Scenario | Expected Behavior |
|---|---|---|
| TG-001 | Free user calls PATCH preferences for Telegram | HTTP 403: tier_restricted |
| TG-002 | Trader user enables Discord preference | HTTP 403: tier_restricted |
| TG-003 | Pro user enables all available channels | Success |
| TG-004 | Downgrade Pro -> Trader | Discord preferences disabled, email sent |
| TG-005 | Upgrade Trader -> Pro | Discord defaults applied, in-app + email notification sent |

### 9.11 Security Tests

| Test ID | Scenario | Expected Behavior |
|---|---|---|
| SEC-001 | User A reads User B's notifications | RLS blocks: 404 or empty result |
| SEC-002 | User A reads User B's notification_log | RLS blocks |
| SEC-003 | Expired JWT | HTTP 401 |
| SEC-004 | Missing JWT | HTTP 401 |

### 9.12 Performance Benchmark Tests

| Test ID | Scenario | Metric | Target |
|---|---|---|---|
| PB-001 | In-app delivery latency | Event to WebSocket receipt | < 2s (p95) |
| PB-002 | Preference save | API response time | < 500ms (p95) |
| PB-003 | Unread count | API response time | < 200ms (p95) |
| PB-004 | 100 concurrent dispatches | Celery throughput | All dispatched within 5s |
| PB-005 | Notification history query | DB query time | < 200ms |

---

## 10. Migration & Deployment

### 10.1 Database Migrations (Phase 1)

1. Create `notification_log` table with indexes and RLS policy.
2. Create `notifications` table (in-app) with indexes and RLS policy.
3. Add `notification_preferences` JSONB column to `users` table with default value.
4. Add `execution_paused` boolean column to `users` table (default: `false`).

### 10.2 Infrastructure Dependencies

| Dependency | Must Be Ready Before |
|---|---|
| Redis instance (Upstash) | Phase 1 start |
| Celery workers configured | Phase 1 start |
| Supabase Realtime configured | Phase 2 start (in-app notifications) |

### 10.3 Feature Flags

| Flag | Purpose | Default |
|---|---|---|
| `notifications.inapp.enabled` | Enable/disable in-app notifications | `false` (Phase 2) |
| `notifications.tier_gating.enabled` | Enable/disable tier-based channel restrictions | `false` (Phase 3) |

### 10.4 Rollback Procedures

| Scenario | Rollback Action |
|---|---|
| Notification queue backing up | Scale Celery workers; if code issue, disable feature flags and drain queue |
| Circuit breaker stuck open | Manual reset via Redis: `SET circuit_breaker:{channel} closed` |
| Database migration failure | Run reverse migration; all migrations are additive with `down` methods |

---

## 11. Open Questions & Assumptions

### 11.1 Assumptions

| # | Assumption | Impact if Wrong |
|---|---|---|
| A1 | Redis Pub/Sub is sufficient for event bus (vs. RabbitMQ) | May need to migrate to RabbitMQ; mitigated by event outbox pattern |
| A3 | Supabase Realtime can handle 1,000 concurrent WebSocket connections | May need custom WebSocket server |
| A5 | Telegram Bot API rate limits (30 msg/s global) are sufficient | Unlikely issue with < 1,000 users |

### 11.2 Open Questions

| # | Question | Impact | Suggested Default |
|---|---|---|---|
| Q1 | Should the event outbox table be implemented in Phase 1 or Phase 2? | Affects delivery guarantees for critical notifications | Phase 1 (critical for trade.fill reliability) |

---

## Appendix A: Glossary

| Term | Definition |
|---|---|
| Channel | A delivery mechanism for notifications (Telegram, Discord, Email, In-App, Custom Webhook) |
| Channel Adapter | A module that formats and sends notifications for a specific channel (see FSD-010b) |
| Circuit Breaker | A pattern that stops sending to a failing channel to prevent cascading failures |
| Correlation ID | A unique identifier that traces a single event through all systems |
| Critical Event | An event requiring at-least-once delivery with fallback: trade.fill, trade.rejected, trade.closed, risk.limit_breach, account.connection_lost |
| Deferred Notification | A notification held during quiet hours for later batch delivery |
| Domain Event | A significant occurrence in the system (e.g., trade filled, risk limit breached) |
| Idempotency | Ensuring the same event processed twice produces the same result (no duplicate notifications) |

## Appendix B: Event Payload Examples

**`trade.fill` event:**

```json
{
  "event_type": "trade.fill",
  "user_id": "usr_abc123",
  "timestamp": "2026-02-11T19:32:05Z",
  "correlation_id": "cor_def456",
  "payload": {
    "trade_id": "trd_ghi789",
    "signal_id": "sig_jkl012",
    "symbol": "MES",
    "contract": "MESH26",
    "direction": "BUY",
    "quantity": 2,
    "fill_price": 5205.25,
    "stop_loss": 5190.00,
    "take_profit": 5225.50,
    "risk_amount": 305.00,
    "rr_ratio": 2.03,
    "slippage_ticks": 0.5,
    "signal_source": "tradingview_webhook",
    "playbook": "A+ Trendline Break",
    "trendline_grade": "A+",
    "trendline_touches": 4
  }
}
```

**`risk.limit_breach` event:**

```json
{
  "event_type": "risk.limit_breach",
  "user_id": "usr_abc123",
  "timestamp": "2026-02-11T20:15:30Z",
  "correlation_id": "cor_xyz789",
  "payload": {
    "limit_type": "daily_loss",
    "current_value": 1050.00,
    "limit_value": 1000.00,
    "percent_used": 105,
    "auto_action": "execution_paused",
    "open_positions": 2
  }
}
```

**`digest.daily` event:**

```json
{
  "event_type": "digest.daily",
  "user_id": "usr_abc123",
  "timestamp": "2026-02-11T23:00:00Z",
  "correlation_id": "cor_mno345",
  "payload": {
    "date": "2026-02-11",
    "net_pnl": 425.00,
    "net_r": 3.42,
    "trades_count": 4,
    "wins": 3,
    "losses": 1,
    "win_rate": 0.75,
    "best_trade": { "symbol": "MES", "pnl": 370.00, "r": 1.82 },
    "worst_trade": { "symbol": "CL", "pnl": -125.00, "r": -0.65 },
    "active_alerts": 7,
    "daily_loss_used_pct": 0.32
  }
}
```

---

*Document version: 1.0 | Last updated: February 12, 2026*
*This document is part of the TrendEdge FSD suite (FSD-010a of FSD-010, sibling to FSD-010b, FSD-010c)*
