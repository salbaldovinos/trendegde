# FSD-008: Authentication & User Management

**TrendEdge — AI-Powered Futures Trading Platform**

| Field | Value |
|---|---|
| FSD ID | FSD-008 |
| Source PRD | PRD-008 |
| Title | Authentication & User Management |
| Version | 1.0 |
| Status | Draft |
| Author | Generated by Claude |
| Created | 2026-02-11 |

---

## 1. Introduction

### 1.1 Purpose

This Functional Specification Document (FSD) translates PRD-008 into an implementable specification for the Authentication & User Management system of TrendEdge. It defines every user-visible behavior, data transformation, error state, state transition, and integration point required for a developer to implement the complete authentication, authorization, user profile management, broker credential management, and data isolation layers without ambiguity.

TrendEdge handles sensitive financial data including broker API credentials, trading history, account balances, and proprietary trading strategies. A breach or data leak could result in direct financial loss to users. Every specification in this document is designed with security-by-default, defense-in-depth, and least-privilege access as foundational principles.

### 1.2 Scope

This FSD covers:

- **User Registration** — Email/password, OAuth (Google, GitHub), magic link flows
- **Authentication** — JWT token lifecycle, session management, refresh token rotation
- **User Profile Management** — Profile CRUD, trading preferences, notification preferences
- **Broker Connection Management** — Secure credential storage, connection health monitoring, multi-broker support
- **Row Level Security (RLS)** — PostgreSQL-enforced data isolation across all user-owned tables
- **Role-Based Access Control (RBAC)** — User, admin, team_admin, team_member roles with enforced permission boundaries
- **Team/Organization Support** — Team creation, member invitation, shared playbooks, team analytics (Phase 3)
- **Onboarding** — Welcome wizard, paper trading default activation (Phase 3)
- **Account Lifecycle** — Data export, account deletion with GDPR compliance (Phase 3)
- **API Key Management** — Key generation, webhook URL provisioning, key validation for TradingView integration

### 1.3 Phased Delivery

| Phase | Timeline | Scope | Target Users |
|-------|----------|-------|-------------|
| Phase 1 | Weeks 1-2 | Single-user basic auth. Email/password login, JWT handling, profile basics, RLS from day one, IBKR and Tradovate broker connections with encrypted credentials. | 1 (developer) |
| Phase 2 | Weeks 9-14 | Full auth flows. Magic links, OAuth, email verification, password reset, session management, multi-broker, API keys, webhooks, all security hardening. | 1-100 (beta) |
| Phase 3 | Weeks 15-22 | Multi-tenant SaaS. Teams, member invitations, shared playbooks, onboarding wizard, data export, account deletion, GDPR compliance. | 100-5,000+ |

### 1.4 Downstream Dependencies

This FSD is the security foundation for the entire TrendEdge platform. The following FSDs depend on this one being implemented first:

| Dependent FSD | What It Needs From FSD-008 |
|---------------|---------------------------|
| [Cross-reference: see FSD-002 for trendline detection] | User context for per-user trendline storage (RLS, JWT) |
| [Cross-reference: see FSD-003 for execution pipeline] | Broker credentials, user identity for order routing |
| [Cross-reference: see FSD-004 for journaling] | User identity for trade ownership (RLS, JWT) |
| [Cross-reference: see FSD-005 for playbook system] | User identity, team sharing |
| [Cross-reference: see FSD-006 for analytics] | User identity for data scoping |
| [Cross-reference: see FSD-009 for notifications] | Notification preferences, Telegram setup |
| [Cross-reference: see FSD-010 for integrations] | API keys for webhook authentication |
| [Cross-reference: see FSD-011 for billing & subscriptions] | User identity, subscription tier enforcement |

### 1.5 Auth Provider

**Supabase Auth** is the authentication provider. It provides OAuth 2.0 and OpenID Connect flows, magic link (passwordless) authentication, JWT-based session tokens with configurable expiry, Row Level Security integration with PostgreSQL, built-in email verification and password reset flows, and team/organization support for Phase 3.

---

## 2. System Context

### 2.1 Architecture Overview

```
+-------------------+       +-------------------+       +-------------------+
|   React Frontend  | <---> |  FastAPI Backend   | <---> |    PostgreSQL      |
|   (Next.js)       |       |  (Python 3.11+)   |       |    (Supabase)      |
+-------------------+       +-------------------+       +-------------------+
        |                           |                           |
        |                   +-------+-------+           +-------+-------+
        |                   |    Redis      |           |   RLS Policies |
        |                   |   (Upstash)   |           |   (Per-table)  |
        |                   +---------------+           +---------------+
        |
+-------+-------+       +-------------------+       +-------------------+
| Supabase Auth  |       |  Cloudflare R2    |       |   SendGrid/       |
| (OAuth, JWT)   |       |  (Avatars, Export)|       |   Resend (Email)  |
+---------------+       +-------------------+       +-------------------+
```

### 2.2 Component Responsibilities

| Component | Responsibility |
|-----------|---------------|
| **React Frontend (Next.js)** | Registration/login forms, session state management via Supabase JS SDK, token storage in memory, inactivity timeout tracking, UI rendering for all auth screens |
| **FastAPI Backend** | JWT validation, RLS context injection (`SET request.jwt.claim.sub`), broker credential encryption/decryption, API key validation, rate limiting enforcement, audit logging |
| **Supabase Auth** | User registration, JWT issuance, refresh token rotation, OAuth provider integration, magic link generation, email verification, password reset email delivery |
| **PostgreSQL (Supabase)** | User data storage, RLS policy enforcement, database triggers for new user setup, all user-owned table isolation |
| **Redis (Upstash)** | Session caching, rate limiting counters (sliding window), user permission/role cache (TTL: 5 min), token blacklist for revoked sessions |
| **Cloudflare R2** | Avatar image storage (`avatars/{user_id}.{ext}`), temporary data export ZIP storage (24-hour TTL) |
| **SendGrid/Resend** | Transactional emails: verification, password reset, team invitations, security notifications, data export download links |
| **Celery Workers** | Background tasks: broker health checks (every 5 min), token auto-refresh (Tradovate), data export generation, soft-delete cleanup (30-day), encryption key rotation |

### 2.3 External Actor Interactions

| Actor | Interaction | Authentication Method |
|-------|------------|----------------------|
| Anonymous visitor | Registration, login, password reset, OAuth redirect | None (public endpoints) |
| Authenticated user | Profile management, trading, broker connections, settings | JWT Bearer token in Authorization header |
| Webhook sender (TradingView) | POST signals to webhook endpoint | API key in `X-API-Key` header or `api_key` query parameter |
| Broker APIs (IBKR, Tradovate, Webull) | Order execution, account info, health checks | Broker-specific credentials (encrypted at rest, decrypted in memory) |
| Admin user | Read-only access to user data for support | JWT Bearer token + admin role verified from database (not JWT claims) |
| Celery worker | Cross-user background tasks (health checks, cleanup) | Supabase service role key (bypasses RLS) |

---

## 3. Functional Specifications

### 3.1 FR-001: Email/Password Registration

**Source:** PRD AU-FR-001 | **Phase:** 1 | **Priority:** P0

#### Description

The system provides email/password registration using Supabase Auth. On successful registration, a corresponding row is created in the `public.users` table via a database trigger, populated with default settings. The user receives a verification email.

#### Inputs

| Field | Type | Validation | Required |
|-------|------|-----------|----------|
| email | string | RFC 5322 format; case-insensitive (lowercased before storage) | Yes |
| password | string | Minimum 8 characters, at least 1 uppercase letter, at least 1 lowercase letter, at least 1 digit, at least 1 special character from `!@#$%^&*` | Yes |
| confirm_password | string | Must exactly match `password` | Yes |

#### Processing Logic

1. User navigates to `/register`. The page renders a form with three fields: email, password, confirm password.
2. **Client-side validation (before submit):**
   - Email is validated against RFC 5322 format in real time as the user types (debounced 300ms).
   - Password is validated against all four complexity rules. A real-time strength indicator displays: "Weak" (red, <3 rules met), "Fair" (orange, 3 rules met), "Strong" (green, all 4 rules met, 8-11 chars), "Very Strong" (green, all 4 rules met, 12+ chars).
   - Confirm password is validated to match password as the user types.
   - The "Register" button is disabled until all three validations pass.
3. **On submit:** The frontend calls `supabase.auth.signUp({ email, password })`.
4. **On Supabase success:** The Supabase backend creates a row in `auth.users`. A PostgreSQL trigger (`on_auth_user_created`) fires and inserts a corresponding row into `public.users` with all default settings (see Data Specifications section 4.1).
5. **Frontend redirect:** Display the message "Check your email to verify your account." and redirect to `/verify-email`.

#### Outputs

| Scenario | HTTP Status | Response / UI Behavior |
|----------|-------------|----------------------|
| Success | 201 | Supabase returns session object. Frontend displays verification message, redirects to `/verify-email`. |
| Duplicate email (production) | 200 | Generic message: "If this email is not already registered, you will receive a verification email." No indication of whether the account exists. |
| Duplicate email (development) | 422 | "An account with this email already exists. Try logging in or resetting your password." |
| Rate limited | 429 | "Too many attempts. Please try again in 60 seconds." |
| Network error | N/A (client) | "Unable to connect. Please check your connection and try again." |

#### Business Rules

- BR-001: In production, the system MUST NOT reveal whether an email is already registered. The generic message is used for both existing and new emails.
- BR-002: All new users are created with `subscription_tier = 'free'`, `role = 'user'`, `paper_trading_mode = true`, and `onboarding_completed = false`.
- BR-003: The database trigger that creates the `public.users` row runs as `SECURITY DEFINER` to ensure it can insert into the `public.users` table regardless of the calling context.
- BR-004: Registration rate limit is 5 requests per IP per hour.

#### Error Handling

| Error Condition | User-Facing Message | System Action |
|----------------|---------------------|---------------|
| Empty email field | "Please enter a valid email address." | Client-side inline validation; form not submitted |
| Invalid email format | "Please enter a valid email address." | Client-side inline validation; form not submitted |
| Password too short (<8 chars) | "Password must be at least 8 characters with 1 uppercase, 1 lowercase, 1 number, and 1 special character." | Client-side inline validation; form not submitted |
| Password missing uppercase | Same as above | Client-side; register button disabled |
| Password missing lowercase | Same as above | Client-side; register button disabled |
| Password missing digit | Same as above | Client-side; register button disabled |
| Password missing special char | Same as above | Client-side; register button disabled |
| Passwords do not match | "Passwords do not match." | Client-side inline validation below confirm field |
| Supabase 429 (rate limit) | "Too many attempts. Please try again in 60 seconds." | Log rate limit event, display countdown timer |
| Supabase 500 (server error) | "Something went wrong. Please try again later." | Log error with full Supabase response (excluding credentials) |
| Network timeout (>10s) | "Unable to connect. Please check your connection and try again." | Client-side timeout detection |
| Database trigger failure | User sees success (Supabase auth row created), but `public.users` row missing | Backend health check detects orphaned auth users and retries trigger logic within 5 minutes |

#### Edge Cases

- **SQL injection in email:** The Supabase SDK parameterizes all inputs. Raw SQL characters in the email field are treated as literal text and will fail RFC 5322 validation.
- **XSS in any field:** React JSX escaping prevents script execution. Server-side `bleach` sanitization strips HTML tags on any stored text.
- **Simultaneous registration with same email:** Supabase enforces unique email constraint at the database level. The second request receives the duplicate email response.
- **Browser back button after registration:** The `/verify-email` page is idempotent. Revisiting it shows the same "Check your email" message.
- **Registration with OAuth-linked email:** If the email is already associated with a Google/GitHub OAuth account, Supabase links the password credential to the existing account (Phase 2 behavior). In Phase 1, OAuth is not available, so this case does not arise.

---

### 3.2 FR-002: Magic Link (Passwordless) Authentication

**Source:** PRD AU-FR-002 | **Phase:** 2 | **Priority:** P0

#### Description

The system supports passwordless login via one-time magic links sent to the user's email address. Magic links are single-use and expire after 1 hour.

#### Inputs

| Field | Type | Validation | Required |
|-------|------|-----------|----------|
| email | string | RFC 5322 format | Yes |

#### Processing Logic

1. User navigates to `/login` and clicks "Sign in with magic link."
2. A single email input field is displayed.
3. User enters their email and clicks "Send magic link."
4. Frontend calls `supabase.auth.signInWithOtp({ email })`.
5. Regardless of whether the email exists, display: "Check your email for a login link. The link expires in 1 hour."
6. Supabase sends an email containing a link to `/auth/callback?token=<otp_token>&type=magiclink`.
7. User clicks the link. The `/auth/callback` page extracts the token and calls `supabase.auth.verifyOtp({ token_hash, type: 'magiclink' })`.
8. On success, the user is redirected to `/dashboard`.

#### Outputs

| Scenario | Response / UI Behavior |
|----------|----------------------|
| Success (email exists) | Email sent with magic link. User clicks link, session created, redirect to `/dashboard`. |
| Email does not exist | Same "Check your email" message displayed (no information leakage). No email sent. |
| Expired link (>1 hour) | "This link has expired. Request a new one." with a "Send new link" button. |
| Already-used link | "This link has already been used. Request a new one." with a "Send new link" button. |
| Invalid/malformed token | "Invalid login link. Please request a new one." |
| Rate limited | "Too many attempts. Please try again in 15 minutes." |

#### Business Rules

- BR-005: Magic links are single-use. After one successful verification, the token is invalidated.
- BR-006: Rate limit: maximum 3 magic link requests per email per 15-minute window.
- BR-007: Magic links expire after 1 hour (configured in Supabase dashboard).

#### Error Handling

| Error Condition | User-Facing Message | System Action |
|----------------|---------------------|---------------|
| Empty email | "Please enter your email address." | Client-side validation |
| Invalid email format | "Please enter a valid email address." | Client-side validation |
| 3+ requests in 15 min for same email | "Too many attempts. Please try again in 15 minutes." | Redis counter tracks per-email requests |
| Supabase unavailable | "Something went wrong. Please try again later." | Log error, suggest email/password login as fallback |

#### Edge Cases

- **User clicks magic link in a different browser:** The link works in any browser. A new session is created in the browser where the link is opened.
- **User requests multiple magic links:** Only the most recent link is valid. Previous links are invalidated by Supabase.
- **Email delivered after expiry window:** The link shows the expiration message with an option to request a new one.

---

### 3.3 FR-003: OAuth Provider Authentication (Google)

**Source:** PRD AU-FR-003 | **Phase:** 2 | **Priority:** P0

#### Description

The system supports Google OAuth login. New users are automatically registered; existing users with the same email have the OAuth identity linked to their account.

#### Inputs

None (user-initiated via button click).

#### Processing Logic

1. User clicks "Continue with Google" on the `/login` or `/register` page.
2. Frontend calls `supabase.auth.signInWithOAuth({ provider: 'google', options: { redirectTo: 'https://app.trendedge.io/auth/callback' } })`.
3. User is redirected to Google's consent screen.
4. On consent, Google redirects to `/auth/callback` with authorization code.
5. Supabase exchanges the code for tokens and creates or links the user account.
6. **New user:** The `on_auth_user_created` database trigger fires, creating the `public.users` row with defaults.
7. **Existing user (same email):** Supabase links the Google OAuth identity to the existing account. No duplicate user row is created.
8. Frontend receives the session and redirects:
   - Existing user: `/dashboard`
   - New user (Phase 3): `/onboarding`
   - New user (Phase 1-2): `/dashboard`

#### Outputs

| Scenario | Response / UI Behavior |
|----------|----------------------|
| Success (new user) | Account created, session established, redirect to dashboard (or onboarding in Phase 3). |
| Success (existing user) | OAuth identity linked, session established, redirect to dashboard. |
| User denies consent | Redirect to `/login` with message: "Google sign-in was cancelled." |
| OAuth state mismatch (CSRF) | "Authentication failed. Please try again." |
| Google returns error | "Google sign-in failed. Please try again or use another login method." |

#### Business Rules

- BR-008: Google OAuth requires `GOOGLE_OAUTH_CLIENT_ID` and `GOOGLE_OAUTH_CLIENT_SECRET` environment variables.
- BR-009: The OAuth redirect URL must be registered in the Google Cloud Console: `https://[SUPABASE_URL]/auth/v1/callback`.
- BR-010: Requested Google scopes: `openid`, `email`, `profile`.

#### Edge Cases

- **User's Google email matches an existing password-only account:** Supabase links the identities. The user can now log in with either method.
- **User revokes Google access after linking:** The user can still log in with email/password or magic link. The Google login option will require re-consent.
- **Google account has no public email:** Sign-in fails. Display: "Could not retrieve your email from Google. Please ensure your Google account has a verified email."

---

### 3.4 FR-004: OAuth Provider Authentication (GitHub)

**Source:** PRD AU-FR-004 | **Phase:** 2 | **Priority:** P1

#### Description

The system supports GitHub OAuth login. The flow is identical to FR-003 (Google OAuth) but uses `provider: 'github'`. GitHub is relevant for the developer persona.

#### Processing Logic

Same as FR-003 with the following substitutions:
- Provider: `'github'` instead of `'google'`
- Button text: "Continue with GitHub"
- Consent screen: GitHub's authorization page
- Scopes: `user:email`
- Environment variables: `GITHUB_OAUTH_CLIENT_ID`, `GITHUB_OAUTH_CLIENT_SECRET`

#### Error Messages

- User denies consent: "GitHub sign-in was cancelled."
- OAuth error: "GitHub sign-in failed. Please try again or use another login method."

---

### 3.5 FR-005: Email Verification Flow

**Source:** PRD AU-FR-005 | **Phase:** 2 | **Priority:** P0

#### Description

The system requires email verification before granting full account access. Unverified users can access the dashboard in read-only mode but cannot connect brokers, execute trades, or create API keys.

#### Inputs

None (triggered automatically on registration). Resend requires no new input.

#### Processing Logic

1. On registration (FR-001), Supabase automatically sends a verification email containing a link to `/auth/callback?token=<token>&type=signup`.
2. The dashboard displays a persistent verification banner at the top of the page for unverified users.
3. Banner text: "Please verify your email to unlock all features. Didn't receive the email? [Resend]"
4. Clicking "Resend" calls `supabase.auth.resend({ type: 'signup', email: currentUser.email })`.
5. Verification link expires after 24 hours.
6. On successful verification via the link, the frontend listens to `supabase.onAuthStateChange()` and:
   - Removes the verification banner immediately (no page reload required).
   - Unlocks all restricted features.
   - Displays a toast notification: "Email verified successfully!"

#### Feature Restrictions for Unverified Users

| Feature | Unverified Access |
|---------|------------------|
| View dashboard | Yes (read-only) |
| View profile settings | Yes |
| Edit profile settings | Yes |
| Connect brokers | **No** — "Please verify your email first." |
| Execute trades (live or paper) | **No** — "Please verify your email first." |
| Create API keys | **No** — "Please verify your email first." |
| View existing data | Yes |

#### Business Rules

- BR-011: Rate limit for resend: maximum 3 resend requests per hour.
- BR-012: Verification link expires after 24 hours.
- BR-013: OAuth-registered users (Google, GitHub) are automatically verified because the OAuth provider has already verified their email.

#### Error Handling

| Error Condition | User-Facing Message |
|----------------|---------------------|
| Expired verification link | "This verification link has expired." with "Send new verification email" button |
| Already verified user clicks link | Redirect to `/dashboard` with toast: "Your email is already verified." |
| Resend rate limit exceeded | "You've requested too many verification emails. Please try again in 1 hour." |

---

### 3.6 FR-006: Password Reset Flow

**Source:** PRD AU-FR-006 | **Phase:** 2 | **Priority:** P0

#### Description

The system provides a secure password reset mechanism. The flow never reveals whether an email address is registered.

#### Inputs

**Request phase:**

| Field | Type | Validation | Required |
|-------|------|-----------|----------|
| email | string | RFC 5322 format | Yes |

**Reset phase:**

| Field | Type | Validation | Required |
|-------|------|-----------|----------|
| new_password | string | Same rules as registration (8+ chars, uppercase, lowercase, digit, special char) | Yes |
| confirm_password | string | Must match new_password | Yes |

#### Processing Logic

1. User clicks "Forgot password?" on the `/login` page.
2. System displays an email input form at `/forgot-password`.
3. On submit, system calls `supabase.auth.resetPasswordForEmail(email, { redirectTo: 'https://app.trendedge.io/auth/reset-password' })`.
4. **Always display** (regardless of whether the email exists): "If an account exists with that email, you will receive a password reset link."
5. If the email is registered, Supabase sends a reset email with a link to `/auth/reset-password?token=<token>`.
6. Reset link expires after 1 hour.
7. The reset password page (`/auth/reset-password`) renders two fields: new password and confirm password, with a real-time strength indicator.
8. Strength indicator levels: "Weak" (red), "Fair" (orange), "Strong" (green), "Very Strong" (green, bold).
9. On submit, the frontend calls `supabase.auth.updateUser({ password: newPassword })`.
10. On success: Display "Password updated successfully." and redirect to `/login`.
11. All existing sessions for this user are invalidated upon password reset.

#### Business Rules

- BR-014: The response message MUST be identical whether the email exists or not (prevents email enumeration).
- BR-015: Reset link expires after 1 hour.
- BR-016: Reset links are single-use. Using a link invalidates it.
- BR-017: Rate limit: maximum 3 reset requests per email per hour.
- BR-018: New password must be different from the current password.
- BR-019: On successful password reset, ALL existing sessions for the user are invalidated. The user must log in again with the new password.

#### Error Handling

| Error Condition | User-Facing Message |
|----------------|---------------------|
| Expired reset token | "This reset link has expired. Request a new one." with "Request new link" button |
| Already-used reset token | "This reset link has already been used." |
| New password matches old | "New password must be different from your current password." |
| New password fails validation | Same validation messages as registration (FR-001) |
| Passwords do not match | "Passwords do not match." |
| Rate limit (3+ requests/hour) | "Too many reset requests. Please try again later." |

#### Edge Cases

- **User requests multiple resets:** Only the most recent reset link is valid. Previous links are invalidated.
- **User is already logged in and navigates to forgot password:** Redirect to `/settings/account` with option to change password directly (requires current password).
- **User's account is soft-deleted:** The generic message is still shown (no information leakage). No email is sent.

---

### 3.7 FR-010: JWT Token Handling

**Source:** PRD AU-FR-010 | **Phase:** 1 | **Priority:** P0

#### Description

The system uses Supabase-issued JWTs for all authenticated API requests. Access tokens are short-lived (15 minutes) and stored in memory. Refresh tokens are long-lived (7 days) and stored in HTTP-only cookies.

#### Processing Logic

1. On successful authentication (any method), Supabase issues:
   - **Access token:** JWT, 15-minute lifetime, stored in JavaScript memory (never `localStorage` or `sessionStorage`).
   - **Refresh token:** Opaque token, 7-day lifetime, stored in an HTTP-only, Secure, SameSite=Lax cookie.
2. Every API request to the FastAPI backend includes the access token: `Authorization: Bearer <access_token>`.
3. The FastAPI backend validates the JWT on every request by:
   - Verifying the signature against `SUPABASE_JWT_SECRET`.
   - Checking the `exp` claim (reject if expired with HTTP 401).
   - Checking the `aud` claim matches the expected audience value.
   - Extracting the `sub` claim (user UUID).
4. After validation, the backend sets the PostgreSQL session variable for RLS enforcement: `SET request.jwt.claim.sub = '<user_id>'`.
5. All subsequent database queries in that request automatically apply RLS policies filtering by `auth.uid()`.

#### Business Rules

- BR-020: Access tokens are NEVER stored in `localStorage`, `sessionStorage`, cookies, or any persistent client-side storage. Memory-only.
- BR-021: Refresh tokens are stored exclusively in HTTP-only, Secure, SameSite=Lax cookies.
- BR-022: JWT validation is stateless (no database call required for valid tokens), achieving <50ms p95 latency.
- BR-023: Roles are verified from the database, NEVER from JWT claims alone (prevents privilege escalation via JWT manipulation).

#### Error Handling

| Error Condition | HTTP Status | Response Body |
|----------------|-------------|--------------|
| Missing Authorization header | 401 | `{"error": "authentication_required", "message": "Authentication required."}` |
| Malformed token | 401 | `{"error": "invalid_token", "message": "Invalid authentication token."}` |
| Expired access token | 401 | `{"error": "token_expired", "message": "Token has expired. Please refresh."}` |
| Invalid signature (tampered) | 401 | `{"error": "invalid_token", "message": "Invalid authentication token."}` |
| Audience mismatch | 401 | `{"error": "invalid_token", "message": "Invalid authentication token."}` |

---

### 3.8 FR-011: Refresh Token Rotation

**Source:** PRD AU-FR-011 | **Phase:** 1 | **Priority:** P0

#### Description

The system implements refresh token rotation. On each token refresh, the old refresh token is invalidated and a new one is issued. Reuse of an invalidated refresh token triggers automatic revocation of all sessions for that user.

#### Processing Logic

1. Access tokens expire after 15 minutes (900 seconds).
2. Refresh tokens expire after 7 days (604,800 seconds).
3. The Supabase client SDK automatically refreshes the access token when it is within 60 seconds of expiry.
4. On each refresh, the old refresh token is invalidated and a new refresh token + access token pair is issued.
5. **Theft detection:** If a previously-invalidated refresh token is used (indicating the token was copied before rotation), ALL sessions for that user are revoked immediately.
6. The user receives an email notification: "We detected suspicious activity on your account. All sessions have been signed out for your protection."
7. **Cross-tab coordination:** The Supabase client SDK uses `BroadcastChannel` API to coordinate refresh across browser tabs. Only one tab performs the refresh; other tabs receive the new token via the channel.

#### Business Rules

- BR-024: On stolen token detection, ALL sessions (every device, every browser) are revoked.
- BR-025: The security notification email is sent regardless of the user's notification preferences.
- BR-026: After forced sign-out due to theft detection, the user must re-authenticate with a primary method (password, OAuth, or magic link).

#### Edge Cases

- **Browser does not support BroadcastChannel:** Each tab refreshes independently. This may cause one tab's refresh token to be invalidated by another tab's refresh. The Supabase SDK handles this gracefully by retrying the refresh with the newly issued token.
- **User is offline when token expires:** On reconnection, the refresh token is used. If the refresh token has also expired (>7 days offline), the user is redirected to `/login` with message: "Your session has expired. Please sign in again."

---

### 3.9 FR-012: Session Expiry and Inactivity Timeout

**Source:** PRD AU-FR-012 | **Phase:** 1 (basic) / 2 (full) | **Priority:** P0

#### Description

The system enforces configurable session expiry policies including an inactivity timeout with user warning.

#### Configuration

| Parameter | Default Value | Configurable By |
|-----------|--------------|----------------|
| Access token lifetime | 900 seconds (15 min) | Environment variable |
| Refresh token lifetime | 604,800 seconds (7 days) | Environment variable |
| Inactivity timeout | 30 minutes | User setting (Phase 2) |
| Maximum session age | 30 days | Environment variable |

#### Processing Logic — Inactivity Timeout

1. The frontend tracks user interaction events: click, keypress, scroll, mouse movement.
2. An inactivity timer starts from the last interaction event.
3. After 25 minutes of inactivity, display a modal overlay:
   - Title: "Session Timeout Warning"
   - Body: "Your session will expire in 5 minutes due to inactivity."
   - Buttons: [Stay signed in]
   - A visible countdown timer from 5:00 to 0:00.
4. Clicking "Stay signed in" resets the inactivity timer to 30 minutes and triggers a token refresh.
5. If no action is taken after 30 minutes total, the frontend:
   - Calls `supabase.auth.signOut()`.
   - Preserves any unsaved form data in `sessionStorage` (keyed by route path).
   - Redirects to `/login` with message: "You were signed out due to inactivity."
6. On re-login, if `sessionStorage` contains preserved form data for the current route, restore it and show a toast: "Your unsaved changes have been restored."

#### Edge Cases

- **Multiple tabs open:** The inactivity timer tracks globally. Activity in any tab resets the timer for all tabs (via `BroadcastChannel` or `localStorage` event).
- **User is watching a long video or reading without interaction:** The modal appears at 25 minutes. This is by design for security. Users who want longer sessions can click "Stay signed in."

---

### 3.10 FR-013: Multi-Device Session Management

**Source:** PRD AU-FR-013 | **Phase:** 2 | **Priority:** P1

#### Description

Users can view and manage active sessions across devices from the security settings page.

#### Processing Logic

1. User navigates to `/settings/security/sessions`.
2. The page displays a list of active sessions with the following metadata per session:
   - **Device type:** Desktop, Mobile, or Tablet (parsed from User-Agent string).
   - **Browser:** Name and major version (e.g., "Chrome 120", "Safari 17").
   - **IP address:** Partially masked for privacy (e.g., `192.168.xxx.xxx` — last two octets hidden).
   - **Location:** City and country derived from IP geolocation.
   - **Last active:** Relative timestamp ("Active now", "2 hours ago", "3 days ago").
   - **Current session indicator:** The session matching the current device/browser is labeled "(this device)".
3. Each session except the current one has a "Revoke" button.
4. Clicking "Revoke" opens a confirmation modal: "Are you sure you want to revoke this session? The device will need to log in again. [Cancel] [Revoke]"
5. On confirmation, the backend calls `supabase.auth.admin.deleteSession(sessionId)` via a server-side proxy endpoint.
6. A "Revoke all other sessions" button at the top revokes every session except the current one.
7. After revocation, the revoked device's next API request returns HTTP 401, forcing re-authentication.

#### Business Rules

- BR-027: Users cannot revoke their own current session from this page. They must use the "Sign out" action in the navigation menu.
- BR-028: Session revocation is logged in the audit log with: `user_id`, `session_id`, `revoked_by: 'self'`, timestamp.
- BR-029: The session list refreshes automatically every 60 seconds while the page is active.

---

### 3.11 FR-020: Profile CRUD

**Source:** PRD AU-FR-020 | **Phase:** 1 (basic) / 2 (full) | **Priority:** P1/P0

#### Description

The system provides profile viewing and editing capabilities for user display name, timezone, avatar, and email.

#### Inputs — Profile Fields

| Field | Type | Validation | Default | Phase |
|-------|------|-----------|---------|-------|
| display_name | string | 2-50 characters; letters, spaces, hyphens only; regex: `^[a-zA-Z\s\-]{2,50}$` | null | 1 |
| timezone | string | Valid IANA timezone identifier (validated against `pytz.all_timezones` on backend) | "America/New_York" | 1 |
| avatar | file or URL | JPG or PNG format; max 2MB file size; minimum 200x200 pixels | null | 2 |
| email | string | RFC 5322 (change handled through separate verification flow) | from auth | 2 |

#### Processing Logic — Profile Update

1. User navigates to `/settings/profile`.
2. Form pre-fills with current values. Empty optional fields show placeholder text.
3. On change, client-side validation runs immediately.
4. On submit, frontend sends `PATCH /api/profile` with changed fields only.
5. Backend validates all fields server-side (same rules as client-side).
6. Backend updates the `public.users` row where `id = auth.uid()`.
7. `updated_at` is set to `NOW()` on every update.
8. Success response returns the updated profile object.
9. Frontend displays toast: "Profile updated successfully."

#### Processing Logic — Email Change

1. User enters a new email on the profile page and clicks "Change email."
2. Frontend calls `supabase.auth.updateUser({ email: newEmail })`.
3. Supabase sends a verification link to the NEW email address.
4. The old email remains active until the new email is verified.
5. On verification of the new email, Supabase sends a notification to the OLD email: "Your TrendEdge email was changed to [new-email]. If this wasn't you, contact support immediately."
6. The `public.users.email` field is updated by a database trigger listening to `auth.users` changes.

#### Processing Logic — Avatar Upload

1. User clicks "Upload avatar" or drags an image onto the avatar area.
2. Client validates: file type (JPG/PNG only), file size (max 2MB).
3. On submit, frontend sends `POST /api/profile/avatar` with the file as multipart form data.
4. Backend validates file type via magic bytes (not just extension), validates file size.
5. Backend resizes the image to 200x200 pixels using Pillow (Python Imaging Library), maintaining aspect ratio and center-cropping.
6. Backend uploads to Cloudflare R2 at path: `avatars/{user_id}.{ext}`.
7. Backend updates `users.avatar_url` with the R2 URL.
8. If a previous avatar exists, the old file is deleted from R2.
9. Frontend displays the new avatar immediately.

#### Error Handling

| Error Condition | User-Facing Message |
|----------------|---------------------|
| Display name < 2 chars | "Name must be at least 2 characters." |
| Display name > 50 chars | "Name must not exceed 50 characters." |
| Display name contains invalid chars | "Name can only contain letters, spaces, and hyphens." |
| Avatar file > 2MB | "Image must be under 2MB." |
| Avatar wrong format | "Please upload a JPG or PNG image." |
| Avatar file corrupted (magic bytes mismatch) | "The uploaded file appears to be corrupted. Please try a different image." |
| Avatar dimensions < 200x200 | "Image must be at least 200x200 pixels." |
| Timezone not in IANA list | "Please select a valid timezone." |
| Email change — new email already in use | "This email is already associated with another account." |
| R2 upload failure | "Avatar upload failed. Please try again." (retry up to 2 times, then show error) |

---

### 3.12 FR-021: Trading Preferences

**Source:** PRD AU-FR-021 | **Phase:** 1 | **Priority:** P0

#### Description

Users can configure default trading parameters that are used throughout the platform for trade execution, risk management, and dashboard display.

#### Inputs

| Preference | Type | Validation | Default | Range |
|-----------|------|-----------|---------|-------|
| default_instruments | string[] | 0-20 items; each must be a valid CME futures symbol | `[]` | Valid symbols: ES, NQ, YM, CL, GC, PL, SI, HG, NG, ZB, ZN, 6E, and others |
| default_timeframe | enum | Must be one of: 1H, 4H, D, W | "4H" | N/A |
| risk_per_trade_percent | decimal | 0.1 to 5.0, step 0.1 | 1.0 | 0.1 - 5.0 |
| max_daily_loss | decimal | 50.00 to 50,000.00, step 1.00 | 500.00 | $50 - $50,000 |
| max_concurrent_positions | integer | 1 to 20 | 3 | 1 - 20 |
| paper_trading_mode | boolean | N/A | true | true/false |

#### Processing Logic — Paper Trading Mode Toggle

1. User navigates to `/settings/trading` and toggles "Paper Trading Mode" from ON to OFF.
2. **First confirmation modal:** "You are switching to LIVE trading. Real money will be at risk. Are you sure? [Stay in paper] [Switch to live]"
3. **Conditional second warning:** If the user has been in paper mode for fewer than 60 days since account creation, an additional warning is displayed: "We recommend at least 60 days of paper trading before going live. You have completed [X] days. [Continue anyway] [Stay in paper]"
4. On confirmation, `settings.trading_preferences.paper_trading_mode` is set to `false`.
5. The toggle state change is logged in the audit log with event type `paper_mode_changed`, capturing `old_value`, `new_value`, and `days_in_paper`.
6. The dashboard banner changes from "PAPER TRADING MODE" (orange) to no banner (live mode).

#### Business Rules

- BR-030: Paper trading mode defaults to `true` for ALL new users regardless of subscription tier.
- BR-031: Switching from paper to live requires at least one active broker connection with `is_paper = false`.
- BR-032: If no live broker connection exists when toggling to live, display: "You need an active live broker connection to trade live. [Connect broker] [Stay in paper]"
- BR-033: Paper trades are always flagged with `trade.is_paper = true` and are never mixed with live trade data in analytics unless the user explicitly enables "Show paper trades" toggle.

---

### 3.13 FR-022: Notification Preferences

**Source:** PRD AU-FR-022 | **Phase:** 2 | **Priority:** P0

#### Description

Users can configure notification channels (Telegram, Discord, email) and select which events trigger notifications.

#### Inputs

| Setting | Type | Default | Validation |
|---------|------|---------|-----------|
| telegram_enabled | boolean | false | N/A |
| telegram_chat_id | string | null | Required when telegram_enabled is true; numeric string |
| discord_webhook_url | string | null | Must match `https://discord.com/api/webhooks/...` pattern |
| email_digest | enum | "daily" | One of: "none", "daily", "weekly" |
| alert_on_fill | boolean | true | N/A |
| alert_on_trendline | boolean | true | N/A |
| alert_on_risk_breach | boolean | true | N/A |

#### Processing Logic — Telegram Setup

1. User clicks "Connect Telegram" on the notification settings page.
2. System displays step-by-step instructions:
   - "1. Open Telegram on your phone or desktop."
   - "2. Search for @TrendEdgeBot."
   - "3. Send the command /start to the bot."
   - "4. The bot will reply with your Chat ID. Copy it and paste it below."
3. User pastes the chat ID into the input field.
4. User clicks "Test Connection."
5. Backend sends a test message via the Telegram Bot API to the provided chat ID: "TrendEdge connected successfully! You will receive trading alerts here."
6. **Success:** Display green checkmark and "Telegram connected!" message. Save `telegram_chat_id` and set `telegram_enabled = true`.
7. **Failure:** Display "Could not reach your Telegram. Please verify the chat ID and ensure you've started the bot."

#### Business Rules

- BR-034: Disabling Telegram (`telegram_enabled = false`) retains the `telegram_chat_id` for easy re-enablement.
- BR-035: `alert_on_risk_breach` cannot be disabled if the user has live trading enabled. Attempting to disable it shows: "Risk breach alerts are required for live trading accounts."

---

### 3.14 FR-040: Broker Connection Data Model and Tier Limits

**Source:** PRD AU-FR-040 | **Phase:** 1 | **Priority:** P0

#### Description

Broker connections are stored in a dedicated table with encrypted credentials. The number of connections and accounts is limited by the user's subscription tier.

#### Tier Enforcement

| Tier | Max Broker Connections | Max Accounts | Enforced At |
|------|----------------------|-------------|-------------|
| Free | 0 (paper only, no broker) | 1 (internal paper) | Application layer (API endpoint) |
| Trader | 1 | 1 | Application layer |
| Pro | 3 | 5 | Application layer |
| Team | Unlimited | 20+ | Application layer |

#### Processing Logic

When a user attempts to add a broker connection:

1. Backend queries `SELECT COUNT(*) FROM broker_connections WHERE user_id = auth.uid() AND status != 'disconnected'`.
2. Backend retrieves the user's `subscription_tier`.
3. If count >= tier limit, return HTTP 403 with message: "Your [tier] plan supports up to [N] broker connections. Upgrade to [next tier] for more."
4. The response includes an `upgrade_url` field pointing to the billing page.

#### Error Messages by Tier

| Tier | Rejection Message |
|------|------------------|
| Free | "Your Free plan does not include broker connections. Upgrade to Trader ($49/mo) to connect a broker. [Upgrade] [Cancel]" |
| Trader (at 1) | "Your Trader plan supports up to 1 broker connection. Upgrade to Pro ($99/mo) for up to 3 connections. [Upgrade] [Cancel]" |
| Pro (at 3) | "Your Pro plan supports up to 3 broker connections. Upgrade to Team ($199/mo) for unlimited connections. [Upgrade] [Cancel]" |

---

### 3.15 FR-041: Secure Credential Storage (AES-256-GCM)

**Source:** PRD AU-FR-041 | **Phase:** 1 | **Priority:** P0

#### Description

All broker API credentials are encrypted at rest using AES-256-GCM with per-connection key derivation.

#### Processing Logic — Encryption

1. A 256-bit master encryption key is stored in the `BROKER_ENCRYPTION_MASTER_KEY` environment variable (Railway/Vercel encrypted env vars). This key is NEVER stored in the database or source code.
2. When a user saves a broker connection, the system:
   a. Serializes the broker-specific credentials to a JSON string (UTF-8 encoded).
   b. Derives a unique Data Encryption Key (DEK) using HKDF-SHA256: `DEK = HKDF(master_key, salt=None, info=connection_id.encode(), length=32)`.
   c. Generates a cryptographically random 96-bit (12-byte) IV: `iv = os.urandom(12)`.
   d. Encrypts the JSON plaintext with AES-256-GCM using the DEK and IV. The 128-bit GCM authentication tag is appended to the ciphertext automatically.
   e. Stores in the database: `credentials_encrypted` (ciphertext + tag), `credentials_iv` (IV), `credentials_key_id` (version identifier of the master key, e.g., "v1").
3. Decrypted credentials are NEVER logged, NEVER returned in API responses, and NEVER cached (disk or Redis).

#### Processing Logic — Decryption

1. When the system needs broker credentials (e.g., for trade execution or health check):
   a. Read `credentials_encrypted`, `credentials_iv`, and `credentials_key_id` from the database.
   b. Look up the master key version from `credentials_key_id`.
   c. Re-derive the DEK using HKDF with the same parameters.
   d. Decrypt using AES-256-GCM. If the authentication tag does not match (tampering detected), raise `InvalidTag` exception.
   e. Parse the JSON plaintext into a Python dictionary.
   f. Use the credentials for the broker API call.
   g. Securely overwrite the plaintext in memory after use (where supported by the runtime).

#### Processing Logic — Key Rotation

1. When the master key is rotated (new `BROKER_ENCRYPTION_MASTER_KEY` value deployed):
   a. Both the old key (identified by `credentials_key_id = "v1"`) and new key (`"v2"`) are available during the rotation window.
   b. A Celery background task iterates through all `broker_connections` rows.
   c. For each row: decrypt with the old key, re-encrypt with the new key, update `credentials_key_id` to the new version.
   d. Rotation window maximum: 24 hours.
   e. After all rows are re-encrypted, the old key is removed from environment variables.

#### Credential Formats Per Broker

**IBKR:**
```json
{
  "host": "127.0.0.1",
  "port": 4002,
  "client_id": 1,
  "account": "DU1234567",
  "gateway_type": "paper|live"
}
```

**Tradovate:**
```json
{
  "username": "...",
  "password": "...",
  "app_id": "...",
  "app_version": "...",
  "cid": "...",
  "sec": "...",
  "environment": "demo|live"
}
```

**Webull:**
```json
{
  "app_key": "...",
  "app_secret": "...",
  "access_token": "...",
  "refresh_token": "...",
  "device_id": "...",
  "account_id": "..."
}
```

#### Error Handling

| Error Condition | System Action |
|----------------|---------------|
| GCM authentication tag mismatch (tampered data) | Log critical security event, do NOT return credentials, notify admin, mark connection as `error` with `last_error = "Credential integrity check failed"` |
| Master key not found in environment | Application fails to start. Log: "CRITICAL: BROKER_ENCRYPTION_MASTER_KEY not set." |
| Key version mismatch (credentials_key_id not found) | Attempt all known key versions. If none decrypt successfully, mark connection as `error`, notify user: "Your broker connection credentials need to be re-entered." |

---

### 3.16 FR-042: Connection Status Monitoring

**Source:** PRD AU-FR-042 | **Phase:** 1 (basic) / 2 (full) | **Priority:** P1

#### Description

The system monitors broker connection health continuously via background tasks and displays status with color-coded indicators.

#### Processing Logic

1. A Celery periodic task runs every 5 minutes for each broker connection where `status IN ('active', 'expired')`.
2. The health check decrypts the broker credentials (FR-041) and attempts a lightweight API call:
   - **IBKR:** Request account summary via IB Gateway API.
   - **Tradovate:** `GET /account/list` endpoint.
   - **Webull:** `GET /account/profile` endpoint.
3. State transitions:

| Current State | Event | New State | System Action |
|--------------|-------|-----------|---------------|
| active | Health check succeeds | active | Update `last_connected_at = NOW()` |
| active | Health check fails (1st failure) | active | Log warning, schedule retry in 1 minute |
| active | Health check fails (3 consecutive) | error | Set `last_error` with error details, send notification to user: "Your [broker] connection has encountered an error: [error]. Please check your connection." |
| active | Token expired (Tradovate/Webull) | expired | Attempt automatic token refresh (FR-044) |
| expired | Auto-refresh succeeds | active | Update encrypted credentials with new token, clear `last_error`, update `last_connected_at` |
| expired | Auto-refresh fails (3 attempts) | expired | Notify user: "Your [broker] connection requires re-authorization. Please update your credentials." |
| error | User re-authorizes (submits new credentials) | active | Re-encrypt new credentials, clear `last_error`, update `last_connected_at` |
| any | User clicks "Disconnect" | disconnected | Credentials retained but connection marked inactive. No health checks run. |
| disconnected | User clicks "Reconnect" | active | Resume health checks. |

#### Dashboard Status Display

| Status | Visual Indicator | Text |
|--------|-----------------|------|
| active | Green circle (pulsing) | "Connected" |
| expired | Yellow circle | "Token expired — re-authorize" (with "Re-authorize" button) |
| error | Red circle | "Connection error: [last_error]" (with "Retry" and "Edit" buttons) |
| disconnected | Gray circle | "Disconnected" (with "Reconnect" button) |

---

### 3.17 FR-043: Add Broker Connection Flow

**Source:** PRD AU-FR-043 | **Phase:** 1 | **Priority:** P0

#### Description

Users can add new broker connections by selecting a broker type, entering credentials, testing the connection, and saving.

#### Processing Logic

1. User navigates to `/settings/brokers` and clicks "Add Broker Connection."
2. System checks tier limits (FR-040). If at limit, display the tier-specific upgrade prompt and stop.
3. User selects broker type from a card-based selection: Interactive Brokers, Tradovate, Webull.
4. System displays the broker-specific connection form:

**IBKR Form:**
| Field | Type | Validation | Default | Help Text |
|-------|------|-----------|---------|-----------|
| Display name | string | 3-50 chars | "My IBKR Account" | "A friendly name for this connection" |
| Gateway host | string | Valid IP or hostname | "127.0.0.1" | "IP address of your IB Gateway instance" |
| Gateway port | integer | 1024-65535 | 4002 (paper) / 4001 (live) | "Port configured in IB Gateway" |
| Client ID | integer | 1-999 | 1 | "Must be unique per Gateway connection" |
| Account number | string | Matches `^[A-Z]{1,2}\d{5,10}$` | "" | "Your IBKR account number (e.g., DU1234567)" |
| Account type | radio | "Paper" or "Live" | "Paper" | Sets `is_paper` flag |

**Tradovate Form:**
| Field | Type | Validation | Default | Help Text |
|-------|------|-----------|---------|-----------|
| Display name | string | 3-50 chars | "My Tradovate Account" | "A friendly name for this connection" |
| Username | string | Non-empty | "" | "Your Tradovate username" |
| Password | password | Non-empty | "" | "Your Tradovate password" |
| App ID | string | Non-empty | "" | "From Tradovate API dashboard" |
| App Version | string | Non-empty | "" | "From Tradovate API dashboard" |
| CID | string | Non-empty | "" | "Customer ID from Tradovate" |
| Secret | password | Non-empty | "" | "API secret from Tradovate" |
| Environment | radio | "Demo" or "Live" | "Demo" | Sets `is_paper` flag |

**Webull Form:**
| Field | Type | Validation | Default | Help Text |
|-------|------|-----------|---------|-----------|
| Display name | string | 3-50 chars | "My Webull Account" | "A friendly name for this connection" |
| App Key | string | Non-empty | "" | "From Webull developer portal" |
| App Secret | password | Non-empty | "" | "From Webull developer portal" |
| Device ID | string | Auto-generated UUID | generated | "Auto-generated unique device identifier" |

5. User fills in the form and clicks "Test Connection."
6. Backend receives the credentials, does NOT encrypt yet. It attempts a test API call to the broker:
   - **IBKR:** Connect to Gateway at `host:port`, request account info.
   - **Tradovate:** Authenticate with username/password/app credentials, request account list.
   - **Webull:** Authenticate with app key/secret, request account profile.
7. **Test success:** Display: "Connection successful! Account: [account_id], Balance: $[balance]." The "Save" button becomes enabled.
8. **Test failure:** Display broker-specific error:
   - IBKR: "IB Gateway is not running or not reachable at [host]:[port]."
   - Tradovate: "Invalid username or password."
   - Webull: "App secret has expired. Generate a new one in the Webull developer portal."
9. On "Save," backend encrypts credentials (FR-041) and stores the connection record.
10. User can optionally edit the display name.

#### Business Rules

- BR-036: A connection MUST be tested successfully before it can be saved.
- BR-037: Credentials are NOT persisted until the user explicitly clicks "Save" after a successful test.
- BR-038: The test connection attempt has a 30-second timeout.
- BR-039: Display name must be unique per user (case-insensitive). Error: "You already have a connection named '[name]'. Please choose a different name."

---

### 3.18 FR-044: Broker Credential Refresh/Rotation

**Source:** PRD AU-FR-044 | **Phase:** 2 | **Priority:** P0

#### Description

The system handles broker credential expiry and rotation automatically where the broker API supports it.

#### Processing Logic

**Tradovate Token Refresh:**
1. Tradovate access tokens expire every 60 minutes.
2. A Celery task checks all active Tradovate connections every 55 minutes (5 minutes before expected expiry).
3. The task decrypts the stored credentials, uses the refresh token to request a new access token from Tradovate API.
4. On success: re-encrypt the updated credentials (with new access token) and update `last_connected_at`.
5. On failure: retry 2 more times at 1-minute intervals.
6. After 3 failures: set status to `expired`, notify user: "Your Tradovate connection requires re-authorization."

**Webull Token Refresh:**
1. Webull app secrets expire every 24 hours to 7 days (configurable in Webull portal).
2. The system CANNOT auto-refresh Webull app secrets.
3. When a Webull health check detects an expired secret (API returns 401), status transitions to `expired`.
4. User notification: "Your Webull connection has expired. Please generate a new app secret in the Webull developer portal and update your connection."

**IBKR:**
1. IBKR uses a persistent socket connection via IB Gateway. No token rotation is required.
2. If IB Gateway restarts or the socket disconnects, the system automatically reconnects on the next health check cycle (within 5 minutes).

---

### 3.19 FR-050/051: Row Level Security (RLS) Policies

**Source:** PRD AU-FR-050, AU-FR-051 | **Phase:** 1 | **Priority:** P0

#### Description

The system enforces Row Level Security on ALL user-owned tables in PostgreSQL. RLS is the last line of defense — even if application code has a bug, RLS prevents cross-user data leakage.

#### Tables and Policies

Every table listed below MUST have RLS enabled AND forced (preventing bypass by table owners):

| Table | SELECT Policy | INSERT Policy | UPDATE Policy | DELETE Policy | Phase |
|-------|--------------|--------------|--------------|--------------|-------|
| users | `id = auth.uid()` | N/A (trigger) | `id = auth.uid()` AND `id = auth.uid()` (WITH CHECK) | N/A (soft delete) | 1 |
| broker_connections | `user_id = auth.uid()` | `user_id = auth.uid()` | `user_id = auth.uid()` both USING and WITH CHECK | `user_id = auth.uid()` | 1 |
| trades | `user_id = auth.uid()` | `user_id = auth.uid()` | `user_id = auth.uid()` both | `user_id = auth.uid()` | 1 |
| signals | `user_id = auth.uid()` | `user_id = auth.uid()` | `user_id = auth.uid()` both | `user_id = auth.uid()` | 1 |
| trendlines | `user_id = auth.uid()` | `user_id = auth.uid()` | `user_id = auth.uid()` both | `user_id = auth.uid()` | 1 |
| playbooks | `user_id = auth.uid()` | `user_id = auth.uid()` | `user_id = auth.uid()` both | `user_id = auth.uid()` | 1 |
| journal_entries | `user_id = auth.uid()` | `user_id = auth.uid()` | `user_id = auth.uid()` both | `user_id = auth.uid()` | 1 |
| api_keys | `user_id = auth.uid()` | `user_id = auth.uid()` | `user_id = auth.uid()` both | `user_id = auth.uid()` | 2 |
| audit_logs | `user_id = auth.uid()` (SELECT only) | `true` (service role inserts) | N/A (append-only) | N/A (append-only) | 1 |
| teams | `id IN (SELECT team_id FROM users WHERE id = auth.uid())` | Team tier check | `owner_id = auth.uid()` OR team_admin | N/A | 3 |
| team_members | `team_id IN (SELECT team_id FROM users WHERE id = auth.uid())` | Team admin check | Team admin check | Team admin check | 3 |

#### SQL Implementation Pattern

For each user-owned table, the following SQL pattern is applied:

```sql
-- Enable and force RLS
ALTER TABLE public.{table_name} ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.{table_name} FORCE ROW LEVEL SECURITY;

-- SELECT: own rows only
CREATE POLICY "Users can view own {table_name}"
  ON public.{table_name} FOR SELECT
  USING (user_id = auth.uid());

-- INSERT: own user_id only
CREATE POLICY "Users can insert own {table_name}"
  ON public.{table_name} FOR INSERT
  WITH CHECK (user_id = auth.uid());

-- UPDATE: own rows only, cannot change user_id
CREATE POLICY "Users can update own {table_name}"
  ON public.{table_name} FOR UPDATE
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

-- DELETE: own rows only
CREATE POLICY "Users can delete own {table_name}"
  ON public.{table_name} FOR DELETE
  USING (user_id = auth.uid());
```

#### Business Rules

- BR-040: RLS MUST be enabled from Phase 1, even when there is only a single user. This ensures RLS is tested and operational before multi-user access.
- BR-041: `FORCE ROW LEVEL SECURITY` MUST be applied to prevent the table owner role from bypassing policies.
- BR-042: Direct SQL queries without an authenticated JWT context (i.e., without `auth.uid()` set) MUST return zero rows.
- BR-043: The INSERT WITH CHECK on `user_id = auth.uid()` prevents a user from inserting a row with another user's `user_id`.

---

### 3.20 FR-052: Admin Override Policies

**Source:** PRD AU-FR-052 | **Phase:** 3 | **Priority:** P0

#### Description

Admin users have controlled, read-only access to all user data for support purposes. Admin write access is limited to role assignment, subscription tier changes, and account suspension.

#### Processing Logic

1. Admin SELECT policies extend the base RLS policies by adding an OR clause:
   ```sql
   USING (
     user_id = auth.uid()
     OR EXISTS (
       SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin'
     )
   )
   ```
2. Admin UPDATE/DELETE policies remain restricted to the user's own data. Admins CANNOT modify other users' trades, journal entries, or playbooks.
3. Admin write access is limited to specific admin endpoints:
   - `PATCH /api/admin/users/:id/role` — Change user role.
   - `PATCH /api/admin/users/:id/tier` — Change subscription tier.
   - `POST /api/admin/users/:id/suspend` — Suspend user account.
4. All admin access to user data is logged in `audit_logs` with: `admin_user_id`, `target_user_id`, `action`, `timestamp`, `ip_address`.
5. Admin actions require re-authentication (password confirmation) if the admin's session is older than 15 minutes.

---

### 3.21 FR-053: Service Role Access

**Source:** PRD AU-FR-053 | **Phase:** 1 | **Priority:** P0

#### Description

Background tasks (Celery workers) that need cross-user access use the Supabase service role key, which bypasses RLS entirely.

#### Business Rules

- BR-044: The `SUPABASE_SERVICE_ROLE_KEY` is ONLY used in backend Celery workers — NEVER exposed to the frontend, NEVER used in API endpoints that handle user requests.
- BR-045: Service role operations are logged separately with the task name and execution context.
- BR-046: Service role usage is restricted to: broker health checks across all connections, data export generation, soft-delete cleanup, encryption key rotation, and audit log maintenance.

---

### 3.22 FR-060/061/062: Role-Based Access Control

**Source:** PRD AU-FR-060, AU-FR-061, AU-FR-062 | **Phase:** 1 (basic) / 2 (admin) / 3 (team) | **Priority:** P0

#### Description

The system enforces role-based access control with four roles: `user`, `admin`, `team_admin`, `team_member`.

#### Role Definitions

| Role | Scope | Phase |
|------|-------|-------|
| user | Own data only. Can manage own profile, trades, playbooks, connections, journal entries, API keys. | 1 |
| admin | All data (read-only) + user management. Can manage roles, subscription tiers, suspend accounts. | 2 |
| team_admin | Own data + team management. Can manage team members, shared playbooks, view team analytics. | 3 |
| team_member | Own data + shared resources. Read access to shared team playbooks, aggregated team analytics. | 3 |

#### Permission Matrix

| Resource | user | admin | team_admin | team_member |
|----------|------|-------|-----------|-------------|
| Own profile (CRUD) | Yes | Yes | Yes | Yes |
| Own trades (CRUD) | Yes | Read-only | Yes | Yes |
| Own playbooks (CRUD) | Yes | Read-only | Yes | Yes |
| Own broker connections (CRUD) | Yes | Read-only | Yes | Yes |
| Own journal entries (CRUD) | Yes | Read-only | Yes | Yes |
| Own API keys (CRUD) | Yes | Read-only | Yes | Yes |
| Other users' data | **No** | Read-only | **No** | **No** |
| User role management | **No** | Yes | **No** | **No** |
| Subscription tier management | **No** | Yes | **No** | **No** |
| Account suspension | **No** | Yes | **No** | **No** |
| Team creation | **No** | Yes | Yes | **No** |
| Team member management | **No** | Yes | Yes (own team) | **No** |
| Shared playbooks (read) | **No** | Yes | Yes (own team) | Yes (own team) |
| Shared playbooks (write) | **No** | **No** | Yes (own team) | **No** |
| Team analytics (read) | **No** | Yes | Yes (own team) | Aggregated only |
| System configuration | **No** | Yes | **No** | **No** |

#### Role Assignment Rules

1. New users: `role = 'user'` (default, set by database trigger).
2. Admin role: assigned ONLY by another admin or via direct database `UPDATE` (bootstrap for first admin).
3. Team_admin role: assigned automatically when a user creates a team (Phase 3).
4. Team_member role: assigned when a user accepts a team invitation (Phase 3).
5. A user can have at most ONE role. `team_admin` and `team_member` are mutually exclusive.
6. All role changes are logged in the audit log.

#### Error Handling for Unauthorized Access

| Scenario | HTTP Status | Response |
|----------|-------------|---------|
| User accesses admin endpoint | 403 | `{"error": "forbidden", "message": "You do not have permission to perform this action."}` |
| User accesses another user's resource | 200 (empty) | RLS returns zero rows. No error — the resource appears to not exist. |
| Team member attempts to edit shared playbook | 403 | `{"error": "forbidden", "message": "Only team admins can modify shared playbooks."}` |
| Non-team user accesses team endpoints | 403 | `{"error": "forbidden", "message": "You are not a member of any team."}` |

---

### 3.23 FR-070-074: Team / Organization Support (Phase 3)

**Source:** PRD AU-FR-070 through AU-FR-074 | **Phase:** 3 | **Priority:** P0

#### Description

The system supports team creation, member invitations, role management, shared playbooks, and aggregated team analytics for users on the Team subscription tier.

#### FR-070: Team Data Model

See Data Specifications (section 4) for the `teams` and `team_members` table schemas.

#### FR-071: Team Creation Flow

1. User with `subscription_tier = 'team'` navigates to `/settings/team` and clicks "Create Team."
2. User enters team name (3-100 characters, alphanumeric + spaces + hyphens).
3. System generates a URL-safe slug: lowercase, spaces replaced with hyphens, special characters removed, truncated to 100 chars.
4. System creates the `teams` row with `owner_id = auth.uid()`.
5. System sets the user's `team_id` and `team_role = 'team_admin'`.
6. System creates a `team_members` row with `role = 'team_admin'`, `invitation_status = 'accepted'`, `joined_at = NOW()`.

**Error handling:**
- Slug collision: "A team with a similar name already exists. Please choose a different name."
- User already in a team: "You are already a member of [team_name]. Leave that team before creating a new one."
- Not on Team tier: "Team creation requires the Team plan ($199/mo). [Upgrade]"

#### FR-072: Member Invitation Flow

1. Team admin navigates to `/settings/team/members` and clicks "Invite Member."
2. Admin enters the invitee's email address.
3. System validates:
   - Email format is valid.
   - Team has not reached `max_members` limit. Error: "Your team has reached its maximum of [N] members."
   - Email does not already have a pending or accepted invitation. Error: "This email already has a pending invitation." or "This user is already a team member."
4. System creates a `team_members` row: `invitation_status = 'pending'`, generates unique `invitation_token`, sets `invitation_expires_at = NOW() + 7 days`.
5. System sends invitation email: "You've been invited to join [team_name] on TrendEdge by [admin_name]. [Accept Invitation]"
6. Invitation link: `https://app.trendedge.io/teams/join?token=[invitation_token]`

**Invitee flow (existing TrendEdge user):**
1. Clicks link, logs in if not already authenticated.
2. Sees: "You've been invited to join [team_name] by [admin_name]. [Accept] [Decline]"
3. On Accept: `invitation_status` -> `accepted`, user's `team_id` and `team_role = 'team_member'` are set, `joined_at = NOW()`.
4. On Decline: `invitation_status` -> `declined`.

**Invitee flow (new user):**
1. Clicks link, directed to `/register` with `?invitation_token=[token]` preserved.
2. After registration and email verification, the invitation acceptance flow triggers automatically.

**Admin actions:**
- Revoke pending invitation: `invitation_status` -> `revoked`, link becomes invalid.
- Invitation expires after 7 days: link shows "This invitation has expired. Please ask your team admin to send a new one."

#### FR-073: Team Role Management

1. Team admin can promote a member to `team_admin` (co-admin).
2. Team admin can demote a `team_admin` to `team_member` (except the team owner).
3. Team admin can remove members from the team. On removal: member's `team_id` and `team_role` are set to null; member retains all their own data.
4. The team owner CANNOT be removed or demoted. The owner CAN transfer ownership to another team admin.

#### FR-074: Shared Playbooks and Team Analytics

**Shared Playbooks:**
1. Team admin marks a personal playbook as "shared with team" via a toggle on the playbook detail page.
2. Shared playbooks appear in all team members' playbook lists with a "Shared" badge.
3. Team members can view and use shared playbooks for trade classification but CANNOT edit, duplicate-and-modify, or delete them.
4. Team members can create their own private playbooks.

**Team Analytics:**
1. Team admin views: total team P&L, win rate, average R-multiple, per-member performance summary (name, trade count, P&L, win rate), playbook performance across the team.
2. Team members view: own analytics + aggregated team benchmarks (no individual member data visible).
3. All aggregations are computed server-side; raw data never leaves the RLS boundary.

---

### 3.24 FR-080/081: Onboarding Wizard and Paper Trading (Phase 3)

**Source:** PRD AU-FR-080, AU-FR-081 | **Phase:** 3 | **Priority:** P0

#### Description

New users are guided through a 4-step onboarding wizard on first login. All new users default to paper trading mode.

#### Wizard Steps

**Step 1: Welcome & Profile**
- Header: "Welcome to TrendEdge! Let's set up your trading system."
- Collect: display name, timezone (auto-detected from browser's `Intl.DateTimeFormat().resolvedOptions().timeZone`, editable via dropdown).
- "Skip" link available.

**Step 2: Trading Preferences**
- Header: "What do you trade?"
- Collect: default instruments (multi-select card grid: ES, NQ, YM, CL, GC, PL, SI, HG, NG, ZB, ZN, 6E), default timeframe (radio buttons), risk per trade % (slider).
- Each instrument card shows: symbol, full name, tick size, tick value, margin requirement.
- "Skip" link applies defaults.

**Step 3: Broker Connection**
- Header: "Connect your broker to start trading."
- Options: "Connect Interactive Brokers", "Connect Tradovate", "Connect Webull", "Start with paper trading only."
- Selecting "Paper trading only" skips to Step 4.
- Selecting a broker opens the connection flow (FR-043) inline within the wizard.

**Step 4: First Playbook**
- Header: "Set up your first trading playbook."
- Options: "Use A+ Trendline Break (recommended)", "Use Standard Trendline Break", "Create custom playbook", "Skip for now."
- If a preset is selected, the system creates the playbook with default criteria.
- Final message: "You're all set! Your paper trading account is active. We recommend at least 60 days of paper trading before going live."

#### Progress Tracking

- Progress bar at top: "Step 1 of 4", "Step 2 of 4", etc.
- "Skip setup" link is available on every step. Clicking it sets `onboarding_completed = true` and `onboarding_step` to the current step number.
- Users who skip or do not complete onboarding see a persistent, dismissible banner on the dashboard: "Complete your setup to get the most out of TrendEdge. [Continue setup]"
- Clicking "Continue setup" resumes the wizard at `onboarding_step + 1`.

---

### 3.25 FR-090: Data Export

**Source:** PRD AU-FR-090 | **Phase:** 3 | **Priority:** P0

#### Description

Users can export all their data in machine-readable format (JSON and CSV) as a ZIP file.

#### Processing Logic

1. User navigates to `/settings/account` and clicks "Export my data."
2. System displays: "We'll prepare a download of all your TrendEdge data. This may take a few minutes for large accounts."
3. Frontend sends `POST /api/account/export`.
4. Backend enqueues a Celery task to collect all user data.
5. The Celery task collects:
   - Profile information (JSON)
   - All trades with journal entries (CSV + JSON)
   - All playbooks with criteria (JSON)
   - All trendline detections (JSON)
   - All signals (JSON)
   - Settings and preferences (JSON)
   - API key metadata — name, prefix, permissions, creation date — but NO secrets (JSON)
6. Data is packaged into a ZIP file named `trendedge-export-{user_id}-{YYYY-MM-DD}.zip`.
7. ZIP is uploaded to Cloudflare R2 at `exports/{user_id}/{filename}` with a 24-hour TTL.
8. User receives an email: "Your TrendEdge data export is ready. [Download] This link expires in 24 hours."
9. The download link is a signed R2 URL valid for 24 hours.
10. After 24 hours, the file is automatically deleted from R2.

#### Business Rules

- BR-047: Rate limit: 1 export request per 24 hours per user.
- BR-048: Broker credentials are NEVER included in the export.
- BR-049: The export task runs on a Celery worker with service role access to read all user data.

#### Error Handling

| Error Condition | User-Facing Message |
|----------------|---------------------|
| Export already requested within 24 hours | "You've already requested a data export today. Please try again tomorrow." |
| Export task fails | Email: "Your data export could not be completed. Please try again or contact support." |
| R2 upload fails | Retry up to 3 times. On final failure, notify user via email. |

---

### 3.26 FR-091: Account Deletion

**Source:** PRD AU-FR-091 | **Phase:** 3 | **Priority:** P0

#### Description

Users can permanently delete their account and all associated data, with a 30-day grace period for recovery.

#### Processing Logic

1. User navigates to `/settings/account` and clicks "Delete my account."
2. System displays a confirmation screen with:
   - "This action is permanent and cannot be undone."
   - "All your data will be deleted, including: trades, journal entries, playbooks, trendlines, broker connections, API keys, and settings."
   - "Active broker connections will be disconnected."
   - "If you have an active subscription, it will be cancelled immediately with no refund for the current billing period."
3. User must type the word "DELETE" (case-sensitive) in a text input to confirm.
4. User must re-authenticate: enter password, or confirm via OAuth re-consent.
5. On confirmation, the system executes the following in order:
   a. Cancel any active subscription via Stripe API. [Cross-reference: see FSD-011 for billing details]
   b. Disconnect all broker connections (revoke OAuth tokens where possible, e.g., Tradovate, Webull).
   c. Revoke all API keys (`is_active = false`).
   d. Soft-delete the `public.users` row: set `deleted_at = NOW()`.
   e. Sign out all active sessions.
6. Send confirmation email: "Your TrendEdge account has been deleted. If this was a mistake, contact support within 30 days to restore your account."
7. **Grace period (30 days):** All data is retained with `deleted_at` timestamps. The user cannot log in. Support can restore the account by clearing `deleted_at` and re-enabling the `auth.users` row.
8. **After 30 days:** A scheduled Celery task runs daily and hard-deletes all data for accounts where `deleted_at < NOW() - INTERVAL '30 days'`:
   - Hard delete from all tables: trades, journal_entries, playbooks, trendlines, signals, broker_connections, api_keys, audit_logs.
   - Delete avatar from R2 storage.
   - Delete the `public.users` row.
   - Delete the `auth.users` row via Supabase admin API.

#### Business Rules

- BR-050: The word "DELETE" must be typed exactly (case-sensitive, no extra whitespace) to proceed.
- BR-051: Re-authentication is required regardless of how recently the user logged in.
- BR-052: Soft-deleted accounts cannot log in. The login endpoint returns the generic "Invalid email or password" message (no indication of deletion).
- BR-053: Support restoration within the 30-day window re-enables all data and sessions. The user must set a new password.

---

### 3.27 FR-100: API Key Management

**Source:** PRD AU-FR-100 | **Phase:** 2 | **Priority:** P0

#### Description

Users can create, view, and revoke API keys for authenticating webhook integrations (primarily TradingView).

#### API Key Generation

1. User navigates to `/settings/api-keys` and clicks "Create API Key."
2. User fills in:
   - **Name** (required): 3-50 characters. E.g., "TradingView Alerts".
   - **Expiration** (optional): 30 days, 60 days, 90 days, or "Never expires."
   - **Permissions** (multi-select): `webhook:write`, `trades:read`.
3. Backend generates a cryptographically random 32-byte key using `secrets.token_hex(32)`.
4. Key is prefixed: `te_live_` (if user is in live mode) or `te_test_` (if user is in paper mode).
5. Full key format example: `te_live_a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6` (40 characters total: 8-char prefix + 32-char hex).
6. Backend stores ONLY the SHA-256 hash of the full key in `api_keys.key_hash`. The plaintext key is NEVER stored.
7. The first 8 characters after the prefix are stored as `key_prefix` for display: `a1b2c3d4`.
8. The plaintext key is displayed to the user ONCE in a copyable field.
9. Display: "Your API key has been created. Copy it now — you won't be able to see it again."
10. A "Copy" button copies the key to clipboard with confirmation toast: "API key copied to clipboard."
11. After the user closes the dialog, the plaintext key is no longer accessible. The key list shows only name, prefix, permissions, and usage stats.

#### API Key Validation (on webhook receipt)

1. Incoming request includes the API key in `X-API-Key` header (preferred) or `api_key` query parameter.
2. Backend computes SHA-256 hash of the provided key.
3. Backend looks up the hash in `api_keys.key_hash`.
4. Validation checks (in order):
   - Key exists: if not, return HTTP 401 `{"error": "invalid_api_key", "message": "Invalid API key."}`.
   - Key is active (`is_active = true`): if not, return HTTP 401 `{"error": "revoked_api_key", "message": "API key has been revoked."}`.
   - Key is not expired (`expires_at IS NULL OR expires_at > NOW()`): if expired, return HTTP 401 `{"error": "expired_api_key", "message": "API key has expired."}`.
   - Key has required permission for the endpoint: if not, return HTTP 403 `{"error": "insufficient_permissions", "message": "Insufficient permissions."}`.
5. On valid key: update `last_used_at = NOW()` and increment `request_count`. Set the RLS context to the key's `user_id`. Proceed with request processing.

#### Key Management Actions

- **Revoke:** User clicks "Revoke" on an active key. Confirmation modal: "Revoke API key '[name]'? Any integrations using this key will stop working. [Cancel] [Revoke]". Sets `is_active = false`.
- **Delete:** User clicks "Delete" on a revoked key. Removes the record entirely.
- **View usage:** Displays `request_count`, `last_used_at`, and a 30-day usage chart (requests per day).

#### Tier Limits

| Tier | Max API Keys |
|------|-------------|
| Free | 1 |
| Trader | 5 |
| Pro | 20 |
| Team | 50 |

Exceeding the limit: "Your [tier] plan supports up to [N] API keys. Upgrade to [next tier] for more. [Upgrade]"

---

### 3.28 FR-101: Webhook URL Generation

**Source:** PRD AU-FR-101 | **Phase:** 2 | **Priority:** P0

#### Description

Each API key generates a corresponding webhook URL for TradingView integration.

#### Processing Logic

1. After API key creation, the system displays the webhook URL: `https://api.trendedge.io/v1/webhooks/tradingview?api_key=te_live_...`
2. An alternative method (preferred for security) is to send the API key in the `X-API-Key` header and use the base URL: `https://api.trendedge.io/v1/webhooks/tradingview`.
3. The webhook endpoint accepts POST requests with JSON payload.
4. **Optional HMAC validation:** If the user configures a webhook secret (stored encrypted alongside the API key), the system validates the `X-Signature` header using HMAC-SHA256 of the request body.
5. Payload processing: [Cross-reference: see FSD-010 for integration details on TradingView webhook payload format and processing]

---

## 4. Data Specifications

### 4.1 Users Table

**Table:** `public.users`

| Column | Type | Constraints | Default | Description |
|--------|------|------------|---------|-------------|
| id | UUID | PK, FK -> auth.users(id) ON DELETE CASCADE | N/A | Matches Supabase auth user ID |
| email | TEXT | NOT NULL | from auth | User's email address |
| display_name | TEXT | nullable, 2-50 chars | null | Display name |
| avatar_url | TEXT | nullable | null | R2 URL for avatar image |
| timezone | TEXT | NOT NULL, valid IANA | 'America/New_York' | User's timezone |
| subscription_tier | TEXT | NOT NULL, CHECK IN ('free','trader','pro','team') | 'free' | Current subscription tier |
| settings | JSONB | NOT NULL | See below | User preferences blob |
| role | TEXT | NOT NULL, CHECK IN ('user','admin') | 'user' | Platform role |
| team_id | UUID | nullable, FK -> teams(id) ON DELETE SET NULL | null | Team membership (Phase 3) |
| team_role | TEXT | nullable, CHECK IN ('team_admin','team_member') | null | Role within team (Phase 3) |
| onboarding_completed | BOOLEAN | NOT NULL | false | Whether wizard is complete |
| onboarding_step | INTEGER | NOT NULL | 0 | Last completed wizard step |
| created_at | TIMESTAMPTZ | NOT NULL | NOW() | Account creation timestamp |
| updated_at | TIMESTAMPTZ | NOT NULL | NOW() | Last profile update |
| last_login_at | TIMESTAMPTZ | nullable | null | Most recent login |
| deleted_at | TIMESTAMPTZ | nullable | null | Soft delete timestamp |

**Default settings JSONB:**
```json
{
  "trading_preferences": {
    "default_instruments": [],
    "default_timeframe": "4H",
    "risk_per_trade_percent": 1.0,
    "max_daily_loss": 500.00,
    "max_concurrent_positions": 3,
    "paper_trading_mode": true
  },
  "notification_preferences": {
    "telegram_enabled": false,
    "email_digest": "daily",
    "alert_on_fill": true,
    "alert_on_trendline": true,
    "alert_on_risk_breach": true
  },
  "display_preferences": {
    "theme": "system",
    "currency_display": "USD",
    "date_format": "MM/DD/YYYY",
    "compact_mode": false
  }
}
```

### 4.2 Broker Connections Table

**Table:** `public.broker_connections`

| Column | Type | Constraints | Default | Description |
|--------|------|------------|---------|-------------|
| id | UUID | PK | gen_random_uuid() | Connection identifier |
| user_id | UUID | NOT NULL, FK -> users(id) ON DELETE CASCADE, INDEX | N/A | Owner |
| broker_type | TEXT | NOT NULL, CHECK IN ('ibkr','tradovate','webull','rithmic') | N/A | Broker type |
| display_name | TEXT | NOT NULL | N/A | User-defined name |
| credentials_encrypted | BYTEA | NOT NULL | N/A | AES-256-GCM encrypted credentials |
| credentials_iv | BYTEA | NOT NULL | N/A | Initialization vector |
| credentials_key_id | TEXT | NOT NULL | N/A | Master key version reference |
| status | TEXT | NOT NULL, CHECK IN ('active','expired','error','disconnected') | 'disconnected' | Connection health status |
| last_connected_at | TIMESTAMPTZ | nullable | null | Last successful health check |
| last_error | TEXT | nullable | null | Most recent error message |
| account_id | TEXT | nullable | null | Broker-specific account identifier |
| is_paper | BOOLEAN | NOT NULL | true | Paper vs. live account |
| created_at | TIMESTAMPTZ | NOT NULL | NOW() | Creation timestamp |
| updated_at | TIMESTAMPTZ | NOT NULL | NOW() | Last update timestamp |

### 4.3 API Keys Table

**Table:** `public.api_keys`

| Column | Type | Constraints | Default | Description |
|--------|------|------------|---------|-------------|
| id | UUID | PK | gen_random_uuid() | Key identifier |
| user_id | UUID | NOT NULL, FK -> users(id) ON DELETE CASCADE, INDEX | N/A | Owner |
| name | TEXT | NOT NULL, 3-50 chars | N/A | User-defined key name |
| key_prefix | TEXT | NOT NULL, 8 chars | N/A | Visible portion of key |
| key_hash | TEXT | NOT NULL, UNIQUE, INDEX | N/A | SHA-256 hash of full key |
| permissions | TEXT[] | NOT NULL | '{}' | Array of permission strings |
| last_used_at | TIMESTAMPTZ | nullable | null | Last API call using this key |
| expires_at | TIMESTAMPTZ | nullable | null | Expiration (null = never) |
| is_active | BOOLEAN | NOT NULL | true | Whether key is active |
| created_at | TIMESTAMPTZ | NOT NULL | NOW() | Creation timestamp |
| request_count | BIGINT | NOT NULL | 0 | Total requests processed |

### 4.4 Teams Table (Phase 3)

**Table:** `public.teams`

| Column | Type | Constraints | Default | Description |
|--------|------|------------|---------|-------------|
| id | UUID | PK | gen_random_uuid() | Team identifier |
| name | TEXT | NOT NULL, 3-100 chars | N/A | Team display name |
| slug | TEXT | NOT NULL, UNIQUE | N/A | URL-safe slug |
| owner_id | UUID | NOT NULL, FK -> users(id) | N/A | Team creator/owner |
| max_members | INTEGER | NOT NULL | 5 | Maximum allowed members |
| settings | JSONB | NOT NULL | '{}' | Team configuration |
| created_at | TIMESTAMPTZ | NOT NULL | NOW() | Creation timestamp |
| updated_at | TIMESTAMPTZ | NOT NULL | NOW() | Last update timestamp |

### 4.5 Team Members Table (Phase 3)

**Table:** `public.team_members`

| Column | Type | Constraints | Default | Description |
|--------|------|------------|---------|-------------|
| id | UUID | PK | gen_random_uuid() | Record identifier |
| team_id | UUID | NOT NULL, FK -> teams(id) ON DELETE CASCADE, INDEX | N/A | Team reference |
| user_id | UUID | nullable, FK -> users(id) ON DELETE CASCADE, INDEX | null | User reference (null for pending invitations to non-users) |
| role | TEXT | NOT NULL, CHECK IN ('team_admin','team_member') | 'team_member' | Role within team |
| joined_at | TIMESTAMPTZ | nullable | null | When user accepted invitation |
| invited_by | UUID | FK -> users(id) | N/A | Who sent the invitation |
| invitation_status | TEXT | NOT NULL, CHECK IN ('pending','accepted','declined','revoked') | 'pending' | Invitation state |
| invitation_email | TEXT | NOT NULL | N/A | Invitee email address |
| invitation_token | TEXT | UNIQUE, INDEX | N/A | Unique token for invitation link |
| invitation_expires_at | TIMESTAMPTZ | nullable | null | When invitation expires |

### 4.6 Audit Logs Table

**Table:** `public.audit_logs`

| Column | Type | Constraints | Default | Description |
|--------|------|------------|---------|-------------|
| id | UUID | PK | gen_random_uuid() | Log entry identifier |
| user_id | UUID | FK -> users(id) ON DELETE SET NULL, INDEX | null | Acting user (null for system events) |
| event_type | TEXT | NOT NULL, INDEX | N/A | Event type identifier |
| event_data | JSONB | NOT NULL | '{}' | Event-specific data |
| ip_address | INET | nullable | null | Source IP address |
| user_agent | TEXT | nullable | null | Browser/client user agent |
| created_at | TIMESTAMPTZ | NOT NULL, INDEX | NOW() | Event timestamp |

**Audit log event types:**
`user_registered`, `login_success`, `login_failure`, `password_reset_requested`, `password_changed`, `email_changed`, `broker_connection_added`, `broker_connection_removed`, `api_key_created`, `api_key_revoked`, `role_changed`, `account_deleted`, `admin_data_access`, `session_revoked`, `rate_limit_triggered`, `paper_mode_changed`, `team_created`, `team_member_invited`, `team_member_joined`, `team_member_removed`

### 4.7 Database Indexes

```sql
CREATE INDEX idx_broker_connections_user_id ON public.broker_connections(user_id);
CREATE INDEX idx_broker_connections_status ON public.broker_connections(status);
CREATE INDEX idx_api_keys_user_id ON public.api_keys(user_id);
CREATE INDEX idx_api_keys_key_hash ON public.api_keys(key_hash);
CREATE INDEX idx_api_keys_is_active ON public.api_keys(is_active);
CREATE INDEX idx_team_members_team_id ON public.team_members(team_id);
CREATE INDEX idx_team_members_user_id ON public.team_members(user_id);
CREATE INDEX idx_team_members_invitation_token ON public.team_members(invitation_token);
CREATE INDEX idx_audit_logs_user_id ON public.audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON public.audit_logs(event_type);
CREATE INDEX idx_audit_logs_created_at ON public.audit_logs(created_at);
CREATE INDEX idx_users_team_id ON public.users(team_id);
CREATE INDEX idx_users_deleted_at ON public.users(deleted_at);
```

### 4.8 Database Trigger: New User Setup

```sql
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.users (id, email, subscription_tier, settings, role, created_at, updated_at)
  VALUES (
    NEW.id,
    NEW.email,
    'free',
    '{
      "trading_preferences": {
        "default_instruments": [],
        "default_timeframe": "4H",
        "risk_per_trade_percent": 1.0,
        "max_daily_loss": 500.00,
        "max_concurrent_positions": 3,
        "paper_trading_mode": true
      },
      "notification_preferences": {
        "telegram_enabled": false,
        "email_digest": "daily",
        "alert_on_fill": true,
        "alert_on_trendline": true,
        "alert_on_risk_breach": true
      },
      "display_preferences": {
        "theme": "system",
        "currency_display": "USD",
        "date_format": "MM/DD/YYYY",
        "compact_mode": false
      }
    }'::jsonb,
    'user',
    NOW(),
    NOW()
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
```

---

## 5. API Specifications

### 5.1 Authentication Endpoints (Public)

#### POST /auth/register

**Phase:** 1 | **Auth:** None | **Rate Limit:** 5/IP/hour

**Request:**
```json
{
  "email": "user@example.com",
  "password": "SecureP@ss1"
}
```

**Response 201 (Success):**
```json
{
  "user": {
    "id": "uuid",
    "email": "user@example.com",
    "email_verified": false
  },
  "session": {
    "access_token": "jwt...",
    "refresh_token": "opaque...",
    "expires_in": 900,
    "token_type": "bearer"
  },
  "message": "Check your email to verify your account."
}
```

**Response 200 (Production — email exists or not):**
```json
{
  "message": "If this email is not already registered, you will receive a verification email."
}
```

**Response 422 (Validation Error):**
```json
{
  "error": "validation_error",
  "details": [
    {"field": "password", "message": "Password must be at least 8 characters with 1 uppercase, 1 lowercase, 1 number, and 1 special character."}
  ]
}
```

**Response 429 (Rate Limited):**
```json
{
  "error": "rate_limit_exceeded",
  "retry_after": 3600,
  "message": "Too many attempts. Please try again in 60 minutes."
}
```

---

#### POST /auth/login

**Phase:** 1 | **Auth:** None | **Rate Limit:** 10/IP/min, 10/email/15min

**Request:**
```json
{
  "email": "user@example.com",
  "password": "SecureP@ss1"
}
```

**Response 200 (Success):**
```json
{
  "user": {
    "id": "uuid",
    "email": "user@example.com",
    "email_verified": true,
    "role": "user",
    "subscription_tier": "free"
  },
  "session": {
    "access_token": "jwt...",
    "refresh_token": "opaque...",
    "expires_in": 900,
    "token_type": "bearer"
  }
}
```

**Response 401 (Invalid credentials):**
```json
{
  "error": "invalid_credentials",
  "message": "Invalid email or password."
}
```

**Response 423 (Account locked):**
```json
{
  "error": "account_locked",
  "message": "Account temporarily locked. Try again in 15 minutes or use a magic link.",
  "retry_after": 900
}
```

---

#### POST /auth/magic-link

**Phase:** 2 | **Auth:** None | **Rate Limit:** 3/email/15min

**Request:**
```json
{
  "email": "user@example.com"
}
```

**Response 200 (Always, regardless of email existence):**
```json
{
  "message": "Check your email for a login link. The link expires in 1 hour."
}
```

---

#### GET /auth/callback

**Phase:** 2 | **Auth:** None

Handles OAuth and magic link callbacks. Query parameters vary by flow. Frontend-rendered page that exchanges tokens and redirects.

---

#### POST /auth/reset-password

**Phase:** 2 | **Auth:** None | **Rate Limit:** 3/email/hour

**Request:**
```json
{
  "email": "user@example.com"
}
```

**Response 200 (Always):**
```json
{
  "message": "If an account exists with that email, you will receive a password reset link."
}
```

---

#### POST /auth/update-password

**Phase:** 2 | **Auth:** Authenticated (via reset token)

**Request:**
```json
{
  "password": "NewSecureP@ss2"
}
```

**Response 200:**
```json
{
  "message": "Password updated successfully."
}
```

**Response 422:**
```json
{
  "error": "validation_error",
  "message": "New password must be different from your current password."
}
```

---

#### POST /auth/logout

**Phase:** 1 | **Auth:** Authenticated

**Response 200:**
```json
{
  "message": "Signed out successfully."
}
```

---

### 5.2 Profile Endpoints (Authenticated)

#### GET /api/profile

**Phase:** 1 | **Auth:** Bearer JWT

**Response 200:**
```json
{
  "id": "uuid",
  "email": "user@example.com",
  "display_name": "John Doe",
  "avatar_url": "https://r2.trendedge.io/avatars/uuid.jpg",
  "timezone": "America/New_York",
  "subscription_tier": "free",
  "settings": { ... },
  "role": "user",
  "onboarding_completed": false,
  "onboarding_step": 0,
  "created_at": "2026-02-11T12:00:00Z",
  "last_login_at": "2026-02-11T12:00:00Z"
}
```

Note: `team_id`, `team_role`, `deleted_at` are omitted from the response if null.

---

#### PATCH /api/profile

**Phase:** 1 | **Auth:** Bearer JWT

**Request (partial update):**
```json
{
  "display_name": "Jane Trader",
  "timezone": "America/Chicago",
  "settings": {
    "trading_preferences": {
      "default_instruments": ["ES", "NQ", "CL"],
      "risk_per_trade_percent": 1.5
    }
  }
}
```

**Response 200:** Updated profile object (same schema as GET).

**Response 422:** Validation errors (see FR-020, FR-021 for field-specific messages).

---

#### POST /api/profile/avatar

**Phase:** 2 | **Auth:** Bearer JWT | **Content-Type:** multipart/form-data

**Request:** Form data with `file` field containing JPG or PNG image.

**Response 200:**
```json
{
  "avatar_url": "https://r2.trendedge.io/avatars/uuid.jpg"
}
```

**Response 413:** `{"error": "file_too_large", "message": "Image must be under 2MB."}`
**Response 415:** `{"error": "unsupported_media", "message": "Please upload a JPG or PNG image."}`

---

### 5.3 Session Endpoints (Authenticated)

#### GET /api/sessions

**Phase:** 2 | **Auth:** Bearer JWT

**Response 200:**
```json
{
  "sessions": [
    {
      "id": "session-uuid",
      "device_type": "Desktop",
      "browser": "Chrome 120",
      "ip_address": "192.168.xxx.xxx",
      "location": "New York, US",
      "last_active": "2026-02-11T12:00:00Z",
      "is_current": true
    },
    {
      "id": "session-uuid-2",
      "device_type": "Mobile",
      "browser": "Safari 17",
      "ip_address": "10.0.xxx.xxx",
      "location": "Chicago, US",
      "last_active": "2026-02-10T08:30:00Z",
      "is_current": false
    }
  ]
}
```

---

#### DELETE /api/sessions/:id

**Phase:** 2 | **Auth:** Bearer JWT

**Response 200:** `{"message": "Session revoked successfully."}`
**Response 403:** `{"error": "forbidden", "message": "Cannot revoke your current session from here. Use sign out instead."}`
**Response 404:** `{"error": "not_found", "message": "Session not found."}`

---

#### DELETE /api/sessions

**Phase:** 2 | **Auth:** Bearer JWT

Revokes all sessions except the current one.

**Response 200:** `{"message": "All other sessions have been revoked.", "revoked_count": 3}`

---

### 5.4 Broker Connection Endpoints (Authenticated)

#### GET /api/broker-connections

**Phase:** 1 | **Auth:** Bearer JWT

**Response 200:**
```json
{
  "connections": [
    {
      "id": "uuid",
      "broker_type": "ibkr",
      "display_name": "My IBKR Paper",
      "status": "active",
      "last_connected_at": "2026-02-11T12:00:00Z",
      "last_error": null,
      "account_id": "DU1234567",
      "is_paper": true,
      "created_at": "2026-02-01T10:00:00Z"
    }
  ]
}
```

Note: `credentials_encrypted`, `credentials_iv`, and `credentials_key_id` are NEVER included in API responses.

---

#### POST /api/broker-connections

**Phase:** 1 | **Auth:** Bearer JWT

**Request:**
```json
{
  "broker_type": "ibkr",
  "display_name": "My IBKR Paper",
  "credentials": {
    "host": "127.0.0.1",
    "port": 4002,
    "client_id": 1,
    "account": "DU1234567",
    "gateway_type": "paper"
  },
  "is_paper": true
}
```

**Response 201:** Connection object (without credentials).
**Response 403:** Tier limit reached (see FR-040 for messages).
**Response 403 (unverified):** `{"error": "email_not_verified", "message": "Please verify your email first."}`

---

#### POST /api/broker-connections/:id/test

**Phase:** 1 | **Auth:** Bearer JWT

**Response 200:**
```json
{
  "success": true,
  "account_id": "DU1234567",
  "balance": 100000.00,
  "currency": "USD"
}
```

**Response 200 (failure):**
```json
{
  "success": false,
  "error": "IB Gateway is not running or not reachable at 127.0.0.1:4002."
}
```

---

#### PATCH /api/broker-connections/:id

**Phase:** 1 | **Auth:** Bearer JWT

Updates display_name, credentials, or status. Credentials are re-encrypted on update.

---

#### DELETE /api/broker-connections/:id

**Phase:** 1 | **Auth:** Bearer JWT

**Response 200:** `{"message": "Broker connection removed."}`

---

### 5.5 API Key Endpoints (Authenticated)

#### GET /api/api-keys

**Phase:** 2 | **Auth:** Bearer JWT

**Response 200:**
```json
{
  "keys": [
    {
      "id": "uuid",
      "name": "TradingView Alerts",
      "key_prefix": "a1b2c3d4",
      "permissions": ["webhook:write", "trades:read"],
      "is_active": true,
      "last_used_at": "2026-02-11T12:00:00Z",
      "expires_at": null,
      "created_at": "2026-02-01T10:00:00Z",
      "request_count": 1542
    }
  ]
}
```

---

#### POST /api/api-keys

**Phase:** 2 | **Auth:** Bearer JWT

**Request:**
```json
{
  "name": "TradingView Alerts",
  "permissions": ["webhook:write"],
  "expires_in_days": 90
}
```

**Response 201:**
```json
{
  "id": "uuid",
  "name": "TradingView Alerts",
  "key": "te_live_a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6",
  "key_prefix": "a1b2c3d4",
  "permissions": ["webhook:write"],
  "expires_at": "2026-05-12T10:00:00Z",
  "webhook_url": "https://api.trendedge.io/v1/webhooks/tradingview",
  "message": "Your API key has been created. Copy it now — you won't be able to see it again."
}
```

Note: The `key` field is ONLY included in the creation response. Subsequent GET requests do not include it.

---

#### DELETE /api/api-keys/:id

**Phase:** 2 | **Auth:** Bearer JWT

**Response 200:** `{"message": "API key revoked."}`

---

### 5.6 Webhook Endpoint (API Key Auth)

#### POST /v1/webhooks/tradingview

**Phase:** 2 | **Auth:** API Key (X-API-Key header or api_key query param) | **Rate Limit:** 60/key/min

**Request:** TradingView alert JSON payload. [Cross-reference: see FSD-010 for payload format]

**Response 200:** `{"status": "received", "signal_id": "uuid"}`
**Response 401:** Invalid, revoked, or expired API key.
**Response 403:** Insufficient permissions.
**Response 429:** Rate limit exceeded.

---

### 5.7 Team Endpoints (Authenticated, Phase 3)

#### POST /api/teams
Create team. Requires Team subscription tier.

#### GET /api/teams/:id
Get team details. Requires team membership.

#### PATCH /api/teams/:id
Update team settings. Requires team_admin role.

#### POST /api/teams/:id/invite
Invite member. Requires team_admin role.

#### POST /api/teams/join
Accept invitation via token.

#### DELETE /api/teams/:id/members/:userId
Remove team member. Requires team_admin role.

#### GET /api/teams/:id/analytics
Get team analytics. team_admin sees full data; team_member sees aggregated only.

---

### 5.8 Account Lifecycle Endpoints (Authenticated, Phase 3)

#### POST /api/account/export
Request data export. Returns 202 Accepted. Email sent when ready.

#### DELETE /api/account
Delete account. Requires re-authentication and "DELETE" confirmation string.

---

### 5.9 Admin Endpoints (Admin Role, Phase 2-3)

#### PATCH /api/admin/users/:id/role
Change user role. Admin only. Requires re-auth if session > 15 min.

#### PATCH /api/admin/users/:id/tier
Change subscription tier. Admin only.

#### POST /api/admin/users/:id/suspend
Suspend user account. Admin only.

---

### 5.10 Common Response Headers (All Endpoints)

Every API response includes:
```
X-RateLimit-Limit: <max requests>
X-RateLimit-Remaining: <remaining requests>
X-RateLimit-Reset: <unix timestamp>
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
Content-Security-Policy: <see section 8.6>
X-Content-Type-Options: nosniff
X-Frame-Options: DENY
Referrer-Policy: strict-origin-when-cross-origin
Permissions-Policy: camera=(), microphone=(), geolocation=()
Cache-Control: no-store
```

---

## 6. UI/UX Specifications

### 6.1 Registration Page (`/register`)

**Layout:** Centered card on a minimal background. TrendEdge logo at top.

**Form fields:**
1. Email input — placeholder: "Enter your email address"
2. Password input — placeholder: "Create a password", with show/hide toggle icon
3. Confirm password input — placeholder: "Confirm your password", with show/hide toggle icon
4. Password strength indicator — colored bar below password field (red/orange/green)
5. "Create Account" button — full width, disabled until all validations pass
6. Divider: "or"
7. "Continue with Google" button (Phase 2) — Google branded
8. "Continue with GitHub" button (Phase 2) — GitHub branded
9. Footer link: "Already have an account? [Log in]"

**Validation display:** Inline error messages appear below each field in red text, with a 300ms debounce on input validation.

### 6.2 Login Page (`/login`)

**Layout:** Same centered card as registration.

**Form fields:**
1. Email input
2. Password input with show/hide toggle
3. "Log in" button — full width
4. "Forgot password?" link — right-aligned below password field
5. "Sign in with magic link" link — below login button
6. Divider: "or"
7. "Continue with Google" button (Phase 2)
8. "Continue with GitHub" button (Phase 2)
9. Footer link: "Don't have an account? [Register]"

### 6.3 Forgot Password Page (`/forgot-password`)

**Layout:** Same centered card.

**Form fields:**
1. Email input — placeholder: "Enter your email address"
2. "Send reset link" button
3. Back link: "Back to login"

**After submit:** Show green success message (same regardless of email existence).

### 6.4 Reset Password Page (`/auth/reset-password`)

**Layout:** Same centered card. Only accessible via valid reset link.

**Form fields:**
1. New password input with strength indicator
2. Confirm password input
3. "Update password" button

### 6.5 Email Verification Banner

**Location:** Top of dashboard, below main navigation bar. Full width.
**Color:** Blue background, white text.
**Content:** "Please verify your email to unlock all features. Didn't receive the email? [Resend]"
**Behavior:** Disappears immediately when `onAuthStateChange` reports verified status. No page reload.

### 6.6 Session Timeout Warning Modal

**Trigger:** 25 minutes of inactivity.
**Type:** Modal overlay with dimmed background. Cannot be dismissed by clicking outside.
**Content:**
- Title: "Session Timeout Warning"
- Body: "Your session will expire in 5:00 due to inactivity."
- Countdown timer that updates every second.
- Button: [Stay signed in] — full width, primary color.

### 6.7 Broker Connection Settings (`/settings/brokers`)

**Layout:** Card-based list of existing connections. Each card shows:
- Broker logo (IBKR, Tradovate, Webull)
- Display name
- Status indicator (colored dot + text per FR-042)
- Account ID (if connected)
- Paper/Live badge
- Action buttons: "Test", "Edit", "Disconnect"/"Reconnect"

**"Add Broker Connection" button** at top of list. Disabled if at tier limit, with upgrade tooltip.

### 6.8 API Key Management (`/settings/api-keys`)

**Layout:** Table with columns: Name, Key Prefix, Permissions, Last Used, Status, Actions.
**Actions:** "Revoke" (for active keys), "Delete" (for revoked keys), "View Usage" (chart popup).
**"Create API Key" button** at top. Opens modal with name, expiration, permissions inputs.
**Key creation modal:** After creation, full key displayed in a read-only input with "Copy" button. Warning text in orange: "Copy this key now — you won't be able to see it again."

### 6.9 Paper Trading Mode Banner

**Location:** Top of dashboard, below navigation (and below verification banner if both apply).
**Color:** Orange background, dark text.
**Content:** "PAPER TRADING MODE — Trades are simulated. Switch to live in [Settings]."
**Visible when:** `settings.trading_preferences.paper_trading_mode = true`.

### 6.10 Onboarding Wizard (Phase 3)

**Layout:** Full-screen overlay with progress bar at top. One step visible at a time.
**Navigation:** "Continue" button at bottom right, "Skip" link at bottom left, "Back" button (steps 2-4).
**Progress bar:** 4 segments. Completed steps are filled with primary color. Current step is highlighted.

---

## 7. Integration Specifications

### 7.1 Supabase Auth Integration

**Provider:** Supabase
**Purpose:** Authentication, JWT issuance, email verification, password reset, OAuth flows
**Environment:**
- `SUPABASE_URL` — Supabase project URL
- `SUPABASE_ANON_KEY` — Public key for client-side operations
- `SUPABASE_SERVICE_ROLE_KEY` — Service role key for backend operations (bypasses RLS)
- `SUPABASE_JWT_SECRET` — JWT secret for signature verification

**SDK Usage:**
- Frontend: `@supabase/supabase-js` (JavaScript SDK)
- Backend: `supabase-py` (Python SDK) for admin operations; direct JWT verification for request validation

**Error Handling:**
| Supabase Error | Our Response |
|---------------|-------------|
| 401 Invalid credentials | "Invalid email or password." |
| 422 User already registered | Generic message (production) |
| 429 Rate limited | "Too many attempts. Please try again in [X] seconds." |
| 500 Server error | "Something went wrong. Please try again later." Log full error. |
| Network timeout | "Unable to connect. Please check your connection and try again." |

### 7.2 Redis (Upstash) Integration

**Provider:** Upstash Redis
**Purpose:** Rate limiting, session caching, permission caching, token blacklist
**Environment:** `REDIS_URL`

**Usage Patterns:**
| Pattern | Key Format | TTL | Purpose |
|---------|-----------|-----|---------|
| Rate limit (IP) | `ratelimit:ip:{ip}:{endpoint}` | Varies by endpoint | Sliding window counter |
| Rate limit (email) | `ratelimit:email:{email_hash}:{endpoint}` | Varies by endpoint | Per-account rate limiting |
| Rate limit (API key) | `ratelimit:apikey:{key_hash}:{minute}` | 60 seconds | Webhook rate limiting |
| Permission cache | `perms:{user_id}` | 5 minutes | Cached role and permissions |
| Token blacklist | `blacklist:{token_jti}` | Until original token expiry | Revoked token tracking |
| Failed login counter | `failed_login:{email_hash}` | 1 hour | Brute force protection |
| Failed login counter (IP) | `failed_login_ip:{ip}` | 1 hour | IP-based protection |

**Fallback:** If Redis is unavailable, rate limiting degrades to in-memory counters (per-process, not distributed). A warning is logged every 60 seconds until Redis connectivity is restored.

### 7.3 Cloudflare R2 Integration

**Provider:** Cloudflare R2
**Purpose:** Avatar image storage, data export file storage
**Environment:** `R2_BUCKET_URL`, `R2_ACCESS_KEY_ID`, `R2_SECRET_ACCESS_KEY`

**Operations:**
| Operation | Path | TTL | Content Type |
|-----------|------|-----|-------------|
| Avatar upload | `avatars/{user_id}.{ext}` | Permanent | image/jpeg, image/png |
| Avatar delete | `avatars/{user_id}.{ext}` | N/A | N/A |
| Export upload | `exports/{user_id}/{filename}.zip` | 24 hours | application/zip |

**Error Handling:**
| Error | Our Response |
|-------|-------------|
| Upload failure | Retry up to 3 times with 2-second delay. On final failure: "Upload failed. Please try again." |
| Download link expired | "This download link has expired. Request a new export." |
| R2 service unavailable | Queue upload for retry. Show user: "Your file is being processed. You'll receive an email when it's ready." |

### 7.4 Email Service Integration (SendGrid/Resend)

**Provider:** SendGrid or Resend
**Purpose:** Transactional email delivery
**Environment:** `SENDGRID_API_KEY`

**Email Types:**
| Email | Trigger | Template |
|-------|---------|----------|
| Verification email | Registration (FR-001) | Handled by Supabase |
| Password reset | Reset request (FR-006) | Handled by Supabase |
| Magic link | Magic link request (FR-002) | Handled by Supabase |
| Security notification (stolen token) | Refresh token reuse (FR-011) | Custom template |
| Email change notification | Email change (FR-020) | Custom template |
| Team invitation | Member invite (FR-072) | Custom template |
| Data export ready | Export complete (FR-090) | Custom template |
| Account deletion confirmation | Account deleted (FR-091) | Custom template |
| Brute force alert | 50+ failed logins | Custom template |

**Error Handling:**
| Error | Our Response |
|-------|-------------|
| 401 Bad API key | Log CRITICAL, alert ops. Email queued for retry. |
| 429 Rate limited | Exponential backoff: 1s, 2s, 4s. Max 3 retries. |
| 500 Provider outage | Queue locally. Retry every 5 minutes. Alert after 3 failures. |
| Timeout (>10s) | Retry once, then queue for background processing. |

### 7.5 Broker API Integrations

#### Interactive Brokers (IBKR)

**Connection type:** Persistent TCP socket via IB Gateway
**Health check:** Request account summary (lightweight)
**Credential format:** Host, port, client ID, account number
**Token management:** No tokens; socket-based connection
**Error patterns:**
- Gateway not running: "IB Gateway is not running or not reachable at [host]:[port]."
- Gateway restart: Auto-reconnect on next health check cycle (within 5 min)
- Client ID conflict: "Client ID [X] is already in use. Choose a different client ID."

#### Tradovate

**Connection type:** REST API with OAuth tokens
**Health check:** `GET /account/list`
**Token refresh:** Every 55 minutes (before 60-minute expiry)
**Error patterns:**
- Invalid credentials: "Invalid username or password."
- Token expired (auto-refresh failed): Connection status -> `expired`
- API rate limit: Exponential backoff, max 3 retries

#### Webull

**Connection type:** REST API with OAuth tokens
**Health check:** `GET /account/profile`
**Token refresh:** NOT supported — manual re-authorization required
**Error patterns:**
- App secret expired: "App secret has expired. Generate a new one in the Webull developer portal."
- Invalid app key: "Invalid app key. Please verify your Webull API credentials."

### 7.6 hCaptcha Integration (Phase 2)

**Provider:** hCaptcha
**Purpose:** Bot protection on login after 5 failed attempts
**Environment:** `HCAPTCHA_SITE_KEY`, `HCAPTCHA_SECRET_KEY`
**Trigger:** After 5 consecutive failed login attempts for a given email
**Verification:** Backend verifies the hCaptcha response token via `POST https://hcaptcha.com/siteverify`
**Fallback:** If hCaptcha service is unavailable, proceed without CAPTCHA but maintain rate limits

---

## 8. Security Specifications

### 8.1 Credential Encryption (AES-256-GCM)

**Requirement:** All broker API credentials MUST be encrypted at rest using AES-256-GCM before storage in the database.

| Property | Specification |
|----------|--------------|
| Algorithm | AES-256-GCM (Galois/Counter Mode) |
| Key size | 256 bits (32 bytes) |
| IV size | 96 bits (12 bytes), cryptographically random per encryption |
| Authentication tag | 128 bits (16 bytes), appended to ciphertext by GCM |
| Master key storage | `BROKER_ENCRYPTION_MASTER_KEY` environment variable (Railway/Vercel encrypted) |
| Key derivation | HKDF-SHA256 with connection_id as info parameter; no salt |
| Key rotation window | Maximum 24 hours; both old and new keys valid during rotation |

**Credential lifecycle security:**

| Stage | Security Measure |
|-------|-----------------|
| Input | Credentials entered over HTTPS. TLS 1.3 enforced. Password fields use `type="password"`. |
| Transit | Encrypted via HTTPS. NEVER transmitted in query parameters, only in POST request body. |
| Processing | Decrypted in memory only when needed for broker API calls. |
| Storage | AES-256-GCM encrypted in PostgreSQL `bytea` column. |
| Display | NEVER displayed in API responses, UI, or logs. Masked format only: `****...a1b2`. |
| Deletion | Database record hard-deleted on account deletion. |
| Logging | Credentials are NEVER logged at any log level. Log sanitization middleware strips detected credential patterns. |

### 8.2 Rate Limiting

All authentication endpoints are protected by rate limits using Redis sliding window counters.

| Endpoint | Rate Limit | Window | Lockout Action |
|----------|-----------|--------|----------------|
| POST /auth/register | 5 requests | per IP per hour | 1-hour IP block |
| POST /auth/login | 10 requests | per IP per minute | 15-minute IP block |
| POST /auth/login (per account) | 10 requests | per email per 15 min | 15-minute account lock; 1-hour lock after 50 attempts |
| POST /auth/magic-link | 3 requests | per email per 15 min | 15-minute block |
| POST /auth/reset-password | 3 requests | per email per hour | 1-hour block |
| POST /auth/verify-email/resend | 3 requests | per email per hour | 1-hour block |
| POST /v1/webhooks/* | 60 requests | per API key per minute | 1-minute block; key auto-disabled after 1000/hour |
| GET /api/* (authenticated) | 120 requests | per user per minute | 1-minute block |

**Response on rate limit exceeded:**
- HTTP 429 with body: `{"error": "rate_limit_exceeded", "retry_after": <seconds>}`
- Headers: `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset` on every response.

### 8.3 Brute Force Protection

**Account lockout policy:**

| Failed Attempts | Action |
|----------------|--------|
| 5 consecutive | Display hCaptcha challenge on next attempt |
| 10 consecutive | Lock account for 15 minutes. Message: "Account temporarily locked. Try again in 15 minutes or use a magic link." |
| 50 consecutive (across lockout periods) | Lock account for 1 hour. Send email: "Multiple failed login attempts detected on your TrendEdge account. If this wasn't you, reset your password immediately." |
| Successful login | Reset failed attempt counter to 0 |

**IP-based protection:**

| Failed Attempts (any email) | Action |
|----------------------------|--------|
| 20 from single IP | Temporary IP block for 15 minutes |
| 100 from single IP per hour | IP block for 1 hour |

Lockout is per-email (not per-IP) for account lockout, preventing attackers from using different IPs to brute-force a single account. IP blocks are a separate, additional layer.

### 8.4 CSRF Protection

1. **SameSite cookies:** All auth cookies set with `SameSite=Lax`, preventing CSRF on cross-origin POST requests.
2. **CSRF tokens:** For server-rendered forms (if any), a CSRF token is included in a hidden field and validated server-side.
3. **Origin validation:** FastAPI backend validates the `Origin` header on all state-changing requests. Accepted origins: `https://app.trendedge.io`, `https://trendedge.io`.
4. **JWT Bearer tokens:** Provide implicit CSRF protection because they are not automatically sent by browsers in cross-origin requests (unlike cookies).

### 8.5 XSS Prevention

1. **Content Security Policy (CSP):**
   ```
   Content-Security-Policy: default-src 'self'; script-src 'self' 'nonce-{random}'; style-src 'self' 'unsafe-inline'; img-src 'self' https://r2.trendedge.io; connect-src 'self' https://api.trendedge.io wss://api.trendedge.io; frame-ancestors 'none';
   ```
2. **Input sanitization:** All user text is sanitized server-side using `bleach` before storage. Profile fields allow plain text only. Journal entry notes allow limited Markdown (no raw HTML).
3. **Output encoding:** React's JSX escaping is used for all user content. `dangerouslySetInnerHTML` is NEVER used with user-provided content.
4. **Additional headers:**
   - `X-Content-Type-Options: nosniff`
   - `X-Frame-Options: DENY`
   - `X-XSS-Protection: 0` (deprecated; CSP preferred)
   - `Referrer-Policy: strict-origin-when-cross-origin`

### 8.6 Session Fixation Prevention

1. On every successful authentication, a new session token is generated. Any pre-existing session token is invalidated.
2. Session tokens are NEVER accepted from URL parameters or form fields — only from HTTP-only cookies or Authorization headers.
3. Session tokens are bound to the user agent string. If the user agent changes, the session is invalidated.
4. Session tokens are regenerated after any privilege change (email verification, role change).

### 8.7 Security Headers

All responses include:

| Header | Value | Purpose |
|--------|-------|---------|
| Strict-Transport-Security | `max-age=31536000; includeSubDomains; preload` | Force HTTPS for 1 year |
| Content-Security-Policy | See section 8.5 | Prevent XSS |
| X-Content-Type-Options | `nosniff` | Prevent MIME type sniffing |
| X-Frame-Options | `DENY` | Prevent clickjacking |
| Referrer-Policy | `strict-origin-when-cross-origin` | Limit referrer information leakage |
| Permissions-Policy | `camera=(), microphone=(), geolocation=()` | Disable unused browser APIs |
| Cache-Control | `no-store` | Prevent caching of auth responses |

### 8.8 Audit Logging

All security-relevant events are logged in an append-only `audit_logs` table. The table has NO UPDATE or DELETE policies (insert-only via service role).

**Events logged:**

| Event Type | Data Captured |
|-----------|-------------|
| `user_registered` | user_id, email (hashed), IP, user_agent, timestamp |
| `login_success` | user_id, method (password/magic-link/oauth), IP, user_agent, timestamp |
| `login_failure` | email (hashed), method, IP, user_agent, failure_reason, timestamp |
| `password_reset_requested` | email (hashed), IP, timestamp |
| `password_changed` | user_id, IP, timestamp |
| `email_changed` | user_id, old_email (hashed), new_email (hashed), timestamp |
| `broker_connection_added` | user_id, broker_type, is_paper, timestamp |
| `broker_connection_removed` | user_id, broker_type, connection_id, timestamp |
| `api_key_created` | user_id, key_prefix, permissions, timestamp |
| `api_key_revoked` | user_id, key_prefix, timestamp |
| `role_changed` | user_id, old_role, new_role, changed_by, timestamp |
| `account_deleted` | user_id, timestamp |
| `admin_data_access` | admin_id, target_user_id, action, timestamp |
| `session_revoked` | user_id, session_id, revoked_by (self or admin), timestamp |
| `rate_limit_triggered` | IP, endpoint, count, timestamp |
| `paper_mode_changed` | user_id, old_value, new_value, days_in_paper, timestamp |

**Retention:** 2 years. Logs older than 2 years are archived to cold storage before deletion.

**RLS:** Users can read only their own audit entries. Admins can read all entries.

---

## 9. Performance Specifications

### 9.1 Authentication Latency

| Operation | Target (p95) | Measurement Point |
|-----------|-------------|-------------------|
| Email/password login | < 200ms | From request receipt to JWT issuance |
| Magic link generation | < 200ms | From request receipt to email queued |
| OAuth callback processing | < 200ms | From callback receipt to session created (excludes provider redirect time) |
| Token refresh | < 100ms | From refresh request to new token issued |
| JWT validation (per request) | < 50ms | From middleware entry to RLS context set |

### 9.2 Session Validation

JWT validation achieves < 50ms p95 through:
1. **Local signature verification:** No database call for valid tokens. The JWT secret is loaded in memory at application startup.
2. **Redis permission cache:** User role and permissions are cached in Redis with a 5-minute TTL. Cache hit rate target: > 95%.
3. **Connection pool reuse:** PostgreSQL connection pool (`asyncpg`) reuses connections for RLS context setting.

### 9.3 Concurrent Session Support

| Metric | Target |
|--------|--------|
| Concurrent authenticated sessions | 5,000+ |
| Authentication requests per second | 100+ |
| Token refresh requests per second | 500+ |
| Session store memory (Redis) | < 500MB at 5,000 sessions |

### 9.4 Scalability Targets

| Phase | Users | Concurrent Sessions | Database Size |
|-------|-------|-------------------|---------------|
| Phase 1 | 1 | 1-3 | < 1GB |
| Phase 2 | 100 | 50-100 | < 10GB |
| Phase 3 | 5,000 | 2,000-5,000 | < 100GB |
| Phase 4 | 50,000 | 10,000-25,000 | < 1TB |

### 9.5 Availability

**Target:** 99.9% availability (< 8.76 hours downtime per year).

**Resilience design:**
1. Supabase Auth provides built-in redundancy.
2. JWT validation is stateless — works even if Supabase is temporarily unreachable, as long as tokens are not expired.
3. Refresh token rotation degrades gracefully: if Supabase is down, existing valid access tokens continue to work until expiry (15 minutes).
4. Redis unavailability degrades to in-memory rate limiting (less accurate but functional).

---

## 10. Testing Specifications

### 10.1 Registration Tests

| Test ID | Test Case | Input | Expected Outcome | Type |
|---------|-----------|-------|-----------------|------|
| T-001 | Valid registration | `email: "test@example.com"`, `password: "SecureP@ss1"` | 201, user created in auth.users and public.users, verification email queued | Automated |
| T-002 | Duplicate email (production) | Existing email | 200, generic message, no duplicate created | Automated |
| T-003 | Weak password — too short | `password: "Ab1!"` (4 chars) | 422, password validation error | Automated |
| T-004 | Weak password — no uppercase | `password: "securep@ss1"` | 422, password validation error | Automated |
| T-005 | Weak password — no lowercase | `password: "SECUREP@SS1"` | 422, password validation error | Automated |
| T-006 | Weak password — no digit | `password: "SecureP@ss"` | 422, password validation error | Automated |
| T-007 | Weak password — no special char | `password: "SecurePass1"` | 422, password validation error | Automated |
| T-008 | Invalid email format | `email: "not-an-email"` | 422, "Please enter a valid email address" | Automated |
| T-009 | Empty fields | `email: ""`, `password: ""` | 422, field-level validation errors | Automated |
| T-010 | SQL injection in email | `email: "'; DROP TABLE users;--"` | Input rejected, no SQL execution | Automated |
| T-011 | XSS in display name (post-reg) | `display_name: "<script>alert('xss')</script>"` | Input sanitized, script not stored/executed | Automated |
| T-012 | Default user settings | New registration | User row has all defaults: free tier, user role, paper_trading_mode=true, all default JSONB settings | Automated |
| T-013 | Registration rate limit | 6 requests from same IP in 1 hour | 6th request returns 429 | Automated |

### 10.2 Login Tests

| Test ID | Test Case | Input | Expected Outcome | Type |
|---------|-----------|-------|-----------------|------|
| T-020 | Valid login | Correct email + password | 200, JWT issued, session created, redirect to dashboard | Automated |
| T-021 | Invalid password | Correct email, wrong password | 401, "Invalid email or password" | Automated |
| T-022 | Non-existent email | Unregistered email | 401, "Invalid email or password" (same message) | Automated |
| T-023 | Unverified email login | Correct credentials, unverified account | 200, login succeeds, verification banner shown, features restricted | Automated |
| T-024 | Magic link login | Valid email | 200, "Check your email" message, email sent | Automated |
| T-025 | Expired magic link | Link older than 1 hour | "This link has expired" with resend option | Automated |
| T-026 | Used magic link | Click same link twice | Second click: "This link has already been used" | Automated |
| T-027 | Google OAuth login | Valid Google account | Session created, redirect to dashboard | E2E |
| T-028 | GitHub OAuth login | Valid GitHub account | Session created, redirect to dashboard | E2E |
| T-029 | OAuth consent denied | User cancels on provider | Redirect to login with cancellation message | E2E |
| T-030 | Account locked (10 failures) | 10 wrong passwords then correct | 11th attempt returns 423 locked message | Automated |
| T-031 | hCaptcha after 5 failures | 5 wrong passwords | 6th attempt requires hCaptcha | Automated |

### 10.3 Password Reset Tests

| Test ID | Test Case | Input | Expected Outcome | Type |
|---------|-----------|-------|-----------------|------|
| T-040 | Valid reset request | Registered email | 200, generic message, reset email sent | Automated |
| T-041 | Non-existent email reset | Unregistered email | 200, same generic message (no info leak) | Automated |
| T-042 | Valid reset token + strong password | Valid token, new password meeting requirements | Password updated, all sessions invalidated | Automated |
| T-043 | Expired reset token | Token older than 1 hour | "This link has expired" with request new link option | Automated |
| T-044 | Reused reset token | Already-used token | "This link has already been used" | Automated |
| T-045 | Same password as current | Current password as new password | "New password must be different from your current password" | Automated |
| T-046 | Session invalidation on reset | Reset password, then use old token | Old token returns 401 | Automated |
| T-047 | Reset rate limit | 4 requests in 1 hour | 4th returns 429 | Automated |

### 10.4 RLS Cross-User Isolation Tests (CRITICAL — Run on Every Deployment)

| Test ID | Test Case | Method | Expected Outcome | Type |
|---------|-----------|--------|-----------------|------|
| T-060 | User A reads User B's trades | Auth as A, SELECT with B's trade ID | 0 rows returned | Automated |
| T-061 | User A updates User B's playbook | Auth as A, UPDATE with B's playbook ID | 0 rows affected | Automated |
| T-062 | User A deletes User B's trendline | Auth as A, DELETE with B's trendline ID | 0 rows affected | Automated |
| T-063 | User A inserts trade with B's user_id | Auth as A, INSERT with user_id = B | RLS violation error | Automated |
| T-064 | Query without auth context | Query without setting JWT claim | 0 rows returned | Automated |
| T-065 | Service role access | Use service role key | Full access (intentional) | Automated |
| T-066 | Admin reads User B's trades | Auth as admin, query B's trades | Rows returned (Phase 3 only) | Automated |
| T-067 | Admin updates User B's trades | Auth as admin, UPDATE B's trades | 0 rows affected (admin is read-only) | Automated |
| T-068 | RLS on ALL tables | Run T-060 pattern on every user-owned table | 0 rows on all tables | Automated |

**Automated test implementation (runs in CI/CD):**
```python
def test_rls_cross_user_isolation():
    """Verify User A cannot access User B's data across all tables."""
    tables = ['trades', 'signals', 'trendlines', 'playbooks',
              'journal_entries', 'broker_connections', 'api_keys']

    for table in tables:
        client_a = create_authenticated_client(user_a_token)

        # Attempt to read User B's data
        result = client_a.from_(table).select('*').eq('user_id', user_b_id).execute()
        assert len(result.data) == 0, f"User A accessed User B's {table}"

        # Attempt to read by specific ID belonging to User B
        result = client_a.from_(table).select('*').eq('id', user_b_record_id).execute()
        assert len(result.data) == 0, f"User A accessed User B's {table} by ID"
```

### 10.5 Session Management Tests

| Test ID | Test Case | Setup | Expected Outcome | Type |
|---------|-----------|-------|-----------------|------|
| T-080 | Token expiry and auto-refresh | Wait 15+ min without manual refresh | Client auto-refreshes, new token works | Automated |
| T-081 | Refresh token rotation | Use refresh token | Old refresh token invalidated, new pair issued | Automated |
| T-082 | Stolen refresh token detection | Use previously-invalidated refresh token | ALL sessions revoked, security email sent | Automated |
| T-083 | Inactivity timeout | No interaction for 30 min | User signed out, redirect to login with inactivity message | E2E |
| T-084 | Multi-device login | Login from two browsers | Both sessions active simultaneously | Automated |
| T-085 | Session revocation | Revoke session from device A | Device A's next request returns 401 | Automated |
| T-086 | Password change invalidation | Change password | All OTHER sessions invalidated | Automated |
| T-087 | Inactivity warning modal | No interaction for 25 min | Warning modal appears with 5-min countdown | E2E |

### 10.6 Credential Encryption Tests

| Test ID | Test Case | Method | Expected Outcome | Type |
|---------|-----------|--------|-----------------|------|
| T-100 | Credentials encrypted at rest | Direct DB query on broker_connections | `credentials_encrypted` column is binary, not readable JSON | Automated |
| T-101 | Credentials decrypt correctly | Decrypt via application layer | Original credential JSON restored exactly | Automated |
| T-102 | Key rotation | Rotate master key, decrypt with new key | All credentials re-encrypted, old key no longer needed | Automated |
| T-103 | Tampered ciphertext | Modify 1 byte of encrypted data | Decryption fails with GCM authentication error (InvalidTag) | Automated |
| T-104 | Missing IV | Remove IV from record | Decryption fails gracefully with clear error | Automated |
| T-105 | API response check | GET /api/broker-connections | Response NEVER contains credentials_encrypted, credentials_iv, or decrypted credentials | Automated |

### 10.7 Penetration Testing Checklist

| Test ID | Category | Test | Pass Criteria | Type |
|---------|----------|------|--------------|------|
| T-120 | Auth Bypass | API access without token | HTTP 401 on all protected endpoints | Automated |
| T-121 | Token Manipulation | Modify JWT payload (change user_id) | Signature verification fails, HTTP 401 | Automated |
| T-122 | Privilege Escalation | Change role claim in JWT | Signature fails; role always verified from DB | Automated |
| T-123 | SQL Injection | SQL in all input fields | No SQL execution; parameterized queries only | Automated |
| T-124 | XSS | Scripts in profile fields, journal notes | Input sanitized; CSP blocks execution | Automated |
| T-125 | CSRF | Cross-origin POST to state-changing endpoints | CSRF protection blocks; SameSite cookies prevent | Automated |
| T-126 | Session Fixation | Set session token before auth | Token regenerated on login; old token invalid | Automated |
| T-127 | Brute Force | >10 login attempts in 1 minute | Account locked, 429 response | Automated |
| T-128 | Credential Exposure | Search logs, errors, API responses | No credentials, tokens, or secrets in any output | Automated |
| T-129 | RLS Bypass | Direct queries via Supabase URL | RLS blocks all unauthorized access | Automated |
| T-130 | IDOR | Access resources by guessing/iterating UUIDs | RLS + ownership check prevents access | Automated |

### 10.8 OWASP Authentication Compliance

| OWASP Test ID | Test Name | Verification | Pass Criteria |
|--------------|-----------|-------------|--------------|
| OTG-AUTHN-001 | Encrypted channel | Check all auth endpoints | All require HTTPS; HSTS header present |
| OTG-AUTHN-002 | Default credentials | Check for default accounts | No default accounts; admin bootstrap is manual DB insert |
| OTG-AUTHN-003 | Account lockout | Trigger lockout | 10 failures -> 15-min lock; 50 -> 1-hour lock |
| OTG-AUTHN-004 | Auth bypass | Test every API route | Auth middleware on all protected routes |
| OTG-AUTHN-005 | Session timeout | Check token lifetimes | Refresh: 7 days; inactivity: 30 min; max age: 30 days |
| OTG-AUTHN-006 | Browser cache | Check cache headers | `Cache-Control: no-store` on all auth responses |
| OTG-AUTHN-007 | Password policy | Test weak passwords | 8+ chars, uppercase, lowercase, digit, special char |
| OTG-AUTHN-008 | Security questions | Verify not used | Not implemented; magic link provides passwordless recovery |
| OTG-AUTHN-009 | Password change | Test flow | Requires current password; all sessions invalidated |
| OTG-AUTHN-010 | HTTP Authentication | Verify method | JWT Bearer tokens only; no HTTP Basic/Digest |

### 10.9 Load Testing Specifications

| Test | Configuration | Pass Criteria |
|------|--------------|--------------|
| Login throughput | 100 concurrent login requests over 60 seconds | p95 latency < 200ms; 0 errors |
| Session validation throughput | 1,000 concurrent authenticated requests | p95 validation < 50ms |
| Token refresh under load | 500 concurrent refresh requests | p95 < 100ms; no token conflicts |
| Concurrent sessions | Simulate 5,000 active sessions | Response times within SLA; Redis < 500MB |
| Webhook throughput | 60 requests/key/min across 50 keys | All processed; rate limits correctly enforced |

---

## 11. Migration & Deployment

### 11.1 Phase 1 Deployment Steps

1. **Supabase project setup:**
   - Create Supabase project with PostgreSQL 16.
   - Configure auth settings: email/password enabled, confirm email enabled.
   - Set JWT expiry to 900 seconds, refresh token expiry to 604800 seconds.

2. **Database migrations (run in order):**
   - Create `public.users` table.
   - Create `public.broker_connections` table.
   - Create `public.audit_logs` table.
   - Create `handle_new_user()` trigger function.
   - Create `on_auth_user_created` trigger.
   - Enable and force RLS on all tables.
   - Create all RLS policies.
   - Create all indexes.

3. **Environment variables (all required for Phase 1):**
   - `SUPABASE_URL`
   - `SUPABASE_ANON_KEY`
   - `SUPABASE_SERVICE_ROLE_KEY`
   - `SUPABASE_JWT_SECRET`
   - `BROKER_ENCRYPTION_MASTER_KEY` (generate: `python -c "import secrets; print(secrets.token_hex(32))"`)
   - `REDIS_URL`

4. **Verification (must pass before deployment is complete):**
   - Register a test user -> verify `public.users` row created with defaults.
   - Login -> verify JWT issued and API requests work.
   - RLS tests -> verify cross-user isolation (T-060 through T-068).
   - Add a broker connection -> verify credentials are encrypted in DB.
   - Verify API responses never contain encrypted credentials.

### 11.2 Phase 2 Deployment Steps

1. **Additional environment variables:**
   - `R2_BUCKET_URL`, `R2_ACCESS_KEY_ID`, `R2_SECRET_ACCESS_KEY`
   - `SENDGRID_API_KEY`
   - `GOOGLE_OAUTH_CLIENT_ID`, `GOOGLE_OAUTH_CLIENT_SECRET`
   - `GITHUB_OAUTH_CLIENT_ID`, `GITHUB_OAUTH_CLIENT_SECRET`
   - `HCAPTCHA_SITE_KEY`, `HCAPTCHA_SECRET_KEY`
   - `APP_DOMAIN`

2. **Supabase configuration:**
   - Enable Google OAuth provider with client ID/secret.
   - Enable GitHub OAuth provider with client ID/secret.
   - Configure redirect URLs: `https://app.trendedge.io/auth/callback`
   - Configure email templates for verification, reset, magic link.

3. **Database migrations:**
   - Create `public.api_keys` table.
   - Enable RLS on `api_keys`.
   - Create RLS policies for `api_keys`.
   - Create indexes on `api_keys`.

4. **Redis setup:**
   - Verify sliding window rate limiting is operational.
   - Configure key TTLs per rate limit specification.

5. **Verification:**
   - All Phase 1 tests still pass.
   - Magic link flow works end-to-end.
   - Google OAuth flow works.
   - GitHub OAuth flow works.
   - Password reset flow works.
   - Email verification enforces feature restrictions.
   - API keys can be created, used, and revoked.
   - Rate limiting blocks excessive requests.
   - All security headers present on responses.
   - Penetration test checklist passes.

### 11.3 Phase 3 Deployment Steps

1. **Database migrations:**
   - Create `public.teams` table.
   - Create `public.team_members` table.
   - Add `team_id` and `team_role` columns to `public.users` (if not already present).
   - Enable RLS on `teams` and `team_members`.
   - Create team-specific RLS policies.
   - Create indexes on team tables.

2. **Verification:**
   - All Phase 1 and Phase 2 tests still pass.
   - Team creation and invitation flow works.
   - Team RLS prevents cross-team data access.
   - Shared playbooks are visible to team members.
   - Data export generates valid ZIP.
   - Account deletion soft-deletes correctly.
   - 30-day cleanup task hard-deletes correctly.
   - Onboarding wizard renders and progresses.

### 11.4 Rollback Procedures

| Component | Rollback Method |
|-----------|----------------|
| Database migrations | Each migration has a corresponding down migration. Run: `alembic downgrade -1` |
| API code deployment | Railway/Vercel supports instant rollback to previous deployment |
| Supabase auth config | Auth settings are version-controlled; revert via Supabase dashboard |
| Environment variables | Previous values stored in deployment platform history |
| Encryption key rotation | Old key retained during rotation window; abort rotation by keeping old key active |

### 11.5 Data Integrity Checks Post-Deployment

| Check | Query | Expected |
|-------|-------|----------|
| All users have matching auth rows | `SELECT COUNT(*) FROM public.users WHERE id NOT IN (SELECT id FROM auth.users)` | 0 |
| All broker credentials are encrypted | `SELECT COUNT(*) FROM broker_connections WHERE credentials_encrypted IS NULL` | 0 |
| RLS is enabled on all tables | `SELECT tablename FROM pg_tables WHERE schemaname='public' AND tablename NOT IN (SELECT tablename FROM pg_policies ...)` | 0 unprotected tables |
| All users have default settings | `SELECT COUNT(*) FROM users WHERE settings IS NULL OR settings = '{}'::jsonb` | 0 |
| No orphaned team members | `SELECT COUNT(*) FROM team_members WHERE team_id NOT IN (SELECT id FROM teams)` | 0 |

---

## 12. Open Questions & Assumptions

### 12.1 Assumptions

| ID | Assumption | Impact if Wrong |
|----|-----------|----------------|
| A-001 | Supabase Auth is reliable at 99.9%+ availability | Need fallback auth provider or local JWT issuance |
| A-002 | Redis (Upstash) is available for rate limiting | Degrade to in-memory counters; rate limiting less accurate in multi-instance deployments |
| A-003 | IB Gateway is installed and running on a user-accessible server | Users need deployment guide for IB Gateway; cannot auto-provision |
| A-004 | Tradovate API rate limits are sufficient for health checks every 5 minutes | May need to reduce health check frequency |
| A-005 | Webull API requires manual re-authorization (no auto-refresh) | Users must manually re-enter credentials when secrets expire |
| A-006 | A single PostgreSQL database handles the expected load through Phase 3 | May need read replicas or connection pooling (PgBouncer) at scale |
| A-007 | Email delivery via SendGrid/Resend is reliable within 30 seconds | Need monitoring and fallback provider |
| A-008 | Users run IB Gateway locally (127.0.0.1) rather than on a remote server | Remote IB Gateway adds network latency and firewall complexity |
| A-009 | Team tier pricing ($199/mo) supports the development cost of team features | Need to validate pricing with market research |
| A-010 | GDPR-like compliance is sufficient (no specific GDPR certification needed initially) | May need formal GDPR audit for EU users |

### 12.2 Open Questions

| ID | Question | Impact | Decision Needed By |
|----|---------|--------|-------------------|
| Q-001 | Should we support 2FA/MFA (TOTP, SMS, or hardware keys)? | High security improvement, but adds complexity. Not in current PRD. | Phase 2 planning |
| Q-002 | Should we implement IP allowlisting for API keys? | Prevents API key abuse from unauthorized IPs. | Phase 2 planning |
| Q-003 | What is the maximum number of team members for the Team tier? | PRD says 5-20+; need exact limit for enforcement. | Before Phase 3 development |
| Q-004 | Should soft-deleted users' data be anonymized rather than fully deleted? | Anonymized data could be useful for aggregate analytics. | Before Phase 3 development |
| Q-005 | How should we handle the case where a user belongs to multiple teams? | Current design: one team per user. Multi-team may be needed for prop firm managers. | Phase 3 planning |
| Q-006 | Should the Rithmic broker type be fully supported or placeholder only? | Listed in CHECK constraint but no connection flow documented. | Phase 1 planning |
| Q-007 | What email service (SendGrid vs. Resend) will be used in production? | Affects API integration code and templates. | Before Phase 2 development |
| Q-008 | Should admin actions require 2FA in addition to re-authentication? | Higher security for admin operations. | Phase 2 planning |

---

## 13. Appendices

### Appendix A: Environment Variables Reference

| Variable | Description | Required | Phase |
|----------|------------|----------|-------|
| `SUPABASE_URL` | Supabase project URL | Yes | 1 |
| `SUPABASE_ANON_KEY` | Supabase anonymous (public) key | Yes | 1 |
| `SUPABASE_SERVICE_ROLE_KEY` | Supabase service role key (bypasses RLS) | Yes | 1 |
| `SUPABASE_JWT_SECRET` | JWT secret for signature verification | Yes | 1 |
| `BROKER_ENCRYPTION_MASTER_KEY` | AES-256 master key for broker credential encryption | Yes | 1 |
| `REDIS_URL` | Redis connection URL for caching and rate limiting | Yes | 1 |
| `R2_BUCKET_URL` | Cloudflare R2 bucket URL for file storage | Yes | 2 |
| `R2_ACCESS_KEY_ID` | R2 access key | Yes | 2 |
| `R2_SECRET_ACCESS_KEY` | R2 secret key | Yes | 2 |
| `SENDGRID_API_KEY` | SendGrid API key for transactional email | Yes | 2 |
| `GOOGLE_OAUTH_CLIENT_ID` | Google OAuth client ID | Yes | 2 |
| `GOOGLE_OAUTH_CLIENT_SECRET` | Google OAuth client secret | Yes | 2 |
| `GITHUB_OAUTH_CLIENT_ID` | GitHub OAuth client ID | Yes | 2 |
| `GITHUB_OAUTH_CLIENT_SECRET` | GitHub OAuth client secret | Yes | 2 |
| `HCAPTCHA_SITE_KEY` | hCaptcha site key for brute force protection | Yes | 2 |
| `HCAPTCHA_SECRET_KEY` | hCaptcha secret key | Yes | 2 |
| `APP_DOMAIN` | Application domain for CORS/origin validation | Yes | 2 |

### Appendix B: User Account State Diagram

```
                    +--------------+
                    |  Registered  |
                    |  (Unverified)|
                    +------+-------+
                           |
                    Email verified
                           |
                    +------v-------+
              +---->|    Active     |<----+
              |     +------+-------+     |
              |            |             |
         Unlocked    Account locked   Restored
              |     (brute force)    (within 30d)
              |            |             |
              |     +------v-------+     |
              |     |    Locked     |     |
              |     +------+-------+     |
              |            |             |
              +--  Lockout expires       |
                                         |
                    +------+-------+     |
                    |   Deleted     +-----+
                    | (Soft, 30d)  |
                    +------+-------+
                           |
                    30 days elapsed
                           |
                    +------v-------+
                    | Hard Deleted  |
                    | (Irreversible)|
                    +--------------+
```

### Appendix C: Broker Connection State Diagram

```
    +---------------+
    | Disconnected  |<----- User disconnects
    +-------+-------+
            |
     User connects
            |
    +-------v-------+
    |    Active      |<----- Auto-refresh succeeds
    +-------+--------+      Health check OK
            |
    +-------+--------+--------+
    |                |        |
 3 failures    Token expires  User disconnects
    |                |        |
+---v---+     +------v---+   |
| Error |     | Expired  |   |
+---+---+     +------+---+   |
    |                |        |
 User re-auth   Auto-refresh  |
    |           fails 3x      |
    |                |         |
    +---> Active <---+    Disconnected
```

### Appendix D: Invitation State Diagram

```
    +----------+
    |  Pending  |
    +----+-----+
         |
    +----+-----+-----+-----+
    |          |           |
 Accepted   Declined    Revoked    Expired (7d)
    |          |           |           |
+---v---+ +---v---+  +----v----+ +----v----+
|Accepted| |Declined| | Revoked | | Expired |
+--------+ +--------+ +---------+ +---------+
```

### Appendix E: API Endpoint Summary

| Method | Endpoint | Auth | Description | Phase |
|--------|----------|------|-------------|-------|
| POST | /auth/register | Public | Email/password registration | 1 |
| POST | /auth/login | Public | Email/password login | 1 |
| POST | /auth/magic-link | Public | Request magic link | 2 |
| GET | /auth/callback | Public | OAuth/magic link callback | 2 |
| POST | /auth/reset-password | Public | Request password reset | 2 |
| POST | /auth/update-password | Authenticated | Set new password (reset flow) | 2 |
| POST | /auth/logout | Authenticated | Sign out current session | 1 |
| GET | /api/profile | Authenticated | Get user profile | 1 |
| PATCH | /api/profile | Authenticated | Update user profile | 1 |
| POST | /api/profile/avatar | Authenticated | Upload avatar | 2 |
| GET | /api/sessions | Authenticated | List active sessions | 2 |
| DELETE | /api/sessions/:id | Authenticated | Revoke a session | 2 |
| DELETE | /api/sessions | Authenticated | Revoke all other sessions | 2 |
| GET | /api/broker-connections | Authenticated | List broker connections | 1 |
| POST | /api/broker-connections | Authenticated | Add broker connection | 1 |
| POST | /api/broker-connections/:id/test | Authenticated | Test broker connection | 1 |
| PATCH | /api/broker-connections/:id | Authenticated | Update broker connection | 1 |
| DELETE | /api/broker-connections/:id | Authenticated | Remove broker connection | 1 |
| GET | /api/api-keys | Authenticated | List API keys | 2 |
| POST | /api/api-keys | Authenticated | Create API key | 2 |
| DELETE | /api/api-keys/:id | Authenticated | Revoke API key | 2 |
| POST | /v1/webhooks/tradingview | API Key | TradingView webhook receiver | 2 |
| POST | /api/teams | Authenticated | Create team | 3 |
| GET | /api/teams/:id | Authenticated | Get team details | 3 |
| PATCH | /api/teams/:id | Authenticated | Update team settings | 3 |
| POST | /api/teams/:id/invite | Authenticated | Invite team member | 3 |
| POST | /api/teams/join | Authenticated | Accept team invitation | 3 |
| DELETE | /api/teams/:id/members/:userId | Authenticated | Remove team member | 3 |
| GET | /api/teams/:id/analytics | Authenticated | Get team analytics | 3 |
| POST | /api/account/export | Authenticated | Request data export | 3 |
| DELETE | /api/account | Authenticated | Delete account | 3 |
| PATCH | /api/admin/users/:id/role | Admin | Change user role | 2 |
| PATCH | /api/admin/users/:id/tier | Admin | Change subscription tier | 2 |
| POST | /api/admin/users/:id/suspend | Admin | Suspend user account | 2 |

### Appendix F: Cross-Reference Index

| FSD Section | PRD Requirement(s) | Phase |
|------------|-------------------|-------|
| FR-001 | AU-FR-001 | 1 |
| FR-002 | AU-FR-002 | 2 |
| FR-003 | AU-FR-003 | 2 |
| FR-004 | AU-FR-004 | 2 |
| FR-005 | AU-FR-005 | 2 |
| FR-006 | AU-FR-006 | 2 |
| FR-010 | AU-FR-010 | 1 |
| FR-011 | AU-FR-011 | 1 |
| FR-012 | AU-FR-012 | 1/2 |
| FR-013 | AU-FR-013 | 2 |
| FR-020 | AU-FR-020 | 1/2 |
| FR-021 | AU-FR-021 | 1 |
| FR-022 | AU-FR-022 | 2 |
| FR-040 | AU-FR-040 | 1 |
| FR-041 | AU-FR-041 | 1 |
| FR-042 | AU-FR-042 | 1/2 |
| FR-043 | AU-FR-043 | 1 |
| FR-044 | AU-FR-044 | 2 |
| FR-050/051 | AU-FR-050, AU-FR-051 | 1 |
| FR-052 | AU-FR-052 | 3 |
| FR-053 | AU-FR-053 | 1 |
| FR-060/061/062 | AU-FR-060, AU-FR-061, AU-FR-062 | 1/2/3 |
| FR-070-074 | AU-FR-070 through AU-FR-074 | 3 |
| FR-080/081 | AU-FR-080, AU-FR-081 | 3 |
| FR-090 | AU-FR-090 | 3 |
| FR-091 | AU-FR-091 | 3 |
| FR-100 | AU-FR-100 | 2 |
| FR-101 | AU-FR-101 | 2 |

---

*This document is FSD-008 of the TrendEdge platform. It specifies the complete authentication, authorization, user management, and data isolation layer that must be implemented before any other FSD that requires user identity, data isolation, or broker connectivity.*
