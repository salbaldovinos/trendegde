# FSD-003a: Signal Ingestion & Normalization

**TrendEdge -- AI-Powered Futures Trading Platform**

| Field | Value |
|---|---|
| FSD ID | FSD-003a |
| Source | FSD-003 (Trade Execution) |
| Title | Signal Ingestion & Normalization |
| Version | 1.0 |
| Status | Draft |
| Author | Generated by Claude |
| Created | 2026-02-11 |

---

## 1. Introduction

### 1.1 Purpose

This sub-FSD specifies the signal ingestion and normalization subsystem of the TrendEdge trade execution pipeline. It covers everything from the moment a trade signal arrives from any source to the point where a fully normalized, validated, enriched, and deduplicated signal is ready for risk evaluation.

This is the entry point of the execution pipeline. Signals flow through this subsystem before being handed off to:

- **FSD-003b (Risk Management Engine)**: Pre-trade risk checks, risk parameter configuration, and audit trail.
- **FSD-003c (Broker Adapters)**: Broker-specific order submission and connection management.
- **FSD-003d (Order Construction & Lifecycle)**: Bracket order building, position tracking, and fill reconciliation.

### 1.2 Scope

This document covers:

- **Signal Sources**: Accepting trade signals from three sources -- internal trendline engine (Redis pub/sub), TradingView webhooks (HTTP POST), and manual dashboard entry (API).
- **Webhook Infrastructure**: Unique URL generation, authentication (HMAC, API key, URL path), rate limiting, payload parsing, and replay attack prevention.
- **Signal Normalization**: Mapping source-specific fields to a canonical `Signal` data structure.
- **Signal Validation**: Instrument resolution, continuous contract symbol mapping, and price validation.
- **Signal Enrichment**: Contract specifications, computed risk fields, market context, and account context.
- **Signal Deduplication**: Detecting and rejecting duplicate signals within a configurable window.

### 1.3 Out of Scope

- Risk check evaluation (position size, daily loss, R:R minimum, correlation) [see FSD-003b]
- Order construction and bracket order building [see FSD-003d]
- Broker connection management and order submission [see FSD-003c]
- Position lifecycle and fill reconciliation [see FSD-003d]
- User authentication and session management [see FSD-009]
- Market data feed infrastructure [see FSD-010]

### 1.4 Glossary

| Term | Definition |
|---|---|
| Signal | A normalized trade intent containing instrument, direction, prices, and metadata. |
| Continuous Contract | A TradingView symbol (e.g., "NQ1!") that always represents the front-month futures contract. |
| Front Month | The nearest expiring actively-traded futures contract. |
| Safety Line | The opposing trendline projected forward, used as a stop loss reference point. |
| RTH | Regular Trading Hours (e.g., 9:30 AM - 4:00 PM ET for equity index futures). |
| ETH | Extended Trading Hours (outside RTH, typically overnight session). |
| HMAC | Hash-based Message Authentication Code, used for webhook signature verification. |
| Deduplication Window | A configurable time period during which identical signals are rejected as duplicates. |

### 1.5 External Dependencies

| Dependency | Type | Description |
|---|---|---|
| PostgreSQL | Hard | Primary data store for signals and webhook URLs. [see FSD-001] |
| Redis | Hard | Pub/sub for internal signals, rate limiting (sliding window), deduplication cache, replay attack prevention. [see FSD-001] |
| TradingView | Soft | External webhook source. TrendEdge has no control over TradingView's delivery latency. |
| Market Data Cache | Soft | Redis-cached market prices for price tolerance validation. [see FSD-010] |

---

## 2. System Context

### 2.1 Signal Flow Overview

```
                    +------------------+
                    | TradingView      |
                    | (Webhook POST)   |
                    +--------+---------+
                             |
                             v
+------------------+   +-----------+   +------------------+
| Trendline Engine |-->|  Signal   |   | Dashboard UI     |
| (FSD-002)        |   | Ingestion |<--| (Manual Entry)   |
| Internal Signals |   | Pipeline  |   | (FSD-011)        |
+------------------+   +-----+-----+   +------------------+
                              |
                    +---------+---------+
                    |                   |
                    v                   v
             +------+------+    +------+------+
             | REJECTED    |    | Normalized  |
             | (logged)    |    | Signal      |
             +-------------+    +------+------+
                                       |
                              handoff to FSD-003b
                              (Risk Management)
```

### 2.2 Pipeline Stages (within this subsystem)

1. **Signal Receipt**: Signal arrives from one of three sources (internal engine via Redis pub/sub, TradingView webhook via HTTP POST, or manual entry via dashboard API).
2. **Normalization**: Raw signal is parsed and normalized into the canonical `Signal` data structure.
3. **Authentication**: Signal source is authenticated (API key, HMAC signature, session token, or internal process verification).
4. **Instrument Validation**: Instrument symbol is resolved and verified against supported instruments.
5. **Symbol Mapping**: TradingView continuous contract symbols are mapped to specific contract months.
6. **Price Validation**: Entry, stop loss, and take profit prices are validated for logical consistency and market tolerance.
7. **Enrichment**: Signal is enriched with contract specifications, computed fields, market context, and account context.
8. **Deduplication**: Signal is checked against recent signals; duplicates are rejected.
9. **Handoff**: The validated, enriched signal is passed to the Risk Management Engine (FSD-003b).

---

## 3. Functional Specifications

### 3.1 EX-FR-001: Internal Signal Source

**Source**: PRD-003 Section 3.1, US-EX-001

**Description**: The system accepts signals from the trendline detection engine via an internal message bus (Redis pub/sub channel or direct async function call). These signals carry full trendline metadata that enriches downstream journaling and analytics.

**Inputs**:

| Field | Type | Required | Description |
|---|---|---|---|
| instrument | string | Yes | Futures symbol (e.g., "MNQ", "MES") |
| direction | enum | Yes | `LONG` or `SHORT` |
| entry_price | Decimal | Yes | Price at which the trendline break was detected |
| stop_loss_price | Decimal | Yes | Safety line price (opposing trendline projected +4 candles) |
| take_profit_price | Decimal | Yes | First S/R level providing >= 2R reward |
| trendline_id | UUID | Yes | Reference to the trendline that generated this signal |
| trendline_grade | string | Yes | Grade of the trendline (e.g., "A+", "A", "B+", "B") |
| touch_count | integer | Yes | Number of times price touched the trendline |
| signal_timestamp | datetime | Yes | When the trendline break was detected |
| confidence_score | Decimal | Yes | Engine confidence score (0.0 to 1.0) |
| candle_spacing | string | No | Timeframe of the trendline (e.g., "5m", "15m", "1h", "4h") |
| slope | Decimal | No | Trendline slope value |
| duration_candles | integer | No | Number of candles the trendline spans |

**Processing Logic**:

1. Subscribe to Redis channel `trendedge:signals:internal` on application startup.
2. When a message is received, deserialize the JSON payload.
3. Validate that all required fields are present. If any required field is missing, log `ERROR: Internal signal missing required field '{field_name}'. Signal discarded. Payload: {truncated_payload}` and discard the signal.
4. Verify the signal originates from an authenticated trendline engine process by checking the `process_auth_token` field against the configured internal service token stored in environment variable `INTERNAL_SERVICE_TOKEN`. If the token is missing or does not match, log `SECURITY: Unauthorized internal signal attempt. Token: {masked_token}` and discard.
5. Create a `Signal` record with `source = 'INTERNAL'` and `status = 'RECEIVED'`.
6. Store the full raw payload in `source_metadata` as JSON.
7. Pass the Signal to the normalization pipeline (EX-FR-004).

**Outputs**:
- A persisted `Signal` record with `status = 'RECEIVED'` and `source = 'INTERNAL'`.
- Signal ID returned to the internal message bus as acknowledgment.

**Business Rules**:
- Internal signals are trusted at a higher level than webhook signals but still must pass all validation and risk checks.
- Internal signals always include trendline metadata; this metadata is preserved through the entire pipeline for journaling.
- The entry_type for internal signals defaults to `MARKET` unless the trendline engine explicitly specifies `LIMIT`.

**Error Handling**:

| Error Condition | System Behavior | Log Level |
|---|---|---|
| Redis pub/sub connection lost | Attempt reconnection with exponential backoff (1s, 2s, 4s, 8s, 16s, 32s, max 60s). Queue is maintained by Redis; messages published during reconnection will be lost unless Redis Streams are used. | ERROR |
| Malformed JSON payload | Discard signal. Log raw payload (truncated to 1000 chars). | ERROR |
| Missing required field | Discard signal. Log field name and signal payload. | ERROR |
| Invalid process auth token | Discard signal. Log attempt with masked token. | SECURITY |
| Database write failure | Retry 3 times with 1s delay. If all retries fail, log and discard. | CRITICAL |

**Edge Cases**:
- If the trendline engine publishes the same signal twice (e.g., due to a restart), the deduplication check (EX-FR-015) will catch it downstream.
- If the trendline engine sends a signal with a `trendline_id` that does not exist in the database, the signal is still processed (the trendline_id is stored as metadata but not validated via foreign key at signal receipt time; validation occurs during enrichment).

---

### 3.2 EX-FR-002: TradingView Webhook Signal Source

**Source**: PRD-003 Section 3.2, US-EX-002

**Description**: The system accepts TradingView alert webhooks via a unique per-user HTTP POST endpoint. Each user receives a unique webhook URL containing a cryptographically random identifier.

**Inputs**:

HTTP Request:
- Method: `POST`
- URL: `/api/v1/webhooks/tradingview/{user_webhook_id}`
- Content-Type: `application/json`
- Optional Header: `X-Signature` (HMAC-SHA256 signature)

JSON Body (primary format):

| Field | Type | Required | Alternatives | Description |
|---|---|---|---|---|
| key | string | Conditional | `api_key` | User API key (required if HMAC not used) |
| ticker | string | Yes | `symbol` | TradingView symbol (e.g., "NQ1!", "ES1!") |
| action | string | Yes | `side`, `order` | Trade direction: "buy", "sell", "close" |
| price | number | Yes | -- | Current price or entry price |
| stop | number | No | `sl` | Stop loss price |
| target | number | No | `tp` | Take profit price |
| quantity | integer | No | `qty`, `contracts` | Number of contracts (default: calculated by risk engine) |
| timeframe | string | No | -- | Chart timeframe (e.g., "240" for 4h) |
| message | string | No | -- | Free-text alert message |
| timestamp | string | No | -- | ISO 8601 timestamp of the alert |

**Processing Logic**:

1. Receive HTTP POST request at `/api/v1/webhooks/tradingview/{user_webhook_id}`.
2. Rate limit check (EX-FR-009): query Redis key `ratelimit:webhook:{user_webhook_id}` using sliding window. If over limit, return HTTP 429.
3. Look up `user_webhook_id` in the `webhook_urls` table. If not found, return HTTP 404 with body `{"error": "Webhook URL not found"}`.
4. Authenticate the request (EX-FR-006):
   a. If `X-Signature` header is present, compute HMAC-SHA256 of the raw request body using the user's webhook secret. Compare using `hmac.compare_digest()`. If mismatch, return HTTP 401 with body `{"error": "Invalid signature"}`.
   b. Else if `key` or `api_key` field is present in the body, hash the provided key with SHA-256 and compare against the stored hash. If mismatch, return HTTP 401 with body `{"error": "Invalid API key"}`.
   c. Else, the webhook URL path itself serves as minimum authentication (the 32+ character random ID acts as a shared secret).
5. Parse the JSON body. Handle alternative field names: map `symbol` to `ticker`, `side`/`order` to `action`, `sl` to `stop`, `tp` to `target`, `qty`/`contracts` to `quantity`.
6. Validate required fields (`ticker`, `action`, `price`). If missing, return HTTP 400 with body `{"error": "Missing required field: {field_name}"}`.
7. Validate `action` value: must be one of `buy`, `sell`, `close` (case-insensitive). If invalid, return HTTP 400 with body `{"error": "Invalid action '{value}'. Must be 'buy', 'sell', or 'close'"}`.
8. Check replay attack prevention (EX-SEC-006): if `timestamp` is present and older than 5 minutes, return HTTP 400 with body `{"error": "Request timestamp too old. Maximum age: 5 minutes"}`. Check Redis set `webhook:processed:{user_webhook_id}` for the request body hash; if found, return HTTP 400 with body `{"error": "Duplicate request detected"}`.
9. Create a `Signal` record with `source = 'WEBHOOK'` and `status = 'RECEIVED'`. Store the entire raw JSON payload (including unrecognized fields) in `source_metadata`.
10. Return HTTP 200 immediately with body: `{"signal_id": "{uuid}", "status": "received", "message": "Signal accepted for processing"}`.
11. Continue processing asynchronously: pass the Signal to the normalization pipeline (EX-FR-004) via an async task (Celery task or asyncio background task).

**Outputs**:
- HTTP 200 response with signal_id (synchronous, within 2 seconds).
- Persisted `Signal` record with `status = 'RECEIVED'` and `source = 'WEBHOOK'`.

**Business Rules**:
- The HTTP 200 response must be returned within 2 seconds regardless of downstream processing time. TradingView will retry if it does not receive a response within its timeout window.
- The `close` action maps to closing an existing open position in the specified instrument. If no open position exists, the signal is rejected during validation with reason `NO_OPEN_POSITION_TO_CLOSE`.
- Unrecognized fields in the JSON body are preserved in `source_metadata` for journaling purposes. They are never rejected.
- The `price` field from TradingView represents the price at the time the alert fired, not necessarily the desired entry price. For market orders, this serves as the reference price for slippage calculation.

**Error Handling**:

| HTTP Status | Condition | Response Body |
|---|---|---|
| 200 | Valid signal accepted | `{"signal_id": "uuid", "status": "received", "message": "Signal accepted for processing"}` |
| 400 | Missing required field | `{"error": "Missing required field: {field_name}"}` |
| 400 | Invalid action value | `{"error": "Invalid action '{value}'. Must be 'buy', 'sell', or 'close'"}` |
| 400 | Stale timestamp | `{"error": "Request timestamp too old. Maximum age: 5 minutes"}` |
| 400 | Duplicate request | `{"error": "Duplicate request detected"}` |
| 400 | Malformed JSON | `{"error": "Invalid JSON in request body"}` |
| 401 | Invalid API key | `{"error": "Invalid API key"}` |
| 401 | Invalid HMAC signature | `{"error": "Invalid signature"}` |
| 404 | Unknown webhook URL | `{"error": "Webhook URL not found"}` |
| 413 | Request body too large | `{"error": "Request body too large. Maximum size: 64 KB"}` |
| 415 | Wrong content type | `{"error": "Content-Type must be application/json"}` |
| 429 | Rate limit exceeded | `{"error": "Rate limit exceeded. Maximum 10 requests per minute", "retry_after": {seconds}}` |
| 500 | Internal server error | `{"error": "Internal server error. Signal may not have been processed. Please check status."}` |

**Edge Cases**:
- TradingView sends the same alert multiple times (due to bar close recalculation): deduplication (EX-FR-015) catches this.
- TradingView sends an alert with `price: 0` or `price: null`: rejected by price validation (EX-FR-013).
- TradingView sends an alert for an instrument TrendEdge does not support (e.g., forex): rejected by instrument validation (EX-FR-011).
- Request body exceeds 64 KB: reject with HTTP 413 `{"error": "Request body too large. Maximum size: 64 KB"}`.
- Non-JSON content type: reject with HTTP 415 `{"error": "Content-Type must be application/json"}`.

---

### 3.3 EX-FR-003: Manual Signal Source

**Source**: PRD-003 Section 3.1, US-EX-003

**Description**: The dashboard provides a form for manual signal entry. The form validates all inputs client-side and server-side before creating a signal.

**Inputs**:

| Field | Type | Required | Validation | Default |
|---|---|---|---|---|
| instrument | string | Yes | Must be in supported instruments list. Searchable dropdown. | -- |
| direction | enum | Yes | `LONG` or `SHORT` | -- |
| entry_type | enum | Yes | `MARKET` or `LIMIT` | `MARKET` |
| entry_price | Decimal | Conditional | Required for LIMIT orders. Pre-filled with last price for MARKET orders. Must be > 0. | Last market price |
| stop_loss_price | Decimal | No | If provided, must be on correct side of entry. | -- |
| take_profit_price | Decimal | No | If provided, must be on correct side of entry. | -- |
| quantity | integer | No | Must be >= 1 and <= max position size. | Calculated by risk engine |
| notes | string | No | Max 500 characters. | -- |

**Processing Logic**:

1. User submits the form via `POST /api/v1/signals/manual`.
2. Authenticate the user via session token (Bearer token in Authorization header). If invalid, return HTTP 401 `{"error": "Authentication required"}`.
3. Validate all inputs server-side (never trust client-side validation alone):
   a. `instrument`: must exist in the `supported_instruments` reference table. If not found, return HTTP 400 `{"error": "Unsupported instrument '{value}'. See /api/v1/instruments for supported instruments."}`.
   b. `direction`: must be `LONG` or `SHORT`. If invalid, return HTTP 400 `{"error": "Direction must be 'LONG' or 'SHORT'"}`.
   c. `entry_type`: must be `MARKET` or `LIMIT`. If invalid, return HTTP 400 `{"error": "Entry type must be 'MARKET' or 'LIMIT'"}`.
   d. `entry_price`: for LIMIT orders, must be provided and > 0. If missing for LIMIT, return HTTP 400 `{"error": "Entry price is required for LIMIT orders"}`.
   e. `stop_loss_price`: if provided, validated in EX-FR-013.
   f. `take_profit_price`: if provided, validated in EX-FR-013.
   g. `quantity`: if provided, must be integer >= 1 and <= the user's max position size for this instrument.
   h. `notes`: if provided, must be <= 500 characters.
4. Create a `Signal` record with `source = 'MANUAL'` and `status = 'RECEIVED'`.
5. Return HTTP 201 with body: `{"signal_id": "{uuid}", "status": "received", "message": "Manual signal submitted for processing"}`.
6. Process the signal synchronously (manual signals are user-initiated and the user expects immediate feedback). The response may alternatively be returned after validation and risk checks complete, with the signal status reflecting the outcome.

**Outputs**:
- HTTP 201 response with signal_id.
- Persisted `Signal` record.

**Business Rules**:
- Manual signals do NOT carry trendline metadata (`trendline_id` and `trendline_grade` are null).
- If stop_loss_price and take_profit_price are both omitted, the signal is accepted but flagged with a warning: "No stop loss or take profit specified. Consider adding risk levels." The warning is returned in the response and displayed on the dashboard. The signal proceeds through the pipeline; the risk check for minimum R:R (EX-FR-019 in FSD-003b) will reject it if R:R cannot be calculated.
- Manual signals are NOT subject to the signal staleness check since they are submitted in real-time by the user.

**Error Handling**:

| HTTP Status | Condition | Response Body |
|---|---|---|
| 201 | Signal accepted | `{"signal_id": "uuid", "status": "received", "message": "Manual signal submitted for processing"}` |
| 400 | Validation failure | `{"error": "{specific validation message}", "field": "{field_name}"}` |
| 401 | Not authenticated | `{"error": "Authentication required"}` |
| 403 | Account suspended | `{"error": "Your account is suspended. Contact support."}` |
| 429 | Manual submission rate limit | `{"error": "Too many manual signals. Maximum 5 per minute."}` |

**Edge Cases**:
- User submits a MARKET order during a market holiday or weekend: the order is constructed but the broker will reject it. The rejection is captured and the user is notified.
- User submits a LIMIT order with an entry price very far from the current market (>5% tolerance): rejected by price validation (EX-FR-013) with message `"Entry price {price} is more than 5% from current market price {market_price} for {instrument}"`.

---

### 3.4 EX-FR-004: Signal Normalization

**Source**: PRD-003 Section 3.1

**Description**: All signals, regardless of source, are normalized into a canonical `Signal` data structure before entering the validation pipeline.

**Inputs**: Raw signal data from any of the three sources (internal, webhook, manual).

**Processing Logic**:

1. Map source-specific fields to canonical fields:
   - **Webhook**: `ticker` -> `instrument` (after symbol mapping), `action` -> `direction` (`buy` -> `LONG`, `sell` -> `SHORT`), `stop` -> `stop_loss_price`, `target` -> `take_profit_price`.
   - **Internal**: Fields already match canonical names. Confirm `direction` is uppercase enum.
   - **Manual**: Fields submitted via API already use canonical names.
2. Assign a UUID `id` to the signal if not already assigned.
3. Set `user_id` from the authenticated context.
4. Set `entry_type` to `MARKET` if not specified.
5. Set `quantity` to `null` if not specified (will be calculated in EX-FR-026, see FSD-003d).
6. Compute `risk_reward_ratio` if both `stop_loss_price` and `take_profit_price` are provided:
   - For LONG: `rr = (take_profit_price - entry_price) / (entry_price - stop_loss_price)`
   - For SHORT: `rr = (entry_price - take_profit_price) / (stop_loss_price - entry_price)`
   - Store as Decimal with 2 decimal places.
7. Set `status` to `RECEIVED`.
8. Set `created_at` to current UTC timestamp.
9. Set `is_paper` based on the user's current trading mode.
10. Persist the Signal record to the `signals` table.
11. Pass the normalized signal to validation (EX-FR-010 through EX-FR-015).

**Outputs**: A fully populated `Signal` record in the database with `status = 'RECEIVED'`.

**Business Rules**:
- The `close` action from webhooks is handled specially: direction is set to the opposite of the current open position's direction. If the user has a LONG position in the instrument, `close` maps to `SHORT` (and vice versa). If no open position exists, the signal is rejected during validation.
- The `risk_reward_ratio` field is computed but not enforced at this stage; enforcement happens in EX-FR-019 (see FSD-003b).

**Error Handling**:

| Error Condition | Behavior |
|---|---|
| Cannot determine direction from webhook `action` field | Reject signal with `status = 'REJECTED'`, `rejection_reason = "Cannot determine direction from action '{value}'"` |
| Division by zero in R:R calculation (entry == stop) | Set `risk_reward_ratio = null`, log warning. Signal proceeds; EX-FR-013 will reject based on stop distance < 1 tick. |

---

### 3.5 EX-FR-005: Unique Webhook URL Generation

**Source**: PRD-003 Section 3.2

**Description**: Each user receives a unique webhook URL with a cryptographically random identifier. Users can regenerate their URL at any time.

**Inputs**:
- Trigger: user registration, first broker connection, or explicit regeneration request.

**Processing Logic**:

1. Generate a webhook ID using `secrets.token_urlsafe(32)` (produces a 43-character URL-safe base64 string with 256 bits of entropy).
2. Store in `webhook_urls` table: `user_id`, `webhook_id`, `created_at`, `is_active = true`.
3. If regenerating, set the previous webhook URL's `is_active = false` and `deactivated_at = NOW()`. The old URL is immediately invalid.
4. Construct the full URL: `https://{domain}/api/v1/webhooks/tradingview/{webhook_id}`.
5. Return the URL to the user via the dashboard or API response.

**Outputs**:
- Full webhook URL displayed to the user (shown once, copyable).
- Stored record in `webhook_urls` table.

**Business Rules**:
- The webhook ID is NOT the user's UUID. It is a separate, opaque identifier.
- Only one webhook URL per user is active at a time. Regenerating invalidates the previous URL immediately.
- Deactivated webhook URLs are retained in the database for audit purposes (with `is_active = false`).
- The webhook URL is displayed in the dashboard settings page with a "Copy" button and a "Regenerate" button.
- Regeneration requires re-authentication (password or 2FA confirmation).

**Error Handling**:

| Error Condition | Behavior |
|---|---|
| Collision in webhook_id (astronomically unlikely with 256 bits) | Retry generation up to 3 times. If collision persists (should never happen), log CRITICAL error and return HTTP 500. |

---

### 3.6 EX-FR-006: Webhook Authentication

**Source**: PRD-003 Section 3.2

**Description**: Each webhook request is authenticated using one of three methods in priority order: HMAC signature, API key in payload, or webhook URL path validation.

**Processing Logic**:

1. **HMAC Signature** (highest security): If the `X-Signature` header is present:
   a. Retrieve the user's webhook secret from the database (looked up via the webhook URL's user_id).
   b. Compute the expected signature: `hmac.new(user_secret.encode(), request_body_bytes, hashlib.sha256).hexdigest()`.
   c. Compare using `hmac.compare_digest(expected_signature, provided_signature)` (constant-time comparison to prevent timing attacks).
   d. If match: authentication succeeds.
   e. If no match: return HTTP 401 `{"error": "Invalid signature"}`. Log: `SECURITY: HMAC validation failed for webhook {webhook_id}. IP: {client_ip}`.

2. **API Key in Payload** (medium security): If no `X-Signature` header but `key` or `api_key` field exists in the JSON body:
   a. Hash the provided key: `hashlib.sha256(provided_key.encode()).hexdigest()`.
   b. Compare the hash against the stored API key hash for the user.
   c. If match: authentication succeeds.
   d. If no match: return HTTP 401 `{"error": "Invalid API key"}`. Log: `SECURITY: API key validation failed for webhook {webhook_id}. IP: {client_ip}`.

3. **Webhook URL Path** (minimum security): If neither HMAC signature nor API key is present:
   a. The 32+ character random webhook ID in the URL path serves as a shared secret.
   b. If the webhook_id exists and is active: authentication succeeds.
   c. This is the minimum acceptable security level.

**Business Rules**:
- All failed authentication attempts are logged with the client IP address, webhook_id, and timestamp.
- After 10 failed authentication attempts within 1 hour for the same webhook_id, the webhook URL is temporarily suspended for 1 hour. The user is notified via email/Telegram.
- The user's webhook secret (for HMAC) is generated alongside the webhook URL and displayed once. It can be regenerated independently of the URL.

---

### 3.7 EX-FR-007 through EX-FR-009: Webhook Payload Parsing, Response, and Rate Limiting

**Source**: PRD-003 Section 3.2

**EX-FR-007 Payload Parsing**: Covered in EX-FR-002 processing logic steps 5-6. Alternative field names are mapped during normalization.

**EX-FR-008 Webhook Response**: Covered in EX-FR-002 processing logic step 10. The HTTP 200 response with `signal_id`, `status`, and `message` is returned within 2 seconds. Processing continues asynchronously.

**EX-FR-009 Rate Limiting**:

**Processing Logic**:

1. On each webhook request, check the Redis sliding window counter for the webhook URL:
   - Key: `ratelimit:webhook:{webhook_id}:minute` -- max 10 requests per 60-second window.
   - Key: `ratelimit:webhook:{webhook_id}:hour` -- max 100 requests per 3600-second window.
2. Implementation uses Redis sorted sets with timestamps as scores:
   a. `ZREMRANGEBYSCORE` to remove entries older than the window.
   b. `ZCARD` to count remaining entries.
   c. If count >= limit, return HTTP 429.
   d. Otherwise, `ZADD` the current timestamp and set TTL on the key to window_size + 1 second.
3. The `Retry-After` header is set to the number of seconds until the oldest entry in the window expires.

**Outputs**:
- HTTP 429 response when rate limit exceeded: `{"error": "Rate limit exceeded. Maximum 10 requests per minute", "retry_after": {seconds}}`.
- `Retry-After` header with seconds until the rate limit resets.

**Edge Cases**:
- If Redis is unavailable for rate limiting, the system SHALL allow the request through (fail-open for rate limiting) and log a warning. Rate limiting is a protective measure; failing closed would block legitimate signals.

---

### 3.8 EX-FR-010: Signal Authentication Validation

**Source**: PRD-003 Section 3.3

**Description**: Validates that each signal comes from an authenticated source appropriate to its type. This is a defense-in-depth check; primary authentication occurs at the ingestion point.

**Processing Logic**:

| Signal Source | Authentication Method | Validation |
|---|---|---|
| WEBHOOK | API key or HMAC signature | Already validated at HTTP endpoint (EX-FR-006). Double-check that `signal.user_id` matches the webhook URL's owner. |
| INTERNAL | Process auth token | Verify `process_auth_token` matches `INTERNAL_SERVICE_TOKEN` env var. Already validated at receipt (EX-FR-001). |
| MANUAL | Session token | Verify the Bearer token in the Authorization header is valid and not expired. Already validated at API endpoint (EX-FR-003). |

**Business Rules**:
- Authentication validation at this stage is a defense-in-depth check. Primary authentication occurs at the ingestion point.
- If authentication fails at this stage (should not happen in normal operation), the signal status is set to `REJECTED` with `rejection_reason = "Authentication failed at validation stage"` and a SECURITY-level log entry is created.

---

### 3.9 EX-FR-011: Instrument Validation

**Source**: PRD-003 Section 3.3

**Description**: Validates that the signal's instrument symbol maps to a supported futures contract.

**Processing Logic**:

1. Look up the instrument in the `supported_instruments` reference table.
2. If the instrument is a TradingView continuous contract symbol (e.g., "NQ1!", "ES1!"), map it to the specific contract month using EX-FR-012.
3. If the instrument is a generic TrendEdge symbol (e.g., "MNQ", "MES"), resolve it to the current front-month contract.
4. If the instrument cannot be resolved, reject the signal.

**Supported Instruments** (initial set):

| Symbol | Exchange | Full Name |
|---|---|---|
| MNQ | CME | Micro E-mini Nasdaq-100 |
| MES | CME | Micro E-mini S&P 500 |
| MYM | CBOT | Micro E-mini Dow Jones |
| M2K | CME | Micro E-mini Russell 2000 |
| MGC | COMEX | Micro Gold |
| MCL | NYMEX | Micro WTI Crude Oil |
| SIL | COMEX | Micro Silver |
| NQ | CME | E-mini Nasdaq-100 |
| ES | CME | E-mini S&P 500 |

**Error Handling**:

| Error | Signal Status | Rejection Reason |
|---|---|---|
| Instrument not in supported list | REJECTED | `"Unsupported instrument '{symbol}'. Supported instruments: MNQ, MES, MYM, M2K, MGC, MCL, SIL, NQ, ES"` |
| Expired contract month | REJECTED | `"Contract {symbol} has expired. Current front month is {front_month}"` |

---

### 3.10 EX-FR-012: Continuous Contract Symbol Mapping

**Source**: PRD-003 Section 3.3

**Description**: Maps TradingView continuous contract symbols (e.g., "NQ1!") to specific contract months based on rollover schedules and user preference for micro vs. full-size.

**Processing Logic**:

1. Receive a TradingView continuous symbol (e.g., "NQ1!").
2. Determine whether the user prefers micro or full-size contracts (stored in user settings, default: micro).
3. Look up the symbol mapping:

| TV Symbol | Micro Instrument | Full-Size Instrument |
|---|---|---|
| NQ1! | MNQ | NQ |
| ES1! | MES | ES |
| YM1! | MYM | YM |
| RTY1! | M2K | RTY |
| GC1! | MGC | GC |
| CL1! | MCL | CL |
| SI1! | SIL | SI |

4. Determine the current front-month contract:
   a. Query the `contract_calendar` table for the instrument family.
   b. The front month is the nearest contract whose expiration date is more than `rollover_days_before_expiry` business days in the future (default: 3 business days).
   c. If within the rollover window, map to the next month contract.
5. Construct the specific contract symbol: `{instrument}{month_code}{year_digit}` (e.g., "MNQH6" for Micro Nasdaq March 2026).

**Outputs**: The resolved specific contract symbol (e.g., "MNQH6") replaces the continuous symbol in the Signal record.

**Business Rules**:
- The rollover schedule is configurable per instrument family. Default: roll 3 business days before the contract's First Notice Day (for physically delivered) or Last Trading Day (for cash-settled).
- When a rollover occurs, all users with active webhook configurations receive a notification: "Symbol mapping has rolled from {old_contract} to {new_contract}".
- Users can override the automatic mapping by specifying exact contract symbols in their signals (e.g., "MNQH6" instead of "NQ1!").

**Edge Cases**:
- Signal arrives exactly on the rollover boundary (within the 3-day window): the signal maps to the new (next) contract month.
- User sends a signal for a back-month contract that TrendEdge does not track: rejected with `"Contract month {month} for {instrument} is not currently tracked. Front month is {front_month}"`.

---

### 3.11 EX-FR-013: Price Validation

**Source**: PRD-003 Section 3.3

**Description**: Validates that entry price, stop loss, and take profit are logically consistent and within market tolerance.

**Processing Logic**:

1. **Entry price tolerance**: Verify that `entry_price` is within 5% of the current market price for the instrument. The tolerance is configurable per user (stored in user settings).
   - Current market price is retrieved from the market data cache (Redis key `market:price:{instrument}`).
   - If market data is unavailable, skip this check and log a warning. The check is advisory; the broker will ultimately validate the price.
   - Validation: `abs(entry_price - market_price) / market_price <= tolerance`.
   - Failure message: `"Entry price {entry_price} is more than {tolerance*100}% from current market price {market_price} for {instrument}"`.

2. **Stop loss side validation**:
   - For LONG: `stop_loss_price < entry_price`. If violated: `"Stop loss ({stop_loss_price}) must be below entry price ({entry_price}) for LONG positions"`.
   - For SHORT: `stop_loss_price > entry_price`. If violated: `"Stop loss ({stop_loss_price}) must be above entry price ({entry_price}) for SHORT positions"`.

3. **Take profit side validation**:
   - For LONG: `take_profit_price > entry_price`. If violated: `"Take profit ({take_profit_price}) must be above entry price ({entry_price}) for LONG positions"`.
   - For SHORT: `take_profit_price < entry_price`. If violated: `"Take profit ({take_profit_price}) must be below entry price ({entry_price}) for SHORT positions"`.

4. **Minimum stop distance**: The stop distance must be at least 1 tick:
   - `stop_distance = abs(entry_price - stop_loss_price)`
   - Retrieve `tick_size` from the contract specification for the instrument.
   - If `stop_distance < tick_size`: `"Stop distance ({stop_distance}) must be at least 1 tick ({tick_size}) for {instrument}"`.

5. **Risk-reward ratio**: If both stop and target are provided, compute R:R and verify it meets the user's minimum (default 2.0). This is enforced later in EX-FR-019 (FSD-003b) but computed here for enrichment.

**Outputs**: Signal status updated to `VALIDATED` if all checks pass. If any check fails, status is set to `REJECTED` with the specific rejection reason.

**Edge Cases**:
- Stop loss price equals entry price: rejected (stop distance is 0, which is less than 1 tick).
- Take profit price equals entry price: rejected (target distance is 0; R:R would be 0).
- Both stop and target are missing (manual signal): signal proceeds with a warning; R:R cannot be computed. The R:R risk check in FSD-003b will reject unless the user has set minimum R:R to 0.

---

### 3.12 EX-FR-014: Signal Enrichment

**Source**: PRD-003 Section 3.3

**Description**: Enriches validated signals with contract specifications, computed risk fields, market context, and account context.

**Processing Logic**:

1. **Contract specification enrichment**: Look up the instrument in the `contract_specifications` table and attach:
   - `tick_size`: e.g., 0.25 for MNQ
   - `tick_value`: e.g., $0.50 for MNQ
   - `notional_value_per_contract`: current price * point value
   - `margin_requirement`: day trading margin for the instrument
   - `exchange`: e.g., "CME"

2. **Computed fields**:
   - `stop_distance_ticks = abs(entry_price - stop_loss_price) / tick_size`
   - `target_distance_ticks = abs(take_profit_price - entry_price) / tick_size`
   - `risk_per_contract = stop_distance_ticks * tick_value`
   - `reward_per_contract = target_distance_ticks * tick_value`
   - `risk_reward_ratio = reward_per_contract / risk_per_contract` (if risk_per_contract > 0)

3. **Market context**:
   - `session`: Determine if current time is RTH or ETH based on the instrument's exchange hours.
   - `day_of_week`: Monday through Friday (1-5).
   - `time_to_next_session_boundary`: minutes until RTH open/close.

4. **Trendline metadata** (if source is INTERNAL):
   - Already attached during signal creation (EX-FR-001). Verify `trendline_id`, `trendline_grade`, `touch_count`, `slope`, `duration_candles`, and `candle_spacing` are present.

5. **Account context**:
   - `current_position_same_instrument`: query `positions` table for OPEN positions in the same instrument for this user.
   - `current_daily_pnl`: sum of realized P&L for today's closed trades plus unrealized P&L for open positions.
   - `current_open_position_count`: count of all OPEN positions for this user.

6. Store all enrichment data in a `signal_enrichment` JSONB column or related table.

**Outputs**: The Signal record is updated with enrichment data. Status remains `VALIDATED`.

---

### 3.13 EX-FR-015: Signal Deduplication

**Source**: PRD-003 Section 3.3

**Description**: Detects and rejects duplicate signals within a configurable deduplication window.

**Processing Logic**:

1. Construct a deduplication key: `dedup:{user_id}:{instrument}:{direction}`.
2. Query Redis for existing entries within the deduplication window (default: 5 minutes):
   - Key: `dedup:{user_id}:{instrument}:{direction}`
   - Value: `{signal_id}:{entry_price}:{timestamp}`
3. For each existing entry, check if the new signal's entry price is within the tolerance (default: 2 ticks):
   - `abs(new_entry_price - existing_entry_price) <= 2 * tick_size`
4. If a match is found:
   - Set signal status to `REJECTED`.
   - Set `rejection_reason = "DUPLICATE_SIGNAL"`.
   - Log: `INFO: Duplicate signal detected for user {user_id}, instrument {instrument}. Original signal: {original_signal_id}. Duplicate: {new_signal_id}`.
   - Return without further processing.
5. If no match: add the new signal to the Redis dedup set with TTL equal to the deduplication window.

**Business Rules**:
- The deduplication window is configurable per user (default: 5 minutes, range: 1-30 minutes).
- The price tolerance is configurable per user (default: 2 ticks, range: 0-10 ticks).
- Deduplication applies across all signal sources. A webhook signal and an internal signal for the same instrument/direction/price within the window are considered duplicates.
- The first signal is always the one that proceeds; subsequent duplicates are rejected.

---

### 3.14 Handoff to Risk Management (FSD-003b)

After a signal passes through all stages in this subsystem (normalization, authentication, validation, enrichment, deduplication), it is handed off to the Risk Management Engine (FSD-003b) with:

- Signal status: `VALIDATED`
- All enrichment data populated (contract specs, computed fields, market/account context)
- Full audit trail of validation steps

The Risk Management Engine evaluates the signal against configurable risk parameters (position size, daily loss limit, concurrent positions, R:R minimum, correlation) before allowing it to proceed to order construction (FSD-003d).

---

## 4. Data Specifications

### 4.1 Database Tables

#### 4.1.1 `signals` Table

```sql
CREATE TABLE signals (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    source VARCHAR(20) NOT NULL CHECK (source IN ('INTERNAL', 'WEBHOOK', 'MANUAL')),
    source_metadata JSONB,
    instrument VARCHAR(20) NOT NULL,
    direction VARCHAR(5) NOT NULL CHECK (direction IN ('LONG', 'SHORT')),
    entry_type VARCHAR(10) NOT NULL CHECK (entry_type IN ('MARKET', 'LIMIT')),
    entry_price DECIMAL(12,4) NOT NULL,
    stop_loss_price DECIMAL(12,4),
    take_profit_price DECIMAL(12,4),
    quantity INTEGER DEFAULT 1,
    risk_reward_ratio DECIMAL(4,2),
    trendline_id UUID,
    trendline_grade VARCHAR(5),
    enrichment_data JSONB,
    status VARCHAR(20) NOT NULL DEFAULT 'RECEIVED'
        CHECK (status IN ('RECEIVED','VALIDATED','RISK_PASSED','EXECUTING','FILLED','REJECTED')),
    rejection_reason TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ,
    is_paper BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE INDEX idx_signals_user_id ON signals(user_id);
CREATE INDEX idx_signals_status ON signals(status);
CREATE INDEX idx_signals_instrument ON signals(instrument);
CREATE INDEX idx_signals_created_at ON signals(created_at);
CREATE INDEX idx_signals_user_instrument_direction ON signals(user_id, instrument, direction);
```

#### 4.1.2 `webhook_urls` Table

```sql
CREATE TABLE webhook_urls (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    webhook_id VARCHAR(64) NOT NULL UNIQUE,
    webhook_secret VARCHAR(128),
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deactivated_at TIMESTAMPTZ
);

CREATE INDEX idx_webhook_urls_webhook_id ON webhook_urls(webhook_id);
CREATE INDEX idx_webhook_urls_user_id ON webhook_urls(user_id);
```

#### 4.1.3 `contract_calendar` Table

```sql
CREATE TABLE contract_calendar (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    instrument_family VARCHAR(10) NOT NULL,
    contract_symbol VARCHAR(20) NOT NULL UNIQUE,
    month_code CHAR(1) NOT NULL,
    year INTEGER NOT NULL,
    first_notice_date DATE,
    last_trading_date DATE NOT NULL,
    expiration_date DATE NOT NULL,
    rollover_date DATE NOT NULL,
    is_front_month BOOLEAN NOT NULL DEFAULT FALSE,
    is_active BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE INDEX idx_contract_calendar_family ON contract_calendar(instrument_family);
CREATE INDEX idx_contract_calendar_front ON contract_calendar(instrument_family, is_front_month);
```

#### 4.1.4 `contract_specifications` Table

```sql
CREATE TABLE contract_specifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    symbol VARCHAR(10) NOT NULL UNIQUE,
    full_name VARCHAR(100) NOT NULL,
    exchange VARCHAR(10) NOT NULL,
    tick_size DECIMAL(10,6) NOT NULL,
    tick_value DECIMAL(10,4) NOT NULL,
    point_value DECIMAL(10,4) NOT NULL,
    contract_size DECIMAL(10,4),
    margin_day DECIMAL(10,2),
    margin_overnight DECIMAL(10,2),
    is_micro BOOLEAN NOT NULL DEFAULT TRUE,
    trading_hours_rth VARCHAR(50),
    trading_hours_eth VARCHAR(50)
);
```

#### 4.1.5 `execution_audit_log` Table (signal ingestion events only)

```sql
CREATE TABLE execution_audit_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    event_type VARCHAR(50) NOT NULL,
    event_data JSONB NOT NULL,
    ip_address INET,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_exec_audit_user_id ON execution_audit_log(user_id);
CREATE INDEX idx_exec_audit_event_type ON execution_audit_log(event_type);
CREATE INDEX idx_exec_audit_created_at ON execution_audit_log(created_at);
```

Events logged by this subsystem:

| Event Type | Logged Data |
|---|---|
| `signal.received` | Source, payload (sanitized), timestamp, IP address |
| `signal.validated` | Validation results, instrument resolution |
| `signal.rejected` | Rejection reason, which check failed |
| `webhook.auth_failed` | Webhook ID, IP address, failure reason |

### 4.2 Contract Specifications Reference Data

| Symbol | Full Name | Tick Size | Tick Value | Point Value | Exchange | Is Micro |
|---|---|---|---|---|---|---|
| MNQ | Micro E-mini Nasdaq-100 | 0.25 | $0.50 | $2.00 | CME | Yes |
| MES | Micro E-mini S&P 500 | 0.25 | $1.25 | $5.00 | CME | Yes |
| MYM | Micro E-mini Dow Jones | 1.00 | $0.50 | $0.50 | CBOT | Yes |
| M2K | Micro E-mini Russell 2000 | 0.10 | $0.50 | $5.00 | CME | Yes |
| MGC | Micro Gold | 0.10 | $1.00 | $10.00 | COMEX | Yes |
| MCL | Micro WTI Crude Oil | 0.01 | $1.00 | $100.00 | NYMEX | Yes |
| SIL | Micro Silver | 0.005 | $2.50 | $500.00 | COMEX | Yes |
| NQ | E-mini Nasdaq-100 | 0.25 | $5.00 | $20.00 | CME | No |
| ES | E-mini S&P 500 | 0.25 | $12.50 | $50.00 | CME | No |

### 4.3 Futures Month Codes

| Code | Month | | Code | Month |
|---|---|---|---|---|
| F | January | | N | July |
| G | February | | Q | August |
| H | March | | U | September |
| J | April | | V | October |
| K | May | | X | November |
| M | June | | Z | December |

### 4.4 Redis Key Patterns (this subsystem)

| Key Pattern | Type | TTL | Purpose |
|---|---|---|---|
| `trendedge:signals:internal` | Pub/Sub channel | -- | Internal signal delivery |
| `ratelimit:webhook:{webhook_id}:minute` | Sorted Set | 120s | Per-minute rate limiting |
| `ratelimit:webhook:{webhook_id}:hour` | Sorted Set | 7200s | Per-hour rate limiting |
| `dedup:{user_id}:{instrument}:{direction}` | Sorted Set | dedup_window + 60s | Signal deduplication |
| `market:price:{instrument}` | String | 30s | Latest market price cache (read-only; populated by FSD-010) |
| `webhook:processed:{webhook_id}` | Set | 300s | Replay attack prevention |

---

## 5. API Specifications

### 5.1 Webhook Endpoint

#### `POST /api/v1/webhooks/tradingview/{user_webhook_id}`

**Authentication**: Webhook ID path + optional API key or HMAC signature.
**Rate Limit**: 10/minute, 100/hour per webhook URL.
**Max Body Size**: 64 KB.

**Request**:
```json
{
  "key": "user_api_key_here",
  "ticker": "NQ1!",
  "action": "buy",
  "price": 18450.25,
  "stop": 18420.00,
  "target": 18510.50,
  "quantity": 1,
  "timeframe": "240",
  "message": "A+ trendline break"
}
```

**Response 200**:
```json
{
  "signal_id": "550e8400-e29b-41d4-a716-446655440000",
  "status": "received",
  "message": "Signal accepted for processing"
}
```

**Error Responses**: See EX-FR-002 error handling table.

### 5.2 Manual Signal Endpoint

#### `POST /api/v1/signals/manual`

**Authentication**: Bearer token (session token).
**Rate Limit**: 5/minute per user.

**Request**:
```json
{
  "instrument": "MNQ",
  "direction": "LONG",
  "entry_type": "MARKET",
  "entry_price": 18450.25,
  "stop_loss_price": 18430.00,
  "take_profit_price": 18490.50,
  "quantity": 2,
  "notes": "Support bounce setup"
}
```

**Response 201**:
```json
{
  "signal_id": "550e8400-e29b-41d4-a716-446655440001",
  "status": "received",
  "message": "Manual signal submitted for processing",
  "warnings": []
}
```

### 5.3 Signal Status Endpoint

#### `GET /api/v1/signals/{signal_id}`

**Authentication**: Bearer token. User can only access their own signals.

**Response 200**:
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "source": "WEBHOOK",
  "instrument": "MNQH6",
  "direction": "LONG",
  "entry_price": "18450.25",
  "stop_loss_price": "18420.00",
  "take_profit_price": "18510.50",
  "quantity": 1,
  "risk_reward_ratio": "2.97",
  "status": "FILLED",
  "created_at": "2026-02-11T14:30:00Z",
  "processed_at": "2026-02-11T14:30:04Z",
  "risk_checks": [
    {"check": "MAX_POSITION_SIZE", "result": "PASS", "actual": 1, "threshold": 2},
    {"check": "DAILY_LOSS_LIMIT", "result": "PASS", "actual": -150.00, "threshold": -500.00},
    {"check": "MAX_CONCURRENT_POSITIONS", "result": "PASS", "actual": 1, "threshold": 3},
    {"check": "MIN_RISK_REWARD", "result": "PASS", "actual": 2.97, "threshold": 2.00},
    {"check": "CORRELATION", "result": "PASS", "actual": 0.00, "threshold": 0.70}
  ]
}
```

### 5.4 Webhook Settings Endpoints

#### `GET /api/v1/settings/webhook`

Returns the user's webhook URL and API key (masked). Includes `webhook_url`, `api_key_prefix` (first 8 chars), `created_at`.

#### `POST /api/v1/settings/webhook/regenerate`

Regenerates the webhook URL. Requires re-authentication. Returns the new URL (shown once).

#### `POST /api/v1/settings/api-key/regenerate`

Regenerates the API key. Returns the new key (shown once, never again).

#### `PUT /api/v1/settings/webhook/ip-allowlist`

Configures IP allowlist for the webhook endpoint. Body: `{"ips": ["1.2.3.4", "5.6.7.0/24"]}`. Set to empty array to disable.

---

## 6. Security Specifications

### 6.1 Webhook Security

#### 6.1.1 HMAC Signature Validation (EX-SEC-004)

- The HMAC-SHA256 signature is computed over the raw request body bytes (not parsed JSON).
- The user's webhook secret is used as the HMAC key.
- Signature comparison uses `hmac.compare_digest()` (constant-time) to prevent timing attacks.
- The expected signature format in the `X-Signature` header is: hex-encoded HMAC-SHA256 digest (64 hex characters).

#### 6.1.2 Webhook URL Security (EX-SEC-005)

- Webhook IDs are generated using `secrets.token_urlsafe(32)`, producing 43 characters with 256 bits of entropy.
- Webhook IDs are not sequential, not predictable, and not derived from user data.
- Regenerating a webhook URL immediately invalidates the previous one. There is no grace period.

#### 6.1.3 Replay Attack Prevention (EX-SEC-006)

- If the webhook payload contains a `timestamp` field, the system rejects requests older than 5 minutes: `abs(now - timestamp) > 300 seconds`.
- The system maintains a Redis set (`webhook:processed:{webhook_id}`) of SHA-256 hashes of processed request bodies, with a 5-minute TTL. If a hash matches, the request is rejected as a duplicate.
- Both checks are applied. A request can be rejected by either the timestamp check or the body hash check.

### 6.2 API Key Management

#### 6.2.1 Key Generation (EX-SEC-007)

- API keys are generated using `secrets.token_urlsafe(32)` (256 bits of entropy).
- The plaintext key is shown to the user exactly once upon generation. It is displayed in a copyable field with a warning: "Copy this key now. It will not be shown again."
- The key is stored in the database as a SHA-256 hash. The plaintext is never persisted.
- Users can revoke their API key at any time from the dashboard. Revocation is immediate.
- Users can generate a new key, which automatically revokes the old key.

#### 6.2.2 Key Scoping (EX-SEC-008)

- Default API key scope: `signal:write` only (can submit signals via webhook).
- Additional scopes available: `order:read` (query order status), `position:read` (query positions).
- Scopes are stored as an array in the `api_keys` table.
- Requests with insufficient scope receive HTTP 403: `{"error": "API key does not have required scope: {scope}"}`.

### 6.3 IP Allowlisting for Webhooks (EX-SEC-010)

- Users can optionally configure an IP allowlist for their webhook endpoint via `PUT /api/v1/settings/webhook/ip-allowlist`.
- If configured, only requests from allowed IP addresses are accepted. Others receive HTTP 403: `{"error": "IP address not in allowlist"}`.
- TradingView's known webhook source IP ranges are documented in the dashboard settings and can be pre-configured with a single click.
- IP allowlisting is disabled by default (all IPs accepted).

### 6.4 Audit and Compliance

All signal ingestion events are logged to the `execution_audit_log` table (append-only):

| Event Type | Logged Data |
|---|---|
| `signal.received` | Source, payload (sanitized), timestamp, IP address |
| `signal.validated` | Validation results, instrument resolution |
| `signal.rejected` | Rejection reason, which check failed |
| `webhook.auth_failed` | Webhook ID, IP address, failure reason |

**Retention**: Minimum 7 years. Records are never deleted by application code. Archival to cold storage after 1 year is managed by the infrastructure layer.

---

## 7. Performance Specifications

### 7.1 Latency Targets

| Metric | Target (p50) | Target (p95) | Measurement Point |
|---|---|---|---|
| Webhook receipt to HTTP 200 response | < 500ms | < 2s | Time from request received to response sent |
| Internal signal receipt to normalization complete | < 200ms | < 500ms | Time from Redis message received to Signal persisted |
| Manual signal receipt to validation complete | < 500ms | < 1.5s | Time from API request received to validation result |
| Signal normalization + validation + enrichment | < 500ms | < 1s | Time from Signal RECEIVED to VALIDATED |
| Webhook receipt to handoff to risk engine | < 1s | < 2s | Time from request received to risk check start |
| Internal signal to handoff to risk engine | < 500ms | < 1s | Time from Redis message received to risk check start |

### 7.2 Throughput Targets

| Metric | Target | Notes |
|---|---|---|
| Concurrent signal processing | 50 signals/second across all users | Limited by database write throughput |
| Webhook requests per user | 10/minute, 100/hour | Rate limited |
| Manual signals per user | 5/minute | Rate limited |

### 7.3 Availability Targets

| Component | Target | Measurement |
|---|---|---|
| Webhook endpoint | 99.9% uptime | Measured monthly. Max 43 minutes downtime/month. |
| Signal processing pipeline | 99.9% uptime | Zero missed signals over 30 trading days. |

---

## 8. Testing Specifications

### 8.1 Signal Normalization Tests

| Test ID | Test Case | Input | Expected Output |
|---|---|---|---|
| UT-SN-001 | Normalize webhook buy signal | `{"ticker":"NQ1!","action":"buy","price":18450.25}` | Signal with instrument=resolved MNQ contract, direction=LONG, entry_type=MARKET |
| UT-SN-002 | Normalize webhook sell signal | `{"ticker":"ES1!","action":"sell","price":5200.50}` | Signal with direction=SHORT |
| UT-SN-003 | Normalize webhook close signal (LONG position open) | `{"ticker":"NQ1!","action":"close","price":18460}` | Signal with direction=SHORT (opposite of open position) |
| UT-SN-004 | Normalize webhook close signal (no position) | `{"ticker":"NQ1!","action":"close","price":18460}` | Signal REJECTED, reason: "NO_OPEN_POSITION_TO_CLOSE" |
| UT-SN-005 | Alternative field names | `{"symbol":"NQ1!","side":"buy","sl":18420,"tp":18510}` | Fields mapped correctly to canonical names |
| UT-SN-006 | R:R calculation LONG | entry=18450, stop=18430, target=18490 | R:R = (18490-18450)/(18450-18430) = 2.00 |
| UT-SN-007 | R:R calculation SHORT | entry=18450, stop=18470, target=18410 | R:R = (18450-18410)/(18470-18450) = 2.00 |
| UT-SN-008 | R:R when stop equals entry | entry=18450, stop=18450 | R:R = null, warning logged |

### 8.2 Price Validation Tests

| Test ID | Test Case | Input | Expected |
|---|---|---|---|
| UT-PV-001 | Entry within tolerance | entry=18450, market=18440 (0.05% diff) | PASS |
| UT-PV-002 | Entry outside tolerance | entry=18450, market=17000 (8.5% diff) | FAIL: "Entry price 18450 is more than 5% from current market price 17000" |
| UT-PV-003 | Stop below entry for LONG | direction=LONG, entry=18450, stop=18430 | PASS |
| UT-PV-004 | Stop above entry for LONG | direction=LONG, entry=18450, stop=18470 | FAIL: "Stop loss (18470) must be below entry price (18450) for LONG positions" |
| UT-PV-005 | Stop above entry for SHORT | direction=SHORT, entry=18450, stop=18470 | PASS |
| UT-PV-006 | Stop below entry for SHORT | direction=SHORT, entry=18450, stop=18430 | FAIL: "Stop loss (18430) must be above entry price (18450) for SHORT positions" |
| UT-PV-007 | Stop distance less than 1 tick (MNQ) | entry=18450.00, stop=18449.90, tick=0.25 | FAIL: "Stop distance (0.10) must be at least 1 tick (0.25)" |
| UT-PV-008 | Stop distance exactly 1 tick | entry=18450.00, stop=18449.75, tick=0.25 | PASS |

### 8.3 Symbol Mapping Tests

| Test ID | Test Case | Input | Expected |
|---|---|---|---|
| UT-SM-001 | NQ1! to micro front month | NQ1!, user prefers micro, current date Feb 2026, March contract active | MNQH6 |
| UT-SM-002 | NQ1! to full-size | NQ1!, user prefers full-size | NQH6 |
| UT-SM-003 | Near rollover (3 days before expiry) | March contract expires in 2 business days | Maps to June contract (MNQM6) |
| UT-SM-004 | Exact contract specified | MNQH6 (not continuous) | No mapping needed, passed through |
| UT-SM-005 | Expired contract | MNQZ5 when current is Feb 2026 | REJECTED: "Contract MNQZ5 has expired. Current front month is MNQH6" |

### 8.4 Deduplication Tests

| Test ID | Test Case | Input | Expected |
|---|---|---|---|
| UT-DD-001 | First signal passes | user=A, instrument=MNQ, direction=LONG, price=18450 | Signal accepted |
| UT-DD-002 | Duplicate within window | Same as UT-DD-001, submitted 30 seconds later | REJECTED: "DUPLICATE_SIGNAL" |
| UT-DD-003 | Similar price within tolerance | user=A, MNQ, LONG, price=18450.50 (1 tick diff, tolerance=2) | REJECTED: "DUPLICATE_SIGNAL" |
| UT-DD-004 | Different direction | user=A, MNQ, SHORT, price=18450 | Accepted (different direction) |
| UT-DD-005 | Different instrument | user=A, MES, LONG, price=5200 | Accepted (different instrument) |
| UT-DD-006 | Outside dedup window | Same as UT-DD-001, submitted 6 minutes later (window=5min) | Accepted |
| UT-DD-007 | Cross-source dedup | Webhook signal for MNQ LONG, then internal signal for same | Second signal REJECTED |

### 8.5 Webhook Security Tests

| Test ID | Test Case | Expected |
|---|---|---|
| ST-001 | POST webhook with invalid API key | HTTP 401 |
| ST-002 | POST webhook with valid HMAC, then tamper body | HTTP 401 |
| ST-003 | POST webhook with timestamp 10 min old | HTTP 400 (stale) |
| ST-004 | POST same webhook body twice in 5 min | Second rejected as duplicate |
| ST-005 | POST 20 webhooks in 1 minute | First 10 accepted, remaining get 429 |
| ST-008 | POST webhook from non-allowlisted IP (when allowlist active) | HTTP 403 |
| ST-009 | 10 failed webhook auth attempts in 1 hour | Webhook temporarily suspended |

### 8.6 End-to-End Ingestion Tests

#### 8.6.1 Webhook Signal Ingestion Flow

1. POST a TradingView-formatted webhook to the test user's webhook URL.
2. Verify HTTP 200 response with signal_id within 2 seconds.
3. Wait up to 5 seconds for async processing.
4. Query `GET /api/v1/signals/{signal_id}` and verify status is `VALIDATED` (or further if risk checks are configured to pass).
5. Verify the signal has correct instrument (mapped from TV continuous symbol), direction, entry_price, stop_loss_price, take_profit_price.
6. Verify enrichment data is populated (tick_size, tick_value, risk_per_contract, R:R ratio, session, market context).

#### 8.6.2 Duplicate Signal Rejection Flow

1. Submit a webhook signal (ticker=NQ1!, action=buy, price=18450).
2. Wait 1 second.
3. Submit the identical signal again.
4. Verify the first signal is processed (status=VALIDATED or further).
5. Verify the second signal is REJECTED with reason "DUPLICATE_SIGNAL".

---

## 9. Environment Configuration

| Variable | Description | Example |
|---|---|---|
| `INTERNAL_SERVICE_TOKEN` | Auth token for internal signal source | (generated secret) |
| `REDIS_URL` | Redis connection string | `redis://localhost:6379/0` |

---

## 10. Cross-References

| Sibling FSD | Handoff Point | Data Exchanged |
|---|---|---|
| **FSD-003b** (Risk Management Engine) | After signal is VALIDATED and enriched | Signal record with enrichment data, account context |
| **FSD-003c** (Broker Adapters) | N/A (no direct handoff from this subsystem) | -- |
| **FSD-003d** (Order Construction & Lifecycle) | N/A (no direct handoff from this subsystem) | -- |

| Related FSD | Integration Point |
|---|---|
| **FSD-001** | PostgreSQL and Redis infrastructure |
| **FSD-002** | Trendline detection engine emits internal signals consumed by this subsystem |
| **FSD-009** | User authentication (session tokens, user management) |
| **FSD-010** | Market data cache (Redis) used for price validation |
| **FSD-011** | Dashboard UI for manual signal entry form and webhook settings |

---

## Changelog

- 2026-02-11: Initial sub-FSD extracted from FSD-003 v1.0

---

*FSD-003a v1.0 -- Signal Ingestion & Normalization*
*TrendEdge -- February 2026*
