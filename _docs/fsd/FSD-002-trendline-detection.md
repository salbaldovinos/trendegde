# FSD-002: Trendline Detection Engine

**TrendEdge -- AI-Powered Futures Trading Platform**

| Field | Value |
|---|---|
| FSD ID | FSD-002 |
| Source PRD | PRD-002 |
| Title | Trendline Detection Engine |
| Version | 1.0 |
| Status | Draft |
| Author | Generated by Claude |
| Created | 2026-02-11 |

---

## 1. Introduction

### 1.1 Purpose

This Functional Specification Document (FSD) translates PRD-002 (Trendline Detection Engine & Alerts) into precise, implementable specifications. Every algorithm, data flow, state transition, error condition, and edge case is defined with sufficient detail that a developer can implement the complete feature without referencing the PRD or making design decisions independently.

### 1.2 Scope

**This document covers:**

- Market data ingestion pipeline (4H OHLCV candles) from multiple data sources
- Swing point (pivot) detection using N-bar confirmation
- Candidate trendline generation via exhaustive pairwise search
- Touch scoring with ATR-scaled tolerance
- Quality grading (A+, A, B) and composite score ranking
- Alert generation and routing for break, touch, new A+, and invalidation events
- Trendline lifecycle state machine (detected -> qualifying -> active -> traded -> invalidated -> expired)
- Per-user configuration management with validation and recalculation triggers
- Instrument watchlist management with tier-based limits
- Continuous futures contract symbol mapping and rollover handling
- All API endpoints, data models, error states, and performance requirements

**This document does NOT cover:**

- Trade execution logic (placing orders with brokers) -- [Cross-reference: see FSD-003 for trade execution details]
- Trade journaling and record-keeping -- [Cross-reference: see FSD-004 for trade journaling details]
- Playbook classification system -- [Cross-reference: see FSD-005 for playbook system details]
- Performance analytics and reporting -- [Cross-reference: see FSD-006 for analytics details]
- Notification infrastructure (channel delivery mechanics) -- [Cross-reference: see FSD-007 for notification system details]
- Dashboard and chart rendering -- [Cross-reference: see FSD-008 for dashboard details]
- ML-based false breakout filtering -- [Cross-reference: see FSD-009 for AI/ML features]
- Foundational platform infrastructure (auth, database, task queue) -- [Cross-reference: see FSD-001 for platform foundation]

### 1.3 Relationship to Source PRD

This FSD is derived from PRD-002 v1.0 (dated 2026-02-11). Every functional requirement (TD-FR-xxx) from the PRD is expanded into detailed behavioral specifications in Section 3. Non-functional requirements (TD-NFR-xxx) are addressed in Sections 9 (Performance) and 8 (Security). Testing requirements (TD-TEST-xxx) are mapped in Section 10.

### 1.4 Cross-References

| Related FSD | Relationship |
|---|---|
| FSD-001: Platform Foundation | Hard dependency. Provides database, auth, API framework, Celery/Redis, deployment. |
| FSD-003: Trade Execution Pipeline | Soft dependency. Consumes break alert payloads with bracket order specs. |
| FSD-004: Trade Journaling | Soft dependency. Receives trendline metadata when trades are logged. |
| FSD-005: Playbook System | Soft dependency. Uses trendline grade for auto-classification. |
| FSD-006: Performance Analytics | Soft dependency. Queries trendline metadata for win-rate analysis. |
| FSD-007: Notification System | Hard dependency. Routes alert payloads to Telegram, email, Discord, WebSocket. |
| FSD-008: Dashboard & Visualization | Soft dependency. Renders trendline overlay coordinates on charts. |
| FSD-009: AI/ML Features | Soft dependency. Consumes detection output for ML model training. |
| FSD-010: Market Data Service | Hard dependency. Provides OHLCV data feed; if not separately scoped, data ingestion is owned by this FSD. |
| FSD-011: Broker Adapters | Soft dependency. Provides contract symbol mapping and real-time data feeds. |

---

## 2. System Context

### 2.1 Architecture Position

The Trendline Detection Engine is a backend Python service that operates as a Celery worker process. It sits between the Market Data Service (upstream) and the Notification System / Trade Execution Pipeline (downstream). It has no direct user-facing UI; it exposes a REST API (FastAPI) consumed by the Dashboard frontend and other internal services.

### 2.2 Context Diagram Description

```
External Data Sources                TrendEdge Platform                    User Channels
=====================    ====================================    =====================

[yfinance API]  -------->|                                    |
[IBKR TWS API]  -------->|  Market Data Ingestion Layer       |
[Tradovate WS]  -------->|  (Celery Beat + Workers)           |
                          |         |                          |
                          |         v                          |
                          |  [PostgreSQL: candles table]       |
                          |         |                          |
                          |         v                          |
                          |  Trendline Detection Engine        |
                          |  (Celery Workers)                  |
                          |    - Pivot Detection               |
                          |    - Candidate Generation          |
                          |    - Touch Scoring                 |
                          |    - Quality Grading               |
                          |    - Ranking                       |
                          |    - Alert Evaluation              |
                          |         |                          |
                          |         v                          |
                          |  [PostgreSQL: pivots, trendlines,  |
                          |   alerts, trendline_events]        |
                          |         |                          |
                          |         v                          |
                          |  Alert Router                      |------> [Telegram Bot]
                          |  (via FSD-007 Notification System) |------> [Email/SMTP]
                          |         |                          |------> [Discord Webhook]
                          |         v                          |------> [WebSocket Push]
                          |  REST API (FastAPI)                |
                          |  /api/v1/trendlines/*              |------> [Dashboard UI]
                          |  /api/v1/config/*                  |
                          |  /api/v1/instruments/*             |
                          |====================================|
```

### 2.3 External Systems

| System | Protocol | Direction | Purpose |
|---|---|---|---|
| yfinance | HTTP REST | Inbound | Historical daily OHLCV bootstrap data |
| Interactive Brokers TWS | TCP Socket (IB API) | Inbound | Real-time and historical 4H OHLCV data |
| Tradovate | WebSocket | Inbound | Alternative real-time 4H OHLCV data |
| PostgreSQL (Supabase) | TCP/SQL | Bidirectional | Primary data store for all entities |
| Redis | TCP | Bidirectional | Celery task broker, result backend, caching |
| Notification System (FSD-007) | Internal Python call / Redis queue | Outbound | Alert delivery to user channels |
| Trade Execution Pipeline (FSD-003) | Internal event / Redis queue | Outbound | Break alert payloads with bracket order specs |

---

## 3. Functional Specifications

### 3.1 Market Data Ingestion

#### 3.1.1 Historical Data Bootstrapping

- **Source**: TD-FR-001, TD-FR-003
- **Description**: On initial setup or when a new instrument is added to a user's watchlist, the system fetches a minimum of 6 months of historical OHLCV candle data to provide sufficient history for trendline construction.

**Inputs:**
- Instrument identifier (symbol, e.g., "CL")
- Lookback period: minimum 6 months (approximately 180 calendar days)
- Data source priority: (1) IBKR TWS for 4H data, (2) yfinance for daily data as free fallback

**Processing Logic:**

1. Check if the instrument has existing candle data in the `candles` table.
2. If no data exists: fetch full 6-month history.
3. If data exists but has gaps: identify missing date ranges, fetch only the gaps.
4. For yfinance daily data:
   a. Map instrument symbol to Yahoo Finance ticker (CL -> "CL=F", GC -> "GC=F", PL -> "PL=F", YM -> "YM=F", MES -> "ES=F", MNQ -> "NQ=F").
   b. Call `yfinance.download(ticker, start=start_date, end=end_date, interval="1d")`.
   c. Parse returned DataFrame into candle records.
   d. Store with `timeframe='1D'` and `source='yfinance'`.
5. For IBKR 4H data:
   a. Establish TWS API connection using stored credentials.
   b. Request historical bars with `barSizeSetting='4 hours'`, `durationStr='6 M'`.
   c. Parse returned bars into candle records.
   d. Store with `timeframe='4H'` and `source='ibkr'`.
6. Deduplicate on `(instrument_id, timestamp, timeframe)` -- if a record already exists for that key, skip the insert (do not overwrite).

**Outputs:**
- Candle records persisted to `candles` table
- Log entry: `"Historical bootstrap complete for {symbol}: {count} candles fetched from {source}, {duplicates_skipped} duplicates skipped"`

**Error Handling:**

| Error Condition | Behavior | Log Message | User-Facing Message |
|---|---|---|---|
| yfinance returns empty DataFrame | Fall back to IBKR; if IBKR also fails, retry 3 times with 30-second intervals | `"ERROR: yfinance returned no data for {ticker}. Falling back to IBKR."` | "Historical data temporarily unavailable for {instrument}. Retrying..." |
| IBKR connection timeout (>30 seconds) | Retry 3 times with exponential backoff (5s, 15s, 45s) | `"ERROR: IBKR connection timeout for {symbol}, attempt {n}/3"` | "Broker connection timeout. Retrying..." |
| IBKR returns partial data (<80% of expected candles) | Accept partial data, log warning, schedule gap-fill task | `"WARN: IBKR returned {actual} candles, expected ~{expected} for {symbol}"` | None (background process) |
| Network failure (ConnectionError, DNS failure) | Retry 3 times with exponential backoff, then mark instrument as "data_pending" | `"ERROR: Network failure fetching data for {symbol}: {error_msg}"` | "Unable to fetch market data. Check your network connection." |
| Invalid ticker symbol | Do not retry; mark instrument as "invalid_symbol" | `"ERROR: Invalid ticker symbol {ticker} for {symbol}"` | "Instrument {symbol} has an invalid data source configuration." |
| Database write failure | Retry write 2 times; if persistent, rollback transaction and alert ops | `"CRITICAL: Database write failed for {symbol} candle batch: {error}"` | "System error saving market data. Our team has been notified." |

**Edge Cases:**
- Weekend/holiday gaps: yfinance and IBKR naturally exclude non-trading periods. The system SHALL NOT flag weekends (Saturday-Sunday) or exchange-defined holidays as data gaps.
- Instrument added during market close: bootstrap proceeds normally; the latest candle will be from the most recent market session.
- Instrument with less than 6 months of history (e.g., newly listed contract): fetch all available data, log a warning if fewer than 300 4H candles are available: `"WARN: Only {count} 4H candles available for {symbol}. Trendline detection may be limited."` The engine still runs detection but may produce fewer or lower-quality trendlines.

#### 3.1.2 Incremental Candle Ingestion

- **Source**: TD-FR-002, TD-FR-004, TD-FR-005
- **Description**: Every 4 hours during CME market hours, the system ingests the latest closed 4H candle for all active instruments.

**Inputs:**
- List of active instruments (all instruments on any user's watchlist where `is_active=true`)
- Current market session state (open/closed)
- Data source priority: (1) IBKR TWS, (2) Tradovate WebSocket, (3) yfinance daily (end-of-day only)

**Processing Logic:**

1. Celery Beat schedules the `ingest_4h_candles` task at the following UTC times during CME market hours (Sunday 23:00 UTC through Friday 21:00 UTC):
   - 01:00, 05:00, 09:00, 13:00, 17:00, 21:00 UTC (corresponding to the 4H candle boundaries for CME futures).
2. For each active instrument:
   a. Request the latest completed 4H candle from the primary data source (IBKR).
   b. If primary fails, fall back to secondary (Tradovate).
   c. Validate the candle: all OHLCV fields must be non-null and non-negative; high >= low; high >= open and close; low <= open and close; volume >= 0.
   d. Check for duplicate: query `candles` table for `(instrument_id, timestamp, '4H')`. If exists, skip.
   e. Insert validated candle into `candles` table.
   f. Trigger the trendline detection pipeline for this instrument (see Section 3.2-3.7).
3. After all instruments processed, run gap detection (see 3.1.3).

**Timing Requirement**: The entire process from candle close to database write SHALL complete within 15 seconds (p95) per TD-NFR-002.

**Outputs:**
- New candle record in `candles` table
- Celery task dispatched: `detect_trendlines_incremental(instrument_id)`
- Metrics emitted: `candle_ingestion_latency_ms`, `candle_ingestion_success` (boolean)

**Error Handling:**

| Error Condition | Behavior | Recovery |
|---|---|---|
| Primary source (IBKR) timeout | Fail over to Tradovate within 5 seconds | Log: `"WARN: IBKR timeout for {symbol}, failing over to Tradovate"` |
| Both primary and secondary fail | Schedule retry in 60 seconds, up to 3 retries | Log: `"ERROR: All data sources failed for {symbol}, retry {n}/3"` |
| All 3 retries exhausted | Mark candle as "missing", trigger gap-fill, alert ops via Telegram | Log: `"CRITICAL: Missed 4H candle for {symbol} at {timestamp}"` |
| Candle validation fails (e.g., high < low) | Reject candle, log error, do not store | Log: `"ERROR: Invalid candle data for {symbol}: high ({high}) < low ({low})"` |
| Market is closed (weekend/holiday) | Skip ingestion silently; Celery Beat task exits immediately | Log: `"INFO: Market closed, skipping candle ingestion"` |

**Edge Cases:**
- CME daily maintenance halt (16:00-17:00 CT / 22:00-23:00 UTC): no 4H candle closes during this window. The system SHALL NOT attempt ingestion during this period.
- Exchange early close (e.g., holiday shortened session): the system accepts whatever candles the exchange produces; shortened candles are valid.
- Duplicate task execution (Celery at-least-once delivery): the deduplication check on `(instrument_id, timestamp, timeframe)` prevents double-writes.

#### 3.1.3 Gap Detection and Fill

- **Source**: TD-FR-005
- **Description**: After each ingestion cycle, the system checks for missing candles in the expected sequence and automatically fills gaps.

**Processing Logic:**

1. For each active instrument, query the `candles` table for the last 30 days of 4H candles ordered by timestamp.
2. Compute the expected candle timestamps based on CME trading hours (6 candles per trading day, excluding weekends and the daily maintenance halt).
3. Identify any expected timestamps without a corresponding candle record.
4. For each gap:
   a. Attempt to fetch the missing candle from the primary data source.
   b. If unavailable, try secondary source.
   c. If still unavailable, log the gap and alert ops.
5. Gaps older than 7 days that cannot be filled are logged as permanent gaps: `"WARN: Permanent gap in {symbol} 4H data at {timestamp}. Trendline detection will interpolate."`.

**Outputs:**
- Filled candle records in `candles` table
- Gap report log: `"Gap detection for {symbol}: {filled_count} gaps filled, {unfilled_count} remain"`

#### 3.1.4 ATR Computation

- **Source**: TD-FR-008
- **Description**: The system computes the 14-period ATR (Average True Range) on 4H candles for each instrument, updated with each new candle.

**Processing Logic:**

1. Fetch the most recent 15 candles (14 periods + 1 for the initial true range) for the instrument.
2. For each consecutive pair of candles, compute True Range:
   ```
   TR = max(
     candle.high - candle.low,
     abs(candle.high - prev_candle.close),
     abs(candle.low - prev_candle.close)
   )
   ```
3. Compute ATR as the Exponential Moving Average (Wilder's smoothing) of TR over 14 periods:
   ```
   ATR_initial = mean(TR[0:14])
   ATR_n = (ATR_{n-1} * 13 + TR_n) / 14
   ```
4. Store the current ATR value associated with the instrument and the latest candle timestamp.
5. Also store per-candle ATR values for historical touch scoring (TD-FR-032).

**Outputs:**
- Current ATR value accessible via `get_current_atr(instrument_id) -> Decimal`
- Historical ATR values accessible via `get_atr_at_candle(instrument_id, candle_id) -> Decimal`

**Error Handling:**
- If fewer than 15 candles are available: compute ATR with available data (minimum 2 candles required). Log: `"WARN: ATR computed with only {count} periods for {symbol}. Accuracy may be reduced."`
- If zero candles available: ATR is null. Trendline detection is blocked for this instrument until sufficient data exists. Log: `"ERROR: Cannot compute ATR for {symbol}. No candle data available."`

---

### 3.2 Swing Point Detection

#### 3.2.1 Pivot High Detection

- **Source**: TD-FR-010, TD-FR-013, TD-FR-014, TD-FR-016
- **Description**: A pivot high is a candle whose high price is greater than or equal to the highs of N candles before it and N candles after it, where N is the user-configurable N-bar lookback (default: 5, range: 2-10).

**Inputs:**
- Array of 4H candles (ordered by timestamp ascending)
- N-bar lookback value from user configuration (default: 5)

**Processing Logic:**

1. Use `scipy.signal.find_peaks` on the `high` price series with `distance=N`.
2. For each detected peak at index `i`:
   a. Verify: `candles[i].high >= candles[j].high` for all `j` in `[i-N, i+N]` (excluding `i`).
   b. If verified, create a pivot record:
      - `type = 'HIGH'`
      - `price = candles[i].high`
      - `timestamp = candles[i].timestamp`
      - `candle_id = candles[i].id`
      - `n_bar_lookback = N`
3. Store pivot in the `pivots` table.

**Edge Cases:**
- Flat highs: When two adjacent candles have identical high prices, the leftmost (earlier) candle is selected as the pivot.
- Candle at the boundary (within N candles of the start or end of the data series): these candles CANNOT be confirmed as pivots because they lack sufficient context. They are excluded. The system requires at least N candles after a potential pivot to confirm it, meaning the most recent N candles never produce confirmed pivots.
- Single-candle spike (gap up then gap down): valid pivot high if it meets the N-bar rule.
- N=2 (Williams Fractals mode): produces more pivots; this is expected and correct behavior.

#### 3.2.2 Pivot Low Detection

- **Source**: TD-FR-011, TD-FR-013, TD-FR-014, TD-FR-016
- **Description**: A pivot low is a candle whose low price is less than or equal to the lows of N candles before it and N candles after it.

**Processing Logic:**

1. Use `scipy.signal.find_peaks` on the negated `low` price series (`-candles.low`) with `distance=N`.
2. For each detected trough at index `i`:
   a. Verify: `candles[i].low <= candles[j].low` for all `j` in `[i-N, i+N]` (excluding `i`).
   b. If verified, create a pivot record with `type = 'LOW'`, `price = candles[i].low`.
3. Store pivot in the `pivots` table.

**Edge Cases:**
- Same boundary and flat-value rules as pivot highs but inverted (flat lows: leftmost selected).

#### 3.2.3 Williams Fractals Alternative

- **Source**: TD-FR-012
- **Description**: When the user sets `pivot_n_bar_lookback = 2`, the system effectively uses Williams Fractals (N=2), producing higher-sensitivity pivot detection. No separate code path is needed; the same algorithm with N=2 produces Williams Fractal behavior.

**Behavior Note**: The system SHALL display a UI hint when N=2 is selected: "Williams Fractals mode (high sensitivity). More pivots will be detected, which may increase noise."

#### 3.2.4 Incremental Pivot Evaluation

- **Source**: TD-FR-015
- **Description**: When new candles arrive, the system evaluates only the region affected by the new data rather than recomputing all pivots.

**Processing Logic:**

1. On receipt of a new candle at index `i`:
   a. Re-evaluate the window `[i - N, i]` for potential new pivots.
   b. A candle at position `i - N` that was previously unconfirmed (too close to the end) may now be confirmable.
   c. Do NOT remove or modify previously confirmed pivots.
2. Full recalculation is triggered only when:
   a. User changes the N-bar lookback parameter.
   b. Contract rollover occurs (price adjustment changes historical values).
   c. A gap-fill inserts historical candles that could affect pivot detection.

---

### 3.3 Candidate Line Generation

#### 3.3.1 Exhaustive Pairwise Search

- **Source**: TD-FR-020, TD-FR-021, TD-FR-023, TD-FR-024, TD-FR-025, TD-FR-026
- **Description**: The system generates candidate trendlines by connecting all valid pairs of pivot points of the same type, then filters candidates that have been historically broken.

**Inputs:**
- Array of pivot highs (for resistance lines)
- Array of pivot lows (for support lines)
- Full candle dataset between anchor points
- User configuration (max slope, etc.)

**Processing Logic:**

1. For each pivot type (highs and lows separately):
   a. Let `pivots` = sorted array of pivots of that type, ordered by timestamp.
   b. For each pair `(pivots[i], pivots[j])` where `j > i`:
      - Construct a line through the two pivot points.
      - Compute slope in price-per-candle units: `slope_raw = (pivot_j.price - pivot_i.price) / (pivot_j.candle_index - pivot_i.candle_index)`.
      - Convert slope to degrees using normalized chart aspect ratio (see 3.3.3).
      - If `slope_degrees > config.max_slope_degrees`: reject this candidate immediately (early termination).
      - Run body-cross validation (see 3.3.2).
      - If validated, compute forward projection to the current candle (see 3.3.4).
      - Store the candidate with its anchor points, slope, direction, and projected price.

2. Total candidates evaluated: `N * (N-1) / 2` for each pivot type (highs and lows), where N is the number of pivots of that type.

**Outputs:**
- Array of validated candidate trendlines, each containing:
  - `anchor_pivot_1_id`, `anchor_pivot_2_id`
  - `direction` ('SUPPORT' or 'RESISTANCE')
  - `slope_raw` (price per candle)
  - `slope_degrees` (normalized)
  - `projected_price` (at current candle)

**Performance Constraint**: For 6 months of 4H data (~600 candles) with N=5, expect approximately 30-60 pivots per type, yielding 435-1,770 candidate pairs per type. This is well within the <10 second processing budget.

#### 3.3.2 Body-Cross Validation

- **Source**: TD-FR-023
- **Description**: A candidate line is rejected if any candle body between the anchor points closes on the "wrong side" of the line.

**Processing Logic:**

For each candle between anchor_pivot_1 and anchor_pivot_2 (exclusive):
1. Compute the projected line price at that candle's index: `line_price = anchor_1.price + slope_raw * (candle_index - anchor_1.candle_index)`.
2. For a SUPPORT line:
   - If `candle.close < line_price`: the body has closed below the support line. **Reject this candidate.**
   - Wick below the line (`candle.low < line_price`) is acceptable as long as the body (close) remains above.
3. For a RESISTANCE line:
   - If `candle.close > line_price`: the body has closed above the resistance line. **Reject this candidate.**
   - Wick above the line (`candle.high > line_price`) is acceptable.

**Important Distinction**: This check uses `candle.close` (body), NOT `candle.high` or `candle.low` (wicks). Wicks crossing the line are expected behavior (touches); body closes past the line indicate a break.

**Edge Case -- Close Exactly on the Line**: If `candle.close == line_price` (within floating-point tolerance of 0.0001), the candle is NOT considered a break. The close must be strictly past the line to constitute a break.

#### 3.3.3 Slope Normalization

- **Source**: TD-FR-024
- **Description**: Slope is computed in degrees, normalized to a standard chart aspect ratio so that slope comparisons are meaningful across instruments with different price scales.

**Processing Logic:**

1. Define a standard chart window: 3 months (approximately 270 4H candles on the x-axis).
2. Define a standard price range: the instrument's price range over the same 3-month window (high - low).
3. Compute the aspect ratio: `aspect = price_range / candle_count`.
4. Normalize the slope: `normalized_slope = slope_raw / aspect`.
5. Convert to degrees: `slope_degrees = arctan(normalized_slope) * (180 / pi)`.

**Rationale**: Without normalization, a $1/candle slope on Crude Oil (price ~$70) looks very different from a $1/candle slope on Gold (price ~$2000). The normalization ensures that a 45-degree line looks the same visually on any instrument's chart.

#### 3.3.4 Forward Projection

- **Source**: TD-FR-025
- **Description**: Each candidate line is extended forward from the last anchor point to the current candle to determine where price would need to be for a touch or break event.

**Processing Logic:**

1. Given anchor points at candle indices `i1` and `i2` with prices `p1` and `p2`:
   - `slope_raw = (p2 - p1) / (i2 - i1)`
   - For any target candle at index `t`: `projected_price = p1 + slope_raw * (t - i1)`
2. Compute `projected_price` at the current (latest) candle index.
3. Also compute:
   - `safety_line_price`: the projected price 4 candles forward from the current candle, used as the stop-loss level.
   - Distance from current price: `abs(current_close - projected_price)`.

#### 3.3.5 RANSAC Optimization

- **Source**: TD-FR-022
- **Description**: When the number of pivot points of a single type exceeds a configurable threshold (default: 50), the system switches from exhaustive pairwise search to RANSAC fitting.

**Processing Logic:**

1. Check pivot count: if `len(pivots) > 50`, use RANSAC.
2. Use `sklearn.linear_model.RANSACRegressor` with:
   - `min_samples = 2` (minimum points to fit a line)
   - `residual_threshold = config.touch_tolerance * current_atr`
   - `max_trials = 1000`
3. RANSAC returns inlier points that lie close to the fitted line.
4. Construct the candidate trendline from the RANSAC model's fitted line.
5. Re-validate using the same body-cross validation as exhaustive search.
6. RANSAC may produce multiple candidate lines by running iteratively after removing inliers from the previous fit.

**Note**: This is a Phase 2 (P1) feature. Phase 1 uses exhaustive search only.

---

### 3.4 Touch Scoring System

#### 3.4.1 Touch Detection

- **Source**: TD-FR-030, TD-FR-031, TD-FR-033
- **Description**: A "touch" is a candle (beyond the two anchor points) whose wick intersects the trendline within the ATR-scaled tolerance zone, without the body closing past the line.

**Inputs:**
- Candidate trendline (anchor points, slope)
- All candles in the trendline's range (from anchor_1 to current candle)
- ATR value (either current or historical per TD-FR-032)
- Touch tolerance multiplier T (default: 0.5, range: 0.2-1.5)

**Processing Logic:**

For each candle `c` in the range (excluding anchor point candles):
1. Compute `line_price` at candle `c`'s index (see 3.3.4).
2. Compute the tolerance zone: `tolerance = T * ATR`.
3. For a SUPPORT line:
   - The relevant wick is `candle.low`.
   - Touch condition: `line_price - tolerance <= candle.low <= line_price + tolerance`.
   - Additionally: `candle.close >= line_price` (body must NOT close below the line).
   - If both conditions met: this candle is a touch.
4. For a RESISTANCE line:
   - The relevant wick is `candle.high`.
   - Touch condition: `line_price - tolerance <= candle.high <= line_price + tolerance`.
   - Additionally: `candle.close <= line_price` (body must NOT close above the line).
   - If both conditions met: this candle is a touch.
5. If a candle's body closes past the line (`candle.close < line_price` for support or `candle.close > line_price` for resistance), this is a break, NOT a touch. The trendline is invalidated from that point forward per TD-FR-044.

**Edge Cases:**
- Candle with very long wick that touches the line on both sides (e.g., a doji spanning the line): if the close is on the valid side, this counts as a touch. If the close is on the invalid side, this is a break.
- Candle where `open == close` (pure doji) exactly on the line: treat as a touch, not a break, per the rule that close must be strictly past the line.

#### 3.4.2 Historical ATR for Touch Scoring

- **Source**: TD-FR-032
- **Description**: For historically accurate touch scoring, the system uses the 14-period ATR computed at the time of each candidate touch candle, not the current ATR.

**Processing Logic:**

1. For each candidate touch candle at index `i`, retrieve `ATR_at_candle_i` from stored per-candle ATR values.
2. Compute tolerance: `tolerance = T * ATR_at_candle_i`.
3. This ensures that touches during high-volatility periods use a wider tolerance and touches during low-volatility periods use a tighter tolerance.

**Note**: This is a Phase 2 (P1) feature. Phase 1 uses the current ATR for all touch evaluations.

#### 3.4.3 Spacing Enforcement

- **Source**: TD-FR-035
- **Description**: Consecutive touches must be separated by a minimum number of 4H candles. Touches closer than the minimum are collapsed.

**Processing Logic:**

1. Sort all touch candles by index (ascending).
2. Starting from the first touch, iterate through:
   a. If `touch[n+1].candle_index - touch[n].candle_index < config.min_candle_spacing`:
      - These two touches are too close together.
      - Keep the touch whose wick is closest to the trendline price at that candle's index.
      - Discard the other touch.
   b. Repeat until all consecutive pairs meet the minimum spacing.
3. The surviving touches are the qualifying touches.

**Example**: With `min_candle_spacing = 6`, if touches are detected at candle indices [10, 14, 25, 40], the pair (10, 14) has spacing of 4 (< 6). The system compares which of candle 10 or candle 14 has a wick closer to the line and keeps that one. Result might be [10, 25, 40] or [14, 25, 40].

#### 3.4.4 Spacing Quality Score

- **Source**: TD-FR-034
- **Description**: The spacing quality score measures how evenly spaced the touches are. Evenly spaced touches indicate a more reliable trendline.

**Processing Logic:**

1. Compute the gaps (in 4H candle count) between each consecutive pair of touches (including anchor points):
   `gaps = [touch[i+1].candle_index - touch[i].candle_index for i in range(len(touches)-1)]`
2. Compute: `spacing_quality = 1 - (std_dev(gaps) / mean(gaps))`.
3. Clamp the result to `[0.0, 1.0]`:
   - If `mean(gaps) == 0`: `spacing_quality = 0.0` (degenerate case).
   - If `std_dev(gaps) > mean(gaps)`: `spacing_quality = 0.0` (very irregular spacing).
   - If all gaps are identical: `spacing_quality = 1.0` (perfectly even spacing).

**Example**:
- Gaps = [20, 20, 20]: mean=20, std=0, quality = 1 - 0/20 = 1.0 (perfect)
- Gaps = [10, 30, 20]: mean=20, std=8.16, quality = 1 - 8.16/20 = 0.59
- Gaps = [5, 50, 10]: mean=21.67, std=19.74, quality = 1 - 19.74/21.67 = 0.09 (poor)

---

### 3.5 Quality Filtering and Grading

#### 3.5.1 Grade Assignment

- **Source**: TD-FR-040, TD-FR-042, TD-FR-043
- **Description**: Each candidate trendline receives a quality grade based on a rubric evaluating touch count, spacing, slope, duration, and entry zone.

**Grading Rubric (Default Parameters):**

| Criterion | A+ | A | B |
|---|---|---|---|
| Touch count (including anchors) | >= 3 | >= 3 | >= 2 |
| Min candle spacing between consecutive touches | >= 6 | >= 4 | >= 3 |
| Max slope (degrees) | < 45 | < 60 | < 75 |
| Min duration (calendar days from 1st to last touch) | >= 21 (3 weeks) | >= 14 (2 weeks) | >= 7 (1 week) |
| Entry zone: time from 1st touch to current price zone | >= 7 days (1 week) | >= 3 days | No minimum |

**Processing Logic:**

1. Evaluate the trendline against A+ criteria first (most restrictive).
2. If ALL A+ criteria are met: grade = 'A+'.
3. Else, evaluate against A criteria.
4. If ALL A criteria are met: grade = 'A'.
5. Else, evaluate against B criteria.
6. If ALL B criteria are met: grade = 'B'.
7. Else: trendline does NOT qualify. It SHALL NOT be stored or surfaced (TD-FR-041).

**User Configuration Override**: When a user has custom parameters (e.g., `min_touch_count = 4`), the grading rubric adjusts. Example: if user sets `min_touch_count = 4`, then A+ requires >= 4 touches, A requires >= 4 touches, and B requires >= 3 touches (the user's value replaces the A+ threshold, and lower grades shift accordingly).

**Specific Override Rules:**
- `min_touch_count` overrides the A+ touch count threshold. A and B thresholds become `max(original, min_touch_count - 1)` and `max(original, min_touch_count - 1)` respectively, but never below their original values.
- `min_candle_spacing` overrides the A+ spacing threshold. A threshold becomes `max(4, min_candle_spacing - 2)`. B threshold becomes `max(3, min_candle_spacing - 3)`.
- `max_slope_degrees` overrides the A+ slope threshold. A threshold becomes `min(60, max_slope_degrees + 15)`. B threshold becomes `min(75, max_slope_degrees + 30)`.
- `min_duration_days` overrides the A+ duration threshold. A threshold becomes `max(14, min_duration_days - 7)`. B threshold becomes `max(7, min_duration_days - 14)`.

#### 3.5.2 Entry Zone Evaluation

- **Source**: TD-FR-043
- **Description**: The entry zone requirement ensures the trendline has meaningful duration before the trader engages.

**Processing Logic:**

1. Compute the time difference between the first touch (anchor_pivot_1) timestamp and the current candle timestamp.
2. For A+ grade: this difference must be >= 7 calendar days (1 week).
3. For A grade: this difference must be >= 3 calendar days.
4. For B grade: no entry zone requirement.

**Rationale**: A trendline that was just created (first touch yesterday) does not have enough history to be trustworthy at the A+ level.

#### 3.5.3 Broken Line Rejection

- **Source**: TD-FR-044
- **Description**: A trendline that has been previously broken by a candle body close is permanently invalidated, even if price subsequently returned to the valid side.

**Processing Logic:**

1. During body-cross validation (Section 3.3.2), if any candle body crosses the line, the candidate is rejected.
2. Additionally, after a trendline is created and enters the lifecycle, if a new candle body closes past the line:
   a. The trendline transitions to `invalidated` state.
   b. It is NEVER re-qualified, even if subsequent candles close back on the valid side.
   c. A new trendline may form at a different angle through different anchor points.

#### 3.5.4 Grade Recomputation on Configuration Change

- **Source**: TD-FR-045
- **Description**: When a user changes their detection configuration, all trendlines for their watched instruments are re-graded.

**Processing Logic:**

1. On configuration change, dispatch Celery task: `recalculate_all_trendlines(user_id)`.
2. For each instrument in the user's watchlist:
   a. Re-run the full detection pipeline with the new configuration.
   b. Compare new grades to old grades for each trendline.
   c. If a trendline is promoted to A+ (was A or B, now A+): fire a "New A+ Trendline" alert.
   d. If a trendline is demoted below B: remove it from the surfaced list (do NOT delete the record; set `status = 'invalidated'` with reason `'config_change_demotion'`).
   e. If a trendline that was previously below threshold now qualifies: create it as a new trendline in the appropriate state.
3. Total recalculation time budget: < 60 seconds for all instruments (TD-NFR-007).

---

### 3.6 Trendline Ranking and Surfacing

#### 3.6.1 Composite Score Calculation

- **Source**: TD-FR-050, TD-FR-051, TD-FR-052
- **Description**: Each qualifying trendline receives a composite score used for ranking.

**Formula:**

```
composite_score = touch_count * spacing_quality * duration_factor * inverse_slope_factor
```

Where:
- `touch_count`: integer, the number of qualifying touches including anchor points (minimum 2).
- `spacing_quality`: float in [0.0, 1.0], computed per Section 3.4.4.
- `duration_factor = log2(duration_in_weeks + 1)`, where `duration_in_weeks = duration_days / 7.0`. This provides diminishing returns for very old trendlines.
- `inverse_slope_factor = 1 - (slope_degrees / 90)`. A perfectly horizontal line scores 1.0; a 45-degree line scores 0.5; a 90-degree line scores 0.0.

**Example Calculations:**

| Trendline | Touches | Spacing Quality | Duration (weeks) | Slope (deg) | Score |
|---|---|---|---|---|---|
| Line A | 4 | 0.85 | 6 | 20 | 4 * 0.85 * log2(7) = 2.807 * 0.778 = 2.18 ... 4 * 0.85 * 2.807 * 0.778 = 7.43 |
| Line B | 3 | 0.60 | 3 | 40 | 3 * 0.60 * log2(4) = 2.0 * 0.556 = ... 3 * 0.60 * 2.0 * 0.556 = 2.00 |
| Line C | 5 | 0.95 | 10 | 15 | 5 * 0.95 * log2(11) = 3.459 * 0.833 = ... 5 * 0.95 * 3.459 * 0.833 = 13.68 |

Line C ranks highest due to more touches, better spacing, longer duration, and flatter slope.

#### 3.6.2 Top-N Surfacing

- **Source**: TD-FR-053, TD-FR-054
- **Description**: The system surfaces the top N trendlines per instrument per direction, ranked by composite score.

**Processing Logic:**

1. Separate qualifying trendlines into support and resistance lists.
2. Sort each list by `composite_score` descending.
3. Take the top `config.max_lines_per_instrument` (default: 5, range: 1-10) from each list.
4. The surfaced set is: top-N support lines + top-N resistance lines (up to 2N total per instrument).

**Behavior When Fewer Than N Lines Qualify**: If only 2 support lines qualify, surface all 2. Do not pad with lower-quality lines. The UI should display: "2 of 5 support trendlines active" (not show empty slots).

#### 3.6.3 Proximity-Based Deprioritization

- **Source**: TD-FR-055
- **Description**: Trendlines far from the current price are deprioritized but not removed.

**Processing Logic:**

1. Compute the distance from current price to the trendline's projected price: `distance = abs(current_close - projected_price)`.
2. If `distance > 5 * current_atr`:
   a. Multiply the trendline's composite score by a decay factor: `adjusted_score = composite_score * (5 * ATR / distance)`.
   b. This naturally pushes far-away lines down the ranking without removing them.
3. Lines within 5x ATR retain their original composite score.

#### 3.6.4 Recalculation on New Candle

- **Source**: TD-FR-056
- **Description**: Rankings are recalculated on each new 4H candle close.

**Processing Logic:**

1. On new candle ingestion, trigger incremental trendline update:
   a. Check for new pivots in the affected window (Section 3.2.4).
   b. Re-evaluate touches for existing trendlines (new candle may add a touch).
   c. Update spacing quality if a new touch was added.
   d. Update duration (new candle extends duration by 4 hours).
   e. Update projected prices.
   f. Recompute composite scores.
   g. Re-rank and update the surfaced top-N set.
2. Performance budget: < 5 seconds per instrument (TD-NFR-005).

---

### 3.7 Alert Generation and Routing

#### 3.7.1 Trendline Break Alert

- **Source**: TD-FR-060, TD-FR-066, TD-FR-067, TD-FR-069
- **Description**: A break alert fires when a 4H candle's close price crosses past a qualifying trendline.

**Processing Logic:**

1. For each qualifying trendline (status in `['qualifying', 'active']`):
   a. Compute `projected_price` at the new candle's index.
   b. For SUPPORT lines: break occurs when `new_candle.close < projected_price`.
   c. For RESISTANCE lines: break occurs when `new_candle.close > projected_price`.
   d. If break detected:
      - Check deduplication: query `alerts` table for `(trendline_id, alert_type='break')`. If an alert already exists, do NOT fire another.
      - Compute bracket order specification (see 3.7.5).
      - Generate alert payload (see 3.7.6).
      - Transition trendline to `invalidated` state (if not traded) or leave in `traded` state (if trade was entered).
      - Route alert to notification system.

**What SHALL NOT Happen:**
- A break alert SHALL NOT fire for a wick-only crossing where the body closes on the valid side.
- A break alert SHALL NOT fire more than once per trendline. This is enforced by database deduplication AND an in-memory check.
- A break alert SHALL NOT fire for trendlines in `traded`, `invalidated`, or `expired` states.

**Edge Case -- Close Exactly on the Line**: `candle.close == projected_price` (within 0.0001 tolerance) is NOT a break. The close must be strictly past the line.

#### 3.7.2 Trendline Touch Alert

- **Source**: TD-FR-061
- **Description**: A touch alert fires when a candle's wick comes within the touch tolerance of a qualifying trendline without a body close past the line.

**Processing Logic:**

1. For each qualifying trendline:
   a. Compute `projected_price` at the new candle's index.
   b. Compute `tolerance = config.touch_tolerance * current_atr`.
   c. For SUPPORT lines:
      - Touch condition: `projected_price - tolerance <= new_candle.low <= projected_price + tolerance` AND `new_candle.close >= projected_price`.
   d. For RESISTANCE lines:
      - Touch condition: `projected_price - tolerance <= new_candle.high <= projected_price + tolerance` AND `new_candle.close <= projected_price`.
   e. If touch detected:
      - Add the touch to the trendline's `touch_points` array.
      - Increment `touch_count`.
      - Recalculate `spacing_quality` and `composite_score`.
      - Re-evaluate grade (touch may promote the grade).
      - Generate touch alert payload.
      - Route alert.

**Deduplication for Touch Alerts**: Touch alerts CAN fire multiple times for the same trendline (each new touch generates a new alert). However, the same candle SHALL NOT generate both a touch AND a break alert for the same trendline. Break takes precedence.

#### 3.7.3 New A+ Trendline Alert

- **Source**: TD-FR-062
- **Description**: An alert fires when a trendline's grade is promoted to A+.

**Processing Logic:**

1. After any grade recalculation (new touch, duration threshold crossed, config change):
   a. If the trendline's previous grade was 'A' or 'B' and the new grade is 'A+':
      - Check deduplication: query for `(trendline_id, alert_type='new_a_plus')`. If exists, do NOT fire.
      - Generate alert payload with the trendline's full metadata.
      - Route alert.
2. A trendline that was already A+ and remains A+ does NOT re-trigger this alert.

#### 3.7.4 Trendline Invalidated Alert

- **Source**: TD-FR-063
- **Description**: An alert fires when a previously qualifying trendline is broken without the trader having entered a trade.

**Processing Logic:**

1. When a break is detected on a trendline in `qualifying` or `active` state:
   a. If the trendline's status is NOT `traded`:
      - Generate invalidation alert payload.
      - Route alert.
   b. If the trendline's status IS `traded`:
      - Do NOT fire invalidation alert (the break is expected -- it triggered the trade).

#### 3.7.5 Bracket Order Specification

- **Source**: TD-FR-069, US-TD-018
- **Description**: Break alert payloads include a pre-computed bracket order for immediate trade evaluation.

**Processing Logic:**

1. **Entry price**: `new_candle.close` (the close that triggered the break).
2. **Stop loss (safety line)**: The trendline's projected price 4 candles forward from the break candle.
   - `stop_loss = projected_price_at(break_candle_index + 4)`.
   - For a SUPPORT break (short direction): stop loss is ABOVE entry.
   - For a RESISTANCE break (long direction): stop loss is BELOW entry.
3. **Risk (R)**: `abs(entry_price - stop_loss)`.
4. **Take profit (first S/R at >= 2R)**:
   - For a long trade: `target = entry_price + 2 * R` (minimum). The system checks for horizontal S/R levels at or beyond 2R and uses the nearest one. If no S/R level is found, use exactly 2R.
   - For a short trade: `target = entry_price - 2 * R` (minimum).
5. **Position size**: Computed from user's configured risk-per-trade amount divided by the R value, rounded down to the nearest whole contract.
   - `position_size = floor(risk_dollars_per_trade / (R * instrument.tick_value / instrument.tick_size))`.

**Edge Case -- Nonsensical Stop Loss**: If the safety line (4-candle projection) is on the same side as the entry (e.g., stop loss below entry on a long trade), the bracket order is flagged as `"bracket_valid": false` with reason `"Safety line is on the wrong side of entry. Manual review required."`.

#### 3.7.6 Alert Payload Schema

- **Source**: TD-FR-064, TD-FR-067

```json
{
  "alert_id": "uuid",
  "trendline_id": "uuid",
  "alert_type": "break | touch | new_a_plus | invalidated",
  "timestamp": "2026-02-11T13:00:00Z",
  "instrument": {
    "symbol": "CL",
    "name": "Crude Oil",
    "exchange": "NYMEX",
    "current_contract": "CLH26"
  },
  "direction": "LONG | SHORT",
  "trendline": {
    "grade": "A+",
    "touch_count": 4,
    "slope_degrees": 22.5,
    "duration_days": 45,
    "spacing_quality": 0.85,
    "composite_score": 7.43,
    "direction": "SUPPORT | RESISTANCE",
    "status": "active | invalidated"
  },
  "prices": {
    "projected_line_price": 72.45,
    "current_close": 71.80,
    "current_atr": 1.25
  },
  "bracket_order": {
    "bracket_valid": true,
    "entry_price": 71.80,
    "stop_loss_price": 73.20,
    "target_price": 69.00,
    "risk_r": 1.40,
    "reward_r_multiple": 2.0,
    "position_size": 2,
    "position_size_rationale": "$500 risk / ($1.40 * $10/tick / $0.01/tick) = 0.357 -> 0 contracts"
  }
}
```

**Note on position_size_rationale**: This is a human-readable explanation included for transparency. If `position_size` computes to 0 (risk too large for the configured risk-per-trade), the alert still fires but includes: `"bracket_valid": false, "reason": "Computed position size is 0 contracts. Risk per contract ($X) exceeds configured risk limit ($Y)."`.

#### 3.7.7 Alert Routing

- **Source**: TD-FR-065
- **Description**: Alerts are routed to the user's configured notification channels.

**Channels (by priority):**

| Channel | Priority | Delivery Mechanism | Latency Target |
|---|---|---|---|
| WebSocket (Dashboard) | P0 | Push via WebSocket connection to frontend | < 1 second |
| Telegram | P0 | Telegram Bot API `sendMessage` | < 5 seconds |
| Email | P1 | SMTP / SendGrid API | < 30 seconds |
| Discord | P1 | Discord Webhook POST | < 5 seconds |
| Push Notification | P2 | Firebase Cloud Messaging / APNs | < 10 seconds |

**Processing Logic:**

1. For each alert, determine the user's configured channels (from user notification preferences, managed by FSD-007).
2. For each enabled channel:
   a. Format the alert payload into the channel-specific message format (Telegram markdown, email HTML, Discord embed, etc.).
   b. Dispatch delivery to the notification system (FSD-007).
   c. Record delivery attempt in `alerts.channels_sent`: `{"channel": "telegram", "status": "sent", "timestamp": "..."}`.
3. If delivery fails for a channel:
   a. Retry up to 3 times with exponential backoff (1s, 3s, 9s).
   b. If all retries fail: record `"status": "failed"` and try the next channel.
   c. Alert is considered "delivered" if at least one channel succeeds.

**Alert Suppression During Quiet Hours (P2):**
- If the user has configured quiet hours (e.g., `quiet_hours_start = 20:00`, `quiet_hours_end = 06:00`, `quiet_hours_timezone = 'America/Chicago'`):
  a. Check if the current time in the user's timezone falls within the quiet window.
  b. If yes: queue the alert instead of delivering immediately.
  c. At the end of the quiet period, deliver all queued alerts in chronological order.
  d. Break alerts are NEVER suppressed (they are time-sensitive). Only touch and new_a_plus alerts are subject to quiet hours.

#### 3.7.8 Alert Deduplication

- **Source**: TD-FR-066
- **Description**: The system ensures exactly-once alert delivery for break and invalidation events.

**Processing Logic:**

1. Before generating any alert, query the `alerts` table:
   ```sql
   SELECT id FROM alerts
   WHERE trendline_id = :trendline_id
     AND alert_type = :alert_type
   LIMIT 1;
   ```
2. If a matching record exists: do NOT generate a new alert.
3. If no matching record exists: generate the alert and INSERT the record atomically (within the same database transaction as the trendline state transition).
4. This prevents duplicates even under concurrent Celery worker execution because the INSERT will fail on the unique constraint `(trendline_id, alert_type)` for break and invalidation types.

**Note**: Touch alerts do NOT have a uniqueness constraint on `(trendline_id, alert_type)` because multiple touches can occur on the same trendline. However, each touch alert includes the `trigger_candle_id`, and the constraint `(trendline_id, alert_type, trigger_candle_id)` prevents duplicate touch alerts for the same candle.

---

### 3.8 Trendline Lifecycle Management

#### 3.8.1 State Machine Definition

- **Source**: TD-FR-070 through TD-FR-078

**States:**

| State | Description | Entry Condition |
|---|---|---|
| `detected` | Line identified by candidate generation but not yet graded. | Candidate line passes body-cross validation. |
| `qualifying` | Line meets at least B grade criteria. | Grade evaluation assigns B, A, or A+. |
| `active` | Line meets A+ criteria and price is within actionable range. | Grade = A+ AND distance to current price <= 3 * ATR. |
| `traded` | A trade has been entered on this trendline. | Trade execution system confirms entry linked to this trendline_id. |
| `invalidated` | Line was broken without a trade or was manually dismissed. | Body close past line (no trade) OR user dismissal. |
| `expired` | Line has been qualifying/active for > 6 months without price interaction. | 6 months elapsed since last touch or state change. |

**State Transition Table:**

| From | Event | Guard Condition | To | Side Effects |
|---|---|---|---|---|
| `detected` | grade_evaluated | grade >= B | `qualifying` | Log state_change event. |
| `detected` | grade_evaluated | grade < B | (deleted) | Record not stored. |
| `qualifying` | grade_promoted | grade = A+ AND distance <= 3*ATR | `active` | Fire "New A+ Trendline" alert. Log state_change event. |
| `qualifying` | body_close_past_line | no trade entered | `invalidated` | Fire "Invalidated" alert. Log state_change event. |
| `qualifying` | user_dismissed | -- | `invalidated` | Log state_change event with reason "user_dismissed". |
| `qualifying` | expiration_check | 6 months since last interaction | `expired` | Log state_change event. |
| `qualifying` | config_change | grade drops below B | `invalidated` | Log state_change with reason "config_change_demotion". |
| `active` | trade_entered | linked trade confirmed | `traded` | Log state_change event. No further alerts. |
| `active` | body_close_past_line | no trade entered | `invalidated` | Fire "Break" alert + "Invalidated" alert. Log event. |
| `active` | user_dismissed | -- | `invalidated` | Log state_change with reason "user_dismissed". |
| `active` | price_moves_away | distance > 3*ATR | `qualifying` | Demote to qualifying. Log state_change event. |
| `active` | grade_demoted | grade < A+ due to config change | `qualifying` | Log state_change event. |
| `active` | expiration_check | 6 months since last interaction | `expired` | Log state_change event. |
| `traded` | -- | -- | (terminal state) | No further transitions. Trendline record preserved for analytics. |
| `invalidated` | -- | -- | (terminal state) | No further transitions. |
| `expired` | -- | -- | (terminal state) | No further transitions. |

**What SHALL NOT Happen:**
- A trendline SHALL NOT transition from `invalidated` back to `qualifying` or `active`. Once invalidated, always invalidated.
- A trendline SHALL NOT transition from `traded` to any other state.
- A trendline SHALL NOT transition from `expired` to any other state.
- A trendline in `traded` state SHALL NOT generate break or invalidation alerts.

#### 3.8.2 Lifecycle Event Logging

- **Source**: TD-FR-077
- **Description**: Every state transition and significant event is logged in the `trendline_events` table.

**Event Types:**

| Event Type | Trigger | old_value | new_value |
|---|---|---|---|
| `state_change` | Any state transition | `{"status": "qualifying"}` | `{"status": "active"}` |
| `touch_added` | New touch detected | `{"touch_count": 3}` | `{"touch_count": 4, "new_touch": {...}}` |
| `grade_change` | Grade promotion/demotion | `{"grade": "A"}` | `{"grade": "A+"}` |
| `score_update` | Composite score recalculated | `{"score": 5.2}` | `{"score": 7.4}` |

Each event record includes the `trigger_candle_id` (the candle that caused the event) for traceability.

#### 3.8.3 Manual Dismissal

- **Source**: TD-FR-078
- **Description**: Users can manually dismiss a trendline to stop receiving alerts.

**Processing Logic:**

1. User sends `PATCH /api/v1/trendlines/{trendline_id}/dismiss`.
2. Validate: trendline belongs to the requesting user (RLS enforced).
3. Validate: trendline is in `qualifying` or `active` state. If in `traded`, `invalidated`, or `expired`, return 400: `"Cannot dismiss a trendline in '{status}' state."`.
4. Transition to `invalidated` with event reason `"user_dismissed"`.
5. Stop all future alert generation for this trendline.
6. Return 200: `{"status": "invalidated", "reason": "user_dismissed"}`.

#### 3.8.4 One-Trade-Per-Trendline Rule

- **Source**: TD-FR-074, US-TD-019
- **Description**: Per the A+ strategy, each trendline supports at most one trade attempt.

**Processing Logic:**

1. When the trade execution system (FSD-003) confirms a trade entry linked to a `trendline_id`:
   a. Transition the trendline to `traded` state.
   b. No further break or touch alerts are generated for this trendline.
   c. The trendline remains visible on the chart with a distinct "traded" visual indicator.
2. If a second trade attempt is requested on the same trendline:
   a. Reject with: `"This trendline has already been traded. The A+ strategy allows one attempt per trendline."`.

---

### 3.9 Configuration Management

#### 3.9.1 Parameter Definitions

- **Source**: TD-FR-080, TD-FR-081

| Parameter | Field Name | Type | Default | Min | Max | Unit | Validation Error Message |
|---|---|---|---|---|---|---|---|
| Minimum touch count | `min_touch_count` | INTEGER | 3 | 2 | 5 | count | "Minimum touch count must be between 2 and 5." |
| Minimum candle spacing | `min_candle_spacing` | INTEGER | 6 | 3 | 20 | 4H candles | "Minimum candle spacing must be between 3 and 20." |
| Maximum slope angle | `max_slope_degrees` | INTEGER | 45 | 15 | 75 | degrees | "Maximum slope angle must be between 15 and 75 degrees." |
| Minimum duration | `min_duration_days` | INTEGER | 21 | 7 | 180 | days | "Minimum duration must be between 7 and 180 days." |
| Touch tolerance | `touch_tolerance_atr` | DECIMAL(3,1) | 0.5 | 0.2 | 1.5 | x ATR | "Touch tolerance must be between 0.2 and 1.5 ATR." |
| Pivot sensitivity | `pivot_n_bar_lookback` | INTEGER | 5 | 2 | 10 | bars | "Pivot sensitivity must be between 2 and 10 bars." |
| Max lines per instrument | `max_lines_per_instrument` | INTEGER | 5 | 1 | 10 | count | "Max lines per instrument must be between 1 and 10." |
| Quiet hours start | `quiet_hours_start` | TIME | null | -- | -- | local time | "Quiet hours start must be a valid time (HH:MM)." |
| Quiet hours end | `quiet_hours_end` | TIME | null | -- | -- | local time | "Quiet hours end must be a valid time (HH:MM)." |
| Quiet hours timezone | `quiet_hours_timezone` | VARCHAR(50) | null | -- | -- | IANA timezone | "Invalid timezone. Use IANA format (e.g., America/Chicago)." |

#### 3.9.2 Parameter Validation

- **Source**: TD-FR-082
- **Description**: All parameter changes are validated against the defined ranges before persisting.

**Processing Logic:**

1. On `PUT /api/v1/config`:
   a. Parse the request body.
   b. For each parameter present in the request:
      - Check type (integer, decimal, time, string as appropriate).
      - Check range (min/max).
      - If invalid: return 422 with the specific validation error message from the table above.
      - If multiple parameters are invalid: return ALL validation errors, not just the first one.
   c. If all valid: update the `user_detection_config` record.
   d. Trigger recalculation (see 3.9.3).

**Error Response Format:**
```json
{
  "error": "validation_error",
  "message": "One or more configuration parameters are invalid.",
  "details": [
    {"field": "min_touch_count", "value": 7, "message": "Minimum touch count must be between 2 and 5."},
    {"field": "touch_tolerance_atr", "value": 0.1, "message": "Touch tolerance must be between 0.2 and 1.5 ATR."}
  ]
}
```

**Quiet Hours Validation:**
- If `quiet_hours_start` is set, `quiet_hours_end` and `quiet_hours_timezone` must also be set. Return: `"Quiet hours require start time, end time, and timezone to all be set."`.
- If `quiet_hours_start == quiet_hours_end`: return `"Quiet hours start and end cannot be the same time."`.

#### 3.9.3 Recalculation Trigger

- **Source**: TD-FR-083
- **Description**: Configuration changes trigger a full trendline recalculation.

**Processing Logic:**

1. After a successful configuration update:
   a. Dispatch Celery task: `recalculate_all_trendlines.delay(user_id)`.
   b. Return the API response immediately (do not wait for recalculation).
   c. Include in response: `{"recalculation_status": "pending", "estimated_completion_seconds": 60}`.
2. The recalculation task:
   a. Fetches all instruments on the user's watchlist.
   b. For each instrument: runs the full detection pipeline with the new configuration.
   c. Compares results to existing trendlines and applies updates (see 3.5.4).
   d. On completion: pushes a WebSocket event to the user's dashboard: `{"event": "recalculation_complete", "instruments_processed": 6, "trendlines_updated": 15}`.

**Performance Budget**: < 60 seconds total. If exceeded, log a warning: `"WARN: Recalculation for user {user_id} took {duration}s, exceeding 60s budget."`.

#### 3.9.4 Reset to Defaults

- **Source**: TD-FR-084
- **Description**: Restores all parameters to the Tori Trades A+ strategy defaults.

**Processing Logic:**

1. On `POST /api/v1/config/reset`:
   a. Set all parameters to their default values (see table in 3.9.1).
   b. Clear `preset_name`.
   c. Trigger recalculation.
   d. Return 200: `{"message": "Configuration reset to defaults.", "recalculation_status": "pending"}`.

#### 3.9.5 Configuration Presets

- **Source**: TD-FR-085
- **Description**: Users can save and switch between named configuration presets.

**Built-in Presets:**

| Preset Name | touch_count | spacing | slope | duration_days | tolerance | n_bar |
|---|---|---|---|---|---|---|
| Tori A+ Strict | 3 | 6 | 45 | 21 | 0.5 | 5 |
| High Sensitivity | 2 | 3 | 60 | 7 | 1.0 | 2 |
| Conservative | 4 | 10 | 30 | 42 | 0.3 | 7 |

**Processing Logic:**

1. `GET /api/v1/config/presets`: Returns list of built-in presets + user's saved presets.
2. `POST /api/v1/config/presets`: Save current configuration as a named preset.
   - Validate: preset name must be 1-50 characters, alphanumeric + spaces + hyphens.
   - Validate: user cannot overwrite built-in preset names. Return 400: `"Cannot overwrite built-in preset '{name}'."`.
   - Maximum 10 user-created presets. Return 400: `"Maximum of 10 custom presets reached. Delete an existing preset first."`.
3. `PUT /api/v1/config/presets/{preset_name}/apply`: Apply a preset.
   - Load the preset's parameters, write to `user_detection_config`, trigger recalculation.
4. `DELETE /api/v1/config/presets/{preset_name}`: Delete a user-created preset.
   - Cannot delete built-in presets. Return 400: `"Cannot delete built-in preset '{name}'."`.

**Note**: This is a Phase 2 (P2) feature.

---

### 3.10 Instrument Management

#### 3.10.1 Phase 1 Instruments

- **Source**: TD-FR-090, TD-FR-094

| Symbol | Name | Exchange | Tick Size | Tick Value | Contract Months | Typical Roll |
|---|---|---|---|---|---|---|
| PL | Platinum | NYMEX | 0.10 | $5.00 | FJNV | 3rd-to-last business day |
| CL | Crude Oil | NYMEX | 0.01 | $10.00 | All months (FGHJKMNQUVXZ) | 3 days before 25th of prior month |
| GC | Gold | COMEX | 0.10 | $10.00 | GJMQVZ | Last trade day -2 of delivery month |
| YM | E-mini Dow | CBOT | 1.00 | $5.00 | HMUZ | 3rd Friday of expiry month |
| MES | Micro E-mini S&P 500 | CME | 0.25 | $1.25 | HMUZ | 3rd Friday of expiry month |
| MNQ | Micro E-mini Nasdaq 100 | CME | 0.25 | $0.50 | HMUZ | 3rd Friday of expiry month |

#### 3.10.2 Watchlist Management

- **Source**: TD-FR-091, TD-FR-092, TD-FR-093

**Adding an Instrument:**

1. User sends `POST /api/v1/watchlist` with `{"instrument_id": "uuid"}`.
2. Validate:
   - Instrument exists and `is_active = true`. If not: 404, `"Instrument not found or not available."`.
   - Instrument is not already on user's watchlist. If duplicate: 409, `"Instrument is already on your watchlist."`.
   - User has not exceeded tier limit:
     - Free tier: 3 instruments max. Error: `"Free plan allows up to 3 instruments. Upgrade to Trader plan for up to 10."`.
     - Trader tier: 10 instruments max. Error: `"Trader plan allows up to 10 instruments. Upgrade to Pro for unlimited."`.
     - Pro/Team tier: unlimited.
3. Insert record into `user_watchlist` with `is_active = true`.
4. Dispatch Celery task: `bootstrap_instrument.delay(user_id, instrument_id)`.
   - This task fetches historical data and runs initial trendline detection.
   - Completion target: < 2 minutes (TD-FR-092).
5. Return 201: `{"instrument_id": "...", "status": "bootstrapping", "estimated_completion_seconds": 120}`.
6. On bootstrap completion, push WebSocket event: `{"event": "instrument_ready", "instrument": "CL", "trendlines_detected": 8}`.

**Removing an Instrument:**

1. User sends `DELETE /api/v1/watchlist/{instrument_id}`.
2. Validate: instrument is on user's watchlist. If not: 404, `"Instrument is not on your watchlist."`.
3. Set `user_watchlist.is_active = false` (soft delete).
4. Stop alert generation for this instrument for this user.
5. Do NOT delete historical trendline data. Data is retained for analytics (TD-FR-093).
6. Return 200: `{"message": "Instrument removed from watchlist. Historical data retained."}`.

**Edge Cases:**
- User removes and re-adds the same instrument: on re-add, the existing `user_watchlist` record is reactivated (`is_active = true`). Historical data is already present, so bootstrap only fetches candles since the last stored candle. Trendline detection runs fresh.
- User adds an instrument during market close: bootstrap fetches up to the last available candle. Real-time ingestion begins when market opens.

---

### 3.11 Continuous Contract Symbol Mapping

#### 3.11.1 Contract Calendar

- **Source**: TD-FR-100, TD-FR-101

**Processing Logic:**

1. Each instrument has a set of valid contract months stored in `instruments.contract_months`.
2. The system computes the current front-month contract by:
   a. Determining the current date.
   b. Finding the next contract month that has not yet reached its roll date.
   c. Generating the contract symbol: `{root_symbol}{month_code}{year_digit}` (e.g., CL + H + 6 = CLH6 for March 2026 Crude Oil).
3. Roll trigger: the system rolls to the next contract when either:
   a. **Volume crossover**: the next-month contract's volume exceeds the current month's for 2 consecutive trading sessions, OR
   b. **Calendar trigger**: `N` trading days before the first notice day (configurable, default N=3).
4. The `instruments.current_contract` and `instruments.roll_date` fields are updated accordingly.

#### 3.11.2 Contract Rollover Handling

- **Source**: TD-FR-102, TD-FR-104, TD-FR-105

**Processing Logic:**

1. On roll day:
   a. Fetch the settlement prices for both the expiring and new contracts on the roll date.
   b. Compute the adjustment factor:
      - Back-adjusted (default): `adjustment = new_contract_settle - old_contract_settle`.
      - Ratio-adjusted: `adjustment = new_contract_settle / old_contract_settle`.
   c. Apply adjustment to ALL historical candle prices for this instrument:
      - Back-adjusted: `adjusted_price = raw_price + cumulative_adjustment`.
      - Ratio-adjusted: `adjusted_price = raw_price * cumulative_adjustment`.
   d. Store the roll adjustment in a `contract_rolls` table for audit.
   e. Update `instruments.current_contract` to the new contract symbol.
   f. Switch data ingestion to the new contract.
   g. Trigger full trendline recalculation for all users watching this instrument.

2. Trendline recalculation after roll:
   a. Anchor and touch point prices are updated to reflect the adjusted series.
   b. Slopes are recalculated.
   c. Grades and scores are recomputed.
   d. If a trendline changes grade due to the price adjustment, appropriate alerts are fired.

#### 3.11.3 Broker Symbol Mapping

- **Source**: TD-FR-103

| Generic Symbol | TradingView | IBKR | Tradovate |
|---|---|---|---|
| CL (March 2026) | CL1! | CL + expiry (CLH6) | CLH26 |
| GC (April 2026) | GC1! | GC + expiry (GCJ6) | GCJ26 |
| PL (April 2026) | PL1! | PL + expiry (PLJ6) | PLJ26 |
| YM (March 2026) | YM1! | YM + expiry (YMH6) | YMH26 |
| MES (March 2026) | ES1! -> MES | MES + expiry (MESH6) | MESH26 |
| MNQ (March 2026) | NQ1! -> MNQ | MNQ + expiry (MNQH6) | MNQH26 |

The mapping table is updated automatically on each contract roll.

---

## 4. Data Specifications

### 4.1 Data Models

All tables use UUID primary keys, TIMESTAMPTZ for timestamps (stored in UTC), and DECIMAL for prices. See the PRD Section 5.2 for the complete schema. The key tables are:

- **candles**: Raw OHLCV data. Unique on `(instrument_id, timestamp, timeframe)`.
- **instruments**: Instrument metadata including contract specifications.
- **pivots**: Detected swing points. FK to `candles` and `instruments`.
- **trendlines**: Detected and scored trendlines with full metadata. FK to `instruments`, `users`, and `pivots`.
- **trendline_events**: Audit log of all trendline lifecycle events. FK to `trendlines` and `candles`.
- **alerts**: Generated alerts with delivery status tracking. FK to `users` and `trendlines`.
- **user_detection_config**: Per-user configuration parameters. Unique on `user_id`.
- **user_watchlist**: User-to-instrument subscription. Unique on `(user_id, instrument_id)`.

### 4.2 Data Validation Rules

| Table | Field | Validation Rule |
|---|---|---|
| candles | open, high, low, close | Must be > 0. High >= max(open, close). Low <= min(open, close). |
| candles | volume | Must be >= 0. |
| candles | timestamp | Must be a valid 4H candle boundary for the instrument's exchange. |
| pivots | type | Must be 'HIGH' or 'LOW'. |
| pivots | n_bar_lookback | Must be 2-10. |
| trendlines | direction | Must be 'SUPPORT' or 'RESISTANCE'. |
| trendlines | grade | Must be 'A+', 'A', or 'B'. |
| trendlines | status | Must be one of: 'detected', 'qualifying', 'active', 'traded', 'invalidated', 'expired'. |
| trendlines | touch_count | Must be >= 2 (minimum 2 anchor points). |
| trendlines | spacing_quality | Must be in [0.0, 1.0]. |
| trendlines | slope | Must be in [0, 90) degrees. |
| alerts | alert_type | Must be one of: 'break', 'touch', 'new_a_plus', 'invalidated'. |

### 4.3 Data Retention

| Data Type | Retention | Notes |
|---|---|---|
| 4H and daily OHLCV candles | Indefinite | Required for trendline recalculation |
| Pivot points | Indefinite | Required for trendline recalculation |
| Active trendlines (detected, qualifying, active) | Indefinite | Core operational data |
| Terminal trendlines (traded, invalidated, expired) | 2 years, then archived to cold storage | Retained for analytics |
| Trendline events | 1 year | Audit trail |
| Alerts | 1 year | User-facing history |
| Processing logs | 90 days | Operational diagnostics |

---

## 5. API Specifications

### 5.1 Endpoint Inventory

All endpoints are prefixed with `/api/v1`. All require JWT authentication unless noted.

| Method | Path | Description | Auth |
|---|---|---|---|
| GET | `/trendlines/{instrument_id}` | List active trendlines for an instrument | JWT |
| GET | `/trendlines/{instrument_id}/history` | List all trendlines (including terminal) | JWT |
| GET | `/trendlines/{trendline_id}/detail` | Get full trendline detail with touches | JWT |
| PATCH | `/trendlines/{trendline_id}/dismiss` | Dismiss a trendline | JWT |
| GET | `/config` | Get current user detection config | JWT |
| PUT | `/config` | Update detection config | JWT |
| POST | `/config/reset` | Reset config to defaults | JWT |
| GET | `/config/presets` | List available presets | JWT |
| POST | `/config/presets` | Save current config as preset | JWT |
| PUT | `/config/presets/{name}/apply` | Apply a preset | JWT |
| DELETE | `/config/presets/{name}` | Delete a user preset | JWT |
| GET | `/watchlist` | List user's watched instruments | JWT |
| POST | `/watchlist` | Add instrument to watchlist | JWT |
| DELETE | `/watchlist/{instrument_id}` | Remove instrument from watchlist | JWT |
| GET | `/instruments` | List all available instruments | JWT |
| GET | `/instruments/{instrument_id}` | Get instrument detail | JWT |
| GET | `/alerts` | List user's alerts (paginated) | JWT |
| GET | `/alerts/{alert_id}` | Get alert detail | JWT |
| PATCH | `/alerts/{alert_id}/acknowledge` | Acknowledge an alert | JWT |

### 5.2 Example Request/Response: GET /trendlines/{instrument_id}

**Request:**
```
GET /api/v1/trendlines/550e8400-e29b-41d4-a716-446655440000
Authorization: Bearer <jwt_token>
```

**Response 200 (Success):**
```json
{
  "instrument": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "symbol": "CL",
    "name": "Crude Oil"
  },
  "support_lines": [
    {
      "id": "tl-uuid-1",
      "grade": "A+",
      "touch_count": 4,
      "slope_degrees": 22.5,
      "duration_days": 45,
      "spacing_quality": 0.85,
      "composite_score": 7.43,
      "status": "active",
      "projected_price": 72.45,
      "safety_line_price": 73.20,
      "target_price": 69.00,
      "anchor_points": [
        {"timestamp": "2025-12-28T09:00:00Z", "price": 68.50},
        {"timestamp": "2026-01-15T13:00:00Z", "price": 69.80}
      ],
      "touch_points": [
        {"timestamp": "2026-01-08T05:00:00Z", "price": 69.10},
        {"timestamp": "2026-02-01T17:00:00Z", "price": 71.50}
      ]
    }
  ],
  "resistance_lines": [],
  "meta": {
    "last_updated": "2026-02-11T13:00:00Z",
    "max_lines_per_direction": 5,
    "support_count": 1,
    "resistance_count": 0
  }
}
```

**Response 404 (Instrument Not Found):**
```json
{
  "error": "not_found",
  "message": "Instrument not found or not on your watchlist."
}
```

**Response 401 (Unauthorized):**
```json
{
  "error": "unauthorized",
  "message": "Authentication required. Provide a valid JWT token."
}
```

### 5.3 Example Request/Response: PUT /config

**Request:**
```
PUT /api/v1/config
Authorization: Bearer <jwt_token>
Content-Type: application/json

{
  "min_touch_count": 4,
  "max_slope_degrees": 30,
  "touch_tolerance_atr": 0.3
}
```

**Response 200 (Success):**
```json
{
  "config": {
    "min_touch_count": 4,
    "min_candle_spacing": 6,
    "max_slope_degrees": 30,
    "min_duration_days": 21,
    "touch_tolerance_atr": 0.3,
    "pivot_n_bar_lookback": 5,
    "max_lines_per_instrument": 5,
    "quiet_hours_start": null,
    "quiet_hours_end": null,
    "quiet_hours_timezone": null,
    "preset_name": null
  },
  "recalculation_status": "pending",
  "estimated_completion_seconds": 60
}
```

**Response 422 (Validation Error):**
```json
{
  "error": "validation_error",
  "message": "One or more configuration parameters are invalid.",
  "details": [
    {"field": "min_touch_count", "value": 7, "message": "Minimum touch count must be between 2 and 5."}
  ]
}
```

### 5.4 Rate Limiting

| Endpoint Pattern | Rate Limit | Window | Error Response |
|---|---|---|---|
| `PUT /config` | 10 requests | 1 minute | 429: `"Rate limit exceeded. Maximum 10 configuration changes per minute."` |
| `POST /config/reset` | 10 requests | 1 minute | 429 (same as above) |
| `PUT /config/presets/*/apply` | 10 requests | 1 minute | 429 (same as above) |
| All other endpoints | 100 requests | 1 minute | 429: `"Rate limit exceeded. Try again in {seconds} seconds."` |

### 5.5 Authentication and Authorization

- All endpoints require a valid JWT token in the `Authorization: Bearer` header.
- Missing token: 401, `"Authentication required. Provide a valid JWT token."`.
- Expired token: 401, `"Token expired. Please re-authenticate."`.
- Invalid token: 401, `"Invalid authentication token."`.
- All data is scoped to the authenticated user via PostgreSQL RLS. A user can ONLY access their own trendlines, config, watchlist, and alerts.

---

## 6. UI/UX Specifications

### 6.1 Component Inventory

The detection engine provides data to the following UI components (rendered by FSD-008):

| Component | Description | Data Source |
|---|---|---|
| Trendline Chart Overlay | Lines drawn on the candlestick chart | `GET /trendlines/{instrument_id}` |
| Trendline Metadata Panel | Side panel showing grade, touches, score | `GET /trendlines/{trendline_id}/detail` |
| Alert Feed | Chronological list of alerts | `GET /alerts` + WebSocket push |
| Configuration Panel | Form for detection parameters | `GET /config`, `PUT /config` |
| Instrument Watchlist | List of watched instruments with status | `GET /watchlist` |

### 6.2 States the UI Must Handle

**Trendline Chart Overlay:**

| State | Description | Display |
|---|---|---|
| Empty | No trendlines detected for this instrument | Show message: "No qualifying trendlines detected for {symbol}. Adjust parameters or wait for new market data." |
| Loading | Detection pipeline running (after config change or instrument add) | Show spinner with: "Analyzing {symbol}... This may take up to 60 seconds." |
| Success | Trendlines detected and displayed | Draw lines on chart with touch points marked. Color-code by grade: A+ = green, A = blue, B = gray. |
| Error | Detection pipeline failed | Show: "Unable to load trendlines. Retrying..." with automatic retry after 10 seconds. |
| Partial | Some instruments loaded, others pending | Show loaded instruments normally; pending instruments show: "Bootstrapping {symbol}..." |

**Alert Feed:**

| State | Description | Display |
|---|---|---|
| Empty | No alerts generated yet | Show: "No alerts yet. Trendlines are being monitored -- you'll be notified when price interacts with a qualifying line." |
| Loading | Fetching alert history | Show skeleton/placeholder cards. |
| Success | Alerts displayed | Show chronological list with alert type icon, instrument, grade, timestamp. Break alerts highlighted in red. |
| Error | Failed to fetch alerts | Show: "Unable to load alerts. Pull to refresh." |
| New alert (real-time) | WebSocket push received | Animate new alert card sliding in at the top. Play notification sound (if enabled). |

**Configuration Panel:**

| State | Description | Display |
|---|---|---|
| Loading | Fetching current config | Show skeleton form. |
| Success | Config loaded | Show form with current values, sliders for numeric params. |
| Saving | Config update in progress | Disable form, show spinner on Save button. |
| Saved | Config saved, recalculation triggered | Show toast: "Configuration saved. Recalculating trendlines..." |
| Validation error | Invalid parameter values | Show inline error messages beneath each invalid field (red text). |
| Recalculation complete | WebSocket event received | Show toast: "Recalculation complete. {count} trendlines updated." |

---

## 7. Integration Specifications

### 7.1 External Service Integrations

#### 7.1.1 yfinance

- **Purpose**: Free historical daily OHLCV data for bootstrapping.
- **Library**: `yfinance` Python package.
- **Rate Limit**: No official rate limit, but throttle to 1 request per second to avoid IP blocks.
- **Error Handling**: See Section 3.1.1.
- **Fallback**: If yfinance is unavailable, use IBKR or Tradovate for historical data.

#### 7.1.2 Interactive Brokers TWS API

- **Purpose**: Primary real-time and historical 4H OHLCV data.
- **Protocol**: TCP socket (IB API), port 7497 (paper) / 7496 (live).
- **Authentication**: Client ID + paper/live account credentials.
- **Credential Storage**: Encrypted in secrets manager (AES-256). NEVER in logs or config files.
- **Rate Limit**: 60 historical data requests per 10 minutes (IB-imposed).
- **Error Handling**: Retry with exponential backoff (5s, 15s, 45s). After 3 failures, fail over to Tradovate.
- **Connection Management**: Maintain persistent connection during market hours. Reconnect automatically on disconnect with 5-second delay.

#### 7.1.3 Tradovate WebSocket API

- **Purpose**: Alternative real-time 4H OHLCV data.
- **Protocol**: WebSocket (wss://live.tradovateapi.com/v1/websocket).
- **Authentication**: OAuth2 (access token, refresh token). Token refresh: hourly.
- **Error Handling**: Auto-reconnect on disconnect. Queue missed messages for gap-fill.
- **Fallback**: If Tradovate is unavailable, degrade gracefully (delayed data from yfinance daily).

### 7.2 Internal Module Dependencies

| Module | Dependency Type | Interface |
|---|---|---|
| Platform Foundation (FSD-001) | Hard | PostgreSQL database, FastAPI framework, Celery/Redis, JWT auth |
| Notification System (FSD-007) | Hard | `send_alert(user_id, alert_payload, channels)` function call or Redis queue message |
| Trade Execution (FSD-003) | Soft | Consumes alert payloads from Redis queue. Reports trade status back via `trade_entered(trendline_id)` |
| Dashboard (FSD-008) | Soft | Serves data via REST API + WebSocket events |

### 7.3 Event/Message Contracts

**Celery Task: `ingest_4h_candles`**
- Queue: `market_data`
- Schedule: Every 4 hours during market hours (Celery Beat)
- Input: None (processes all active instruments)
- Output: New candle records + dispatches `detect_trendlines_incremental` per instrument

**Celery Task: `detect_trendlines_incremental`**
- Queue: `detection`
- Input: `{"instrument_id": "uuid", "user_id": "uuid", "candle_id": "uuid"}`
- Output: Updated trendline records + dispatches `evaluate_alerts` per trendline

**Celery Task: `evaluate_alerts`**
- Queue: `alerts`
- Input: `{"instrument_id": "uuid", "user_id": "uuid", "candle_id": "uuid"}`
- Output: Alert records + dispatches to notification system

**Celery Task: `recalculate_all_trendlines`**
- Queue: `detection`
- Input: `{"user_id": "uuid"}`
- Output: Updated trendline records + WebSocket event to user

**Celery Task: `bootstrap_instrument`**
- Queue: `market_data`
- Input: `{"user_id": "uuid", "instrument_id": "uuid"}`
- Output: Candle records + initial trendline detection + WebSocket event

### 7.4 Retry and Fallback Strategies

| Operation | Retry Count | Backoff | Fallback |
|---|---|---|---|
| IBKR data fetch | 3 | Exponential (5s, 15s, 45s) | Tradovate |
| Tradovate data fetch | 3 | Exponential (5s, 15s, 45s) | yfinance daily |
| Alert delivery (per channel) | 3 | Exponential (1s, 3s, 9s) | Next channel |
| Database write | 2 | Fixed (1s) | Log critical error, alert ops |
| Celery task execution | 3 | Exponential (10s, 60s, 300s) | Dead-letter queue after 3 failures |

---

## 8. Security Specifications

### 8.1 Authentication Requirements

- All API endpoints require JWT authentication (issued by FSD-001 auth module).
- Celery workers authenticate to PostgreSQL using service account credentials stored in environment variables.
- Broker API connections use per-user credentials stored encrypted (AES-256) in secrets manager.

### 8.2 Authorization Matrix

| Role | Trendlines (own) | Trendlines (others) | Config (own) | Config (others) | Watchlist (own) | Alerts (own) | System Admin |
|---|---|---|---|---|---|---|---|
| Free User | Read, Dismiss | None | Read, Update | None | Read, Add (3 max), Remove | Read, Acknowledge | None |
| Trader User | Read, Dismiss | None | Read, Update | None | Read, Add (10 max), Remove | Read, Acknowledge | None |
| Pro User | Read, Dismiss | None | Read, Update, Presets | None | Read, Add (unlimited), Remove | Read, Acknowledge | None |
| Admin | Full | Read | Full | Read | Full | Full | Full |

### 8.3 Data Isolation

- PostgreSQL Row-Level Security (RLS) policies enforce user data isolation:
  ```sql
  CREATE POLICY user_trendlines ON trendlines
    USING (user_id = current_setting('app.current_user_id')::uuid);
  ```
- All queries automatically scoped to the authenticated user. No API parameter can override this.
- Even if two users watch the same instrument with identical parameters, their trendline records are completely independent.

### 8.4 Data Encryption

| Data | At Rest | In Transit |
|---|---|---|
| OHLCV market data | Database-level encryption (Supabase default) | TLS 1.2+ |
| User configurations | Database-level encryption | TLS 1.2+ |
| Broker API credentials | AES-256 encryption in secrets manager | TLS 1.2+ |
| Alert payloads | Database-level encryption | TLS 1.2+ (to notification channels) |

### 8.5 Input Sanitization

- All API inputs validated via Pydantic models with strict type checking.
- SQL injection prevention: all queries use parameterized statements (SQLAlchemy ORM).
- No user input is interpolated into log messages (prevent log injection).
- Webhook payloads from external sources validated via HMAC-SHA256 signature.

### 8.6 Audit Logging

- All configuration changes logged with `user_id`, `old_value`, `new_value`, and timestamp.
- All trendline state transitions logged in `trendline_events` table.
- All alert deliveries logged with channel, status, and timestamp.
- Failed authentication attempts logged: `"WARN: Failed auth attempt for user {user_id} from IP {ip}"`.

### 8.7 Operational Security

- Detection engine Celery workers have minimal database permissions: `SELECT` on `candles`/`instruments`, `INSERT`/`UPDATE` on `trendlines`/`pivots`/`alerts`/`trendline_events`. No `DELETE`, no DDL.
- Detection engine has NO write access to trade execution tables (separation of concerns).
- Processing logs contain ONLY metadata (instrument, counts, timing). Raw OHLCV data is NEVER logged.
- Alert payloads transmitted to external channels (Telegram, Discord, email) contain NO account balances, position sizes, or broker credentials.

---

## 9. Performance Specifications

### 9.1 Latency Requirements

| Operation | Target | Measurement | Priority |
|---|---|---|---|
| End-to-end: 4H candle close to alert delivery | < 30 seconds (p95) | Timer from candle timestamp to Telegram delivery confirmation | P0 |
| Candle ingestion (broker API to DB write) | < 15 seconds (p95) | Timer from API call to DB commit | P0 |
| Full trendline recalculation (1 instrument, 600 candles) | < 10 seconds | Timer for complete pipeline | P0 |
| Full recalculation (6 instruments, parallel) | < 30 seconds | Timer for batch completion | P0 |
| Incremental update (1 new candle, 1 instrument) | < 5 seconds | Timer from candle receipt to ranking update | P0 |
| Dashboard trendline fetch + render | < 2 seconds (p95) | Timer from API request to chart display | P1 |
| Config change to recalculation complete | < 60 seconds | Timer from API response to WebSocket completion event | P1 |
| DB query: active trendlines per instrument | < 100 ms | SQL query execution time | P1 |

### 9.2 Throughput Requirements

| Phase | Instruments | Users | Concurrent Detection Tasks |
|---|---|---|---|
| Phase 1 | 6-10 | 1 | 6 (1 per instrument) |
| Phase 2 | 50 | 100 | 50 (parallel Celery workers) |
| Phase 3 | 200+ | 1,000+ | Horizontally scaled workers |

### 9.3 Resource Limits

| Resource | Limit | Action on Breach |
|---|---|---|
| Memory per instrument detection | < 512 MB | Log warning, investigate |
| Memory total (6 instruments) | < 2 GB | Log critical, throttle processing |
| Celery worker count | 1-8 (configurable) | Scale horizontally |
| PostgreSQL connection pool | 20 connections per worker | Queue excess connections |

### 9.4 Caching Strategy

| Data | Cache Location | TTL | Invalidation |
|---|---|---|---|
| Current ATR per instrument | Redis | 4 hours (until next candle) | On new candle ingestion |
| User detection config | Redis | 5 minutes | On config update |
| Instrument metadata | Redis | 24 hours | On contract roll |
| Active trendlines per user per instrument | Redis | 4 hours | On new candle or config change |

---

## 10. Testing Specifications

### 10.1 Unit Test Scenarios

| Test ID | Component | Scenario | Input | Expected Output |
|---|---|---|---|---|
| UT-001 | Pivot Detection | N=5 pivot high in middle of series | Candles: highs = [10, 12, 15, 12, 10, 8, 7, 9, 11, 13, 15] | Pivot high detected at index 2 (price=15) and index 10 (price=15) |
| UT-002 | Pivot Detection | Flat highs (equal values) | Candles: highs = [10, 15, 15, 12, 10] with N=2 | Pivot at index 1 (leftmost of equal pair) |
| UT-003 | Pivot Detection | No pivots in flat series | All highs = 10, N=5 | No pivots detected |
| UT-004 | Pivot Detection | Boundary candles excluded | 12 candles with N=5, potential pivot at index 10 | No pivot at index 10 (insufficient right context) |
| UT-005 | Body-Cross | Support line, body below | Support line at price 50, candle close=49 | Candidate rejected |
| UT-006 | Body-Cross | Support line, wick below but body above | Support line at 50, candle low=48, close=51 | Candidate accepted (wick OK) |
| UT-007 | Body-Cross | Close exactly on line | Support at 50.00, close=50.00 | Candidate accepted (not a break) |
| UT-008 | Touch Scoring | Touch within tolerance | Line at 50.0, candle low=49.8, ATR=1.0, tolerance=0.5 | Touch detected (distance 0.2 < 0.5*1.0) |
| UT-009 | Touch Scoring | Touch outside tolerance | Line at 50.0, candle low=49.2, ATR=1.0, tolerance=0.5 | No touch (distance 0.8 > 0.5*1.0) |
| UT-010 | Touch Scoring | Body crosses line (break, not touch) | Line at 50.0, candle close=49.5 | Break, NOT a touch |
| UT-011 | Spacing | Two touches within min spacing | Touches at indices 10, 14 with min_spacing=6 | Collapsed to 1 touch (closest to line) |
| UT-012 | Spacing Quality | Perfect spacing | Gaps = [20, 20, 20] | spacing_quality = 1.0 |
| UT-013 | Spacing Quality | Irregular spacing | Gaps = [5, 50, 10] | spacing_quality = max(0, 1 - 19.74/21.67) = 0.089 |
| UT-014 | Grading | A+ line | 4 touches, 8 spacing, 30 deg slope, 28 days, 10 days entry zone | Grade = A+ |
| UT-015 | Grading | A line (slope too steep for A+) | 3 touches, 5 spacing, 50 deg slope, 18 days, 5 days entry zone | Grade = A |
| UT-016 | Grading | Below B threshold | 1 touch, 2 spacing, 80 deg slope, 5 days | Not stored |
| UT-017 | Composite Score | Known inputs | 4 touches, 0.85 spacing, 6 weeks duration, 20 deg slope | score = 4 * 0.85 * log2(7) * (1 - 20/90) = 4 * 0.85 * 2.807 * 0.778 = 7.43 |
| UT-018 | Break Detection | Support break (close below) | Support line at 50.0, candle close=49.5 | Break alert generated, direction=SHORT |
| UT-019 | Break Detection | Resistance break (close above) | Resistance at 100.0, candle close=101.0 | Break alert generated, direction=LONG |
| UT-020 | Break Detection | Wick past but close valid | Support at 50.0, candle low=48.0, close=51.0 | No break (body above line) |
| UT-021 | ATR | 14-period ATR computation | Known series of 15 candles | ATR matches hand-calculated value |
| UT-022 | Config Validation | Out-of-range touch count | min_touch_count=7 | 422: "Minimum touch count must be between 2 and 5." |
| UT-023 | Config Validation | Valid parameters | All params within range | 200: config updated |
| UT-024 | Deduplication | Duplicate break alert | Break alert already exists for trendline | No new alert created |

### 10.2 Integration Test Scenarios

| Test ID | Scenario | Steps | Expected Outcome |
|---|---|---|---|
| IT-001 | Full pipeline: candle to alert | 1. Insert a new 4H candle that breaks a known A+ support line. 2. Wait for pipeline execution. 3. Verify alert generated. | Break alert in `alerts` table with correct payload. Trendline status = `invalidated`. |
| IT-002 | Lifecycle: detected -> qualifying -> active | 1. Create a trendline meeting B criteria. 2. Add touches to promote to A+. 3. Bring price within 3*ATR. | Trendline transitions through states correctly. Events logged in `trendline_events`. |
| IT-003 | Lifecycle: active -> traded | 1. Have an active A+ trendline. 2. Simulate trade entry linked to the trendline. | Status = `traded`. No further alerts generated. |
| IT-004 | Lifecycle: active -> invalidated | 1. Have an active A+ trendline. 2. Insert candle with body close past line. 3. No trade entered. | Status = `invalidated`. Break + Invalidation alerts generated. |
| IT-005 | Config change recalculation | 1. Set min_touch_count=2 (more lines qualify). 2. Change to min_touch_count=4 (fewer lines qualify). | Lines with 2-3 touches demoted/removed. Lines with 4+ touches retained. |
| IT-006 | Deduplication under concurrency | 1. Dispatch 3 identical break alert evaluations concurrently. | Exactly 1 alert created (DB constraint prevents duplicates). |
| IT-007 | Instrument add bootstrap | 1. Add CL to watchlist. 2. Wait for bootstrap. | Historical candles fetched, pivots detected, trendlines generated within 2 minutes. |
| IT-008 | Contract rollover | 1. Simulate contract roll for CL. 2. Apply price adjustment. 3. Recalculate trendlines. | All prices adjusted. Trendline slopes recalculated. Grades recomputed. |
| IT-009 | Gap detection and fill | 1. Delete a candle from the middle of the series. 2. Run gap detection. | Missing candle detected, fetched from data source, inserted. |
| IT-010 | Watchlist tier enforcement | 1. Free user adds 3 instruments (success). 2. Free user adds 4th instrument. | 4th add returns 403: "Free plan allows up to 3 instruments." |

### 10.3 Performance Test Criteria

| Test | Method | Target | Frequency |
|---|---|---|---|
| Single instrument full detection | Benchmark 600-candle dataset | < 10 seconds | Every deployment |
| 6-instrument parallel detection | Benchmark with 6 Celery workers | < 30 seconds | Every deployment |
| Incremental update (1 candle) | Benchmark single candle addition | < 5 seconds | Every deployment |
| DB query: active trendlines | Benchmark with 1000 total trendlines | < 100 ms | Weekly |
| Memory profiling | Monitor during 6-instrument detection | < 2 GB total | Weekly |

### 10.4 Accuracy Test Criteria

| Test | Method | Target |
|---|---|---|
| Detection recall | Compare engine A+ lines to 50+ manually identified setups | >= 80% |
| False positive rate | Expert review of engine-surfaced A+ lines | <= 20% |
| Touch count accuracy | Compare engine vs. manual touch counts on 30 lines | >= 90% within +/- 1 touch |
| Break detection accuracy | Test 50 known break scenarios | 100% correct |
| Grade agreement | Compare engine vs. expert grades on 30 lines | >= 85% exact match |

---

## 11. Migration & Deployment

### 11.1 Database Migration Steps

1. **Migration 001**: Create `instruments` table with Phase 1 instrument seed data.
2. **Migration 002**: Create `candles` table with unique index on `(instrument_id, timestamp, timeframe)`.
3. **Migration 003**: Create `pivots` table with FK to `instruments` and `candles`.
4. **Migration 004**: Create `trendlines` table with all columns, FKs, and RLS policies.
5. **Migration 005**: Create `trendline_events` table with FK to `trendlines`.
6. **Migration 006**: Create `alerts` table with composite unique index on `(trendline_id, alert_type)` for break/invalidation types, and `(trendline_id, alert_type, trigger_candle_id)` for touch types.
7. **Migration 007**: Create `user_detection_config` table with unique constraint on `user_id`.
8. **Migration 008**: Create `user_watchlist` table with unique constraint on `(user_id, instrument_id)`.
9. **Migration 009**: Enable RLS on `trendlines`, `alerts`, `user_detection_config`, `user_watchlist` tables.

All migrations are idempotent (can be re-run safely). Each migration includes a rollback (`down` migration).

### 11.2 Feature Flags

| Flag | Default | Purpose |
|---|---|---|
| `trendline_detection_enabled` | true | Master kill switch for the detection pipeline |
| `alert_delivery_enabled` | true | Enable/disable alert routing (detection continues, alerts queued) |
| `ransac_enabled` | false | Enable RANSAC optimization (Phase 2) |
| `historical_atr_enabled` | false | Use per-candle ATR for touch scoring (Phase 2) |
| `config_presets_enabled` | false | Enable configuration preset system (Phase 2) |
| `quiet_hours_enabled` | false | Enable alert quiet hours (Phase 2) |

### 11.3 Rollback Procedures

1. **Code rollback**: Deploy previous container image. Celery workers restart automatically.
2. **Database rollback**: Run `down` migrations in reverse order. Each migration is designed for safe rollback.
3. **Data rollback**: Trendline data can be fully recalculated from candle data. If trendline data is corrupted:
   a. Truncate `trendlines`, `pivots`, `trendline_events` tables.
   b. Trigger full recalculation for all instruments.
   c. Estimated recovery time: < 5 minutes for 6 instruments.
4. **Emergency stop**: Set `trendline_detection_enabled = false`. Pipeline stops processing. Existing data preserved.

### 11.4 Deployment Dependencies

| Dependency | Required Before Deploy |
|---|---|
| PostgreSQL database (Supabase) | Must be provisioned and accessible |
| Redis instance | Must be running for Celery broker |
| Celery Beat scheduler | Must be configured with 4H schedule |
| Celery workers (minimum 1) | Must be running to process tasks |
| IBKR TWS or Gateway | Must be running and authenticated for real-time data |
| Telegram Bot token | Must be configured for alert delivery |

---

## 12. Open Questions & Assumptions

### 12.1 Assumptions

| # | Assumption | Impact if Wrong |
|---|---|---|
| A1 | CME 4H candle boundaries are at 00:00, 04:00, 08:00, 12:00, 16:00, 20:00 CT. | Candle timestamps misaligned; detection runs at wrong times. |
| A2 | IBKR TWS API will be available and authenticated during all market hours. | Fallback to Tradovate required; potential data latency. |
| A3 | Phase 1 is single-user. Multi-user data isolation is implemented but not load-tested. | Performance may degrade when Phase 2 multi-user launches. |
| A4 | The 14-period Wilder's smoothed ATR is the correct ATR variant for the Tori Trades methodology. | Touch tolerance calculations may be miscalibrated. |
| A5 | yfinance daily data is sufficient for initial bootstrapping even though the engine primarily uses 4H data. | Daily data provides coarser trendlines; 4H data from IBKR is needed for precision. |
| A6 | The "safety line at 4th candle projection" for stop loss matches the Tori Trades methodology. | Bracket order specs may not match trader expectations. |
| A7 | The formula `score = touch_count * spacing_quality * duration_factor * inverse_slope_factor` produces rankings that align with expert trader preferences. | Ranking may need tuning based on user feedback. |
| A8 | S/R levels for take-profit targets (>= 2R) can be derived from horizontal pivot levels. | If no S/R detection is implemented initially, the system uses exactly 2R as the target. |

### 12.2 Items Requiring Clarification

| # | Question | Impact | Status |
|---|---|---|---|
| Q1 | How are horizontal S/R levels identified for take-profit targeting? Is this a separate algorithm or part of the detection engine? | Affects bracket order spec accuracy. | Open -- Phase 1 may use 2R flat target. |
| Q2 | Should the detection engine share computation across users watching the same instrument with identical configs, or always compute independently? | Performance at scale (Phase 2+). | Deferred to Phase 2. |
| Q3 | What is the exact CME 4H candle boundary schedule accounting for the daily maintenance halt? | Affects Celery Beat scheduling. | Needs confirmation from CME documentation. |
| Q4 | Should the "entry zone" criterion measure calendar time or trading time (excluding weekends/holidays)? | Affects A+ grade assignment near weekends. | Assume calendar time for simplicity. |
| Q5 | What happens to trendlines when IBKR connection drops for > 1 hour during market hours? | Stale data may miss breaks or touches. | Implement monitoring alert; manual review required. |
| Q6 | How should the system handle instruments that trade nearly 24 hours (e.g., ES, NQ) versus those with limited sessions (e.g., PL)? | May affect expected candle counts and gap detection logic. | Use CME Globex hours for all instruments. |

### 12.3 Deferred Decisions

| # | Decision | Deferred To | Rationale |
|---|---|---|---|
| D1 | RANSAC optimization threshold (default 50 pivots). | Phase 2 | Exhaustive search is sufficient for Phase 1 instrument count. |
| D2 | Historical ATR for touch scoring. | Phase 2 | Current ATR is acceptable for Phase 1 accuracy targets. |
| D3 | Configuration presets system. | Phase 2 | Single-user Phase 1 needs only default config + manual overrides. |
| D4 | Quiet hours alert suppression. | Phase 2 | Phase 1 user can manage notifications manually. |
| D5 | Williams Fractals as a selectable mode. | Phase 2 | N-bar with N=2 achieves the same result; UI selection deferred. |
| D6 | Shared computation for same-instrument/same-config users. | Phase 3 | No multi-user in Phase 1. |

---

## 13. Appendices

### 13.1 Glossary

| Term | Definition |
|---|---|
| ATR | Average True Range. 14-period Wilder's smoothed measure of volatility on 4H candles. |
| Back-adjustment | Continuous contract construction method: additive offset applied to historical prices at each roll. |
| Body | The filled portion of a candlestick between the open and close prices. |
| Bracket order | Entry + stop loss + take profit as a single compound order. |
| Candle | A single OHLCV (Open, High, Low, Close, Volume) bar representing a time period. |
| Continuous contract | Synthetic price series stitching multiple futures contract data across roll dates. |
| First Notice Day | First day a futures buyer may be required to take delivery. |
| N-bar confirmation | Pivot detection requiring N candles on each side with lower highs (pivot high) or higher lows (pivot low). |
| Pivot point | A swing high or swing low identified by N-bar confirmation. Trendline anchor/touch point. |
| R-multiple | Profit/loss as a multiple of initial risk (entry-to-stop distance). 2R = twice the risk. |
| RANSAC | Random Sample Consensus. Iterative algorithm for robust line fitting with outliers. |
| RLS | Row-Level Security. PostgreSQL feature for automatic data isolation by user. |
| Safety line | Trendline projected 4 candles forward from break point; used as stop loss. |
| S/R level | Support or Resistance. Horizontal price level where price historically reversed. |
| Touch | Candle wick intersecting a trendline within ATR-scaled tolerance, without body close past line. |
| Wick | The thin lines extending from the candle body to the high and low prices. |
| Williams Fractals | N-bar confirmation with N=2 (high sensitivity pivot detection). |

### 13.2 Related FSDs

- FSD-001: Platform Foundation & Infrastructure
- FSD-003: Trade Execution Pipeline
- FSD-004: Trade Journaling
- FSD-005: Playbook System
- FSD-006: Performance Analytics
- FSD-007: Notification System
- FSD-008: Dashboard & Visualization
- FSD-009: AI/ML Features
- FSD-010: Market Data Service
- FSD-011: Broker Adapters

### 13.3 Algorithm Pseudocode Reference

See PRD-002 Appendix A for the detection pipeline pseudocode (`detect_trendlines`) and alert evaluation pseudocode (`evaluate_alerts`). The FSD expands these into the detailed specifications in Sections 3.1-3.7.

---

## Changelog

- 2026-02-11: Initial FSD v1.0 generated from PRD-002 v1.0 -- Claude
