# FSD-009: Billing & Subscriptions

**TrendEdge — AI-Powered Futures Trading Platform**

| Field | Value |
|---|---|
| FSD ID | FSD-009 |
| Source PRD | PRD-009 |
| Title | Billing & Subscriptions |
| Version | 1.0 |
| Status | Draft |
| Author | Generated by Claude |
| Created | 2026-02-11 |

---

## 1. Introduction

### 1.1 Purpose

This Functional Specification Document (FSD) defines the complete behavioral specification for the TrendEdge Billing and Subscription Management system. It translates every requirement from PRD-009 into implementable detail: exact API contracts, precise error messages, state machine transitions, data schemas, webhook processing logic, and UI behaviors. A developer should be able to implement the entire billing system using only this document and the referenced cross-references.

### 1.2 Scope

**In scope:**
- Stripe product/price configuration and checkout session creation
- Full subscription lifecycle: create, upgrade, downgrade, cancel, pause, reactivate
- Feature gating engine with real-time tier checking middleware
- Stripe webhook receiver with signature verification and idempotent processing
- Invoice and receipt management
- Usage metering for AI features (Claude API costs)
- 14-day Pro trial with automatic conversion
- Coupon and promotion code support
- Admin revenue analytics dashboard
- Refund processing via admin interface
- Dunning management for failed payments
- Subscription state machine with enforced valid transitions

**Out of scope:**
- Custom enterprise pricing
- Marketplace/strategy sales revenue sharing (Phase 4)
- Cryptocurrency payment methods
- Tax calculation beyond Stripe Tax defaults
- Multi-currency pricing (USD only at launch)

### 1.3 Dependencies

| Dependency | Reference | What This FSD Needs |
|---|---|---|
| Infrastructure | [Cross-reference: see FSD-001 for infrastructure details] | PostgreSQL database, Redis cache, Celery task queue, environment variable management, monitoring (Sentry, Axiom) |
| Auth & User Management | [Cross-reference: see FSD-008 for authentication details] | Authenticated user sessions, user ID for subscription records, admin role for revenue dashboard access, user registration event to trigger Free tier provisioning |
| Notification Service | [Cross-reference: see applicable Notifications FSD] | Email delivery (SendGrid) for dunning emails, trial notifications, receipts; Telegram delivery for payment confirmations |

### 1.4 Tier Structure Reference

| Capability | Free | Trader ($49/mo) | Pro ($99/mo) | Team ($199/mo) |
|---|---|---|---|---|
| Trendline Detection | 3 instruments, delayed | 10 instruments, real-time | Unlimited, real-time | Unlimited + custom |
| Trade Execution | Paper only | 1 broker, 1 account | 3 brokers, 5 accounts | Unlimited accounts |
| Journaling | 10 trades/month | Unlimited | Unlimited + AI review | Unlimited + sharing |
| Playbooks | 1 default | 5 custom | Unlimited | Unlimited + templates |
| Analytics | 5 basic metrics | 25+ full dashboard | Advanced + Monte Carlo | Everything + team |
| Notifications | Email only | Telegram + Email | All channels | All + custom hooks |
| Support | Community | Email (48h) | Priority (24h) | Dedicated (4h) |
| Monthly Price | $0 | $49 | $99 | $199 |
| Annual Price | -- | $399/yr (32% off) | $799/yr (33% off) | $1,899/yr (21% off) |

---

## 2. System Context

### 2.1 Architecture Overview

The billing system operates as a service layer within the TrendEdge FastAPI backend. It communicates with Stripe as the sole payment processor and uses Redis for caching tier data to enable sub-50ms feature gate checks. All payment card data is handled exclusively by Stripe; TrendEdge servers never receive, process, or store raw card information.

**Component interactions:**

```
User Browser
  |
  |-- POST /api/billing/checkout --> FastAPI Backend --> Stripe API (create Checkout Session)
  |-- GET  /api/billing/portal   --> FastAPI Backend --> Stripe API (create Portal Session)
  |-- (redirect to Stripe Checkout / Portal hosted pages)
  |
Stripe Servers
  |-- POST /api/webhooks/stripe --> FastAPI Backend --> Celery Worker (async processing)
  |                                                       |
  |                                                       |--> PostgreSQL (subscription, invoice, usage tables)
  |                                                       |--> Redis (invalidate tier cache)
  |                                                       |--> SendGrid (dunning/notification emails)
  |
FastAPI Middleware (on every protected request)
  |-- Redis lookup: user:{user_id}:tier_features (TTL 60s)
  |-- Fallback: PostgreSQL lookup if Redis unavailable
  |-- Attach request.state.tier and request.state.tier_limits
```

### 2.2 Data Flow Summary

| Flow | Source | Processing | Destination |
|---|---|---|---|
| New subscription | Stripe Checkout completion webhook | Validate signature, check idempotency, update subscription record | PostgreSQL `subscriptions` table, Redis tier cache |
| Feature gate check | Incoming API request | Middleware reads tier from Redis (or PostgreSQL fallback) | `request.state.tier` and `request.state.tier_limits` |
| Payment failure | Stripe `invoice.payment_failed` webhook | Queue dunning email, update payment status | PostgreSQL `subscriptions` table, SendGrid email |
| Usage increment | Application feature (e.g., journal entry created) | Atomic PostgreSQL increment, Redis cache invalidation | PostgreSQL `usage_tracking` table |
| Admin revenue query | Admin dashboard page load | Pre-computed metrics from `revenue_metrics_daily` table | Dashboard UI |

### 2.3 External Services

| Service | Purpose | Failure Impact | Fallback |
|---|---|---|---|
| Stripe API | Payment processing, subscription management | Cannot create new subscriptions or process payments | Show "Payment processing is temporarily unavailable. Please try again in a few minutes." Feature gating continues from cached data. |
| Stripe Webhooks | Event-driven subscription lifecycle updates | Local state may become stale | Daily reconciliation job corrects discrepancies. Feature gating continues from last known good state. |
| Redis | Tier data caching for feature gate checks | Feature gate latency increases | Direct PostgreSQL lookup (~100ms vs ~5ms). System continues functioning. |
| SendGrid | Transactional email delivery (dunning, receipts, trial notifications) | Emails delayed | Queue emails locally, process when service recovers. No impact on subscription state or feature access. |

---

## 3. Functional Specifications

### 3.1 BL-FR-001: Stripe Product and Price Configuration

**Source:** PRD-009 Section 3.1, BL-FR-001

**Description:** The system configures Stripe products and prices for all four subscription tiers across both billing intervals (monthly and annual). Products and prices are provisioned via a seed script or Stripe Dashboard, not dynamically at runtime.

**Inputs:** None at runtime. Configuration is static.

**Processing Logic:**

1. Four Stripe products are created, one per tier:
   - `prod_trendedge_free` — Free tier (no associated price; exists for metadata consistency)
   - `prod_trendedge_trader` — Trader tier subscription
   - `prod_trendedge_pro` — Pro tier subscription
   - `prod_trendedge_team` — Team tier subscription

2. Each product includes metadata key `tier_level` with integer value for programmatic comparison:
   - Free: `tier_level = 0`
   - Trader: `tier_level = 1`
   - Pro: `tier_level = 2`
   - Team: `tier_level = 3`

3. Six recurring prices are created:

   | Price | Amount (cents) | Interval | Stripe Price ID Pattern |
   |---|---|---|---|
   | Trader Monthly | 4900 | month | `price_trader_monthly` |
   | Trader Annual | 39900 | year | `price_trader_annual` |
   | Pro Monthly | 9900 | month | `price_pro_monthly` |
   | Pro Annual | 79900 | year | `price_pro_annual` |
   | Team Monthly | 19900 | month | `price_team_monthly` |
   | Team Annual | 189900 | year | `price_team_annual` |

4. All prices use `currency: "usd"` and `recurring` mode.

**Outputs:** Stripe product and price objects. Price IDs stored in environment variables.

**Business Rules:**
- Price IDs MUST be stored in environment configuration variables (see Section 7.3), never hardcoded in source code.
- Products and prices MUST NOT be created dynamically at runtime. Any change requires a deployment or manual Stripe Dashboard update.
- The `tier_level` metadata on each product enables programmatic tier comparison without hardcoded tier-name-to-level mappings.

**Error Handling:**
- If the seed script detects that products/prices already exist in Stripe (matching by ID pattern), it skips creation and logs: `"Stripe product {product_id} already exists. Skipping creation."`
- If the seed script fails to create a product or price, it aborts with a CRITICAL log: `"Failed to create Stripe product/price: {error}. Billing system cannot start without valid Stripe configuration."`

**Edge Cases:**
- Running the seed script twice must be idempotent — no duplicate products or prices created.
- If a price amount needs to change (e.g., price increase), a new price must be created in Stripe. The old price is archived. The environment variable is updated to point to the new price ID. Existing subscribers remain on their current price until their next renewal or plan change.

---

### 3.2 BL-FR-002: Checkout Session Creation

**Source:** PRD-009 Section 3.1, BL-FR-002

**Description:** The system creates Stripe Checkout Sessions to process new subscription purchases. The frontend redirects the user to Stripe-hosted checkout pages; on completion, Stripe redirects back and a webhook confirms subscription creation.

**Inputs:**

| Field | Type | Required | Validation |
|---|---|---|---|
| `price_id` | string | Yes | Must match one of the six configured Stripe price IDs from environment variables |
| `billing_interval` | string | Yes | Must be `"monthly"` or `"annual"` |

**API Endpoint:** `POST /api/billing/checkout`

**Authentication:** Required. User must be authenticated. [Cross-reference: see FSD-008 for authentication details]

**Request Body:**
```json
{
  "price_id": "price_pro_monthly",
  "billing_interval": "monthly"
}
```

**Processing Logic:**

1. Validate that the authenticated user does NOT already have an active paid subscription (status `active`, `trialing`, or `past_due` with a non-free tier). If they do, return 409.
2. Validate that the `price_id` matches one of the six configured Stripe price IDs. If not, return 400.
3. Validate that the `billing_interval` is `"monthly"` or `"annual"`. If not, return 400.
4. Validate that the `price_id` and `billing_interval` are consistent (e.g., `price_trader_monthly` with `"monthly"`). If not, return 400.
5. Determine whether the user already has a Stripe customer ID (`stripe_customer_id` on the subscriptions table):
   - If yes: use the existing customer ID in the Checkout Session.
   - If no: pass the user's email as `customer_email` so Stripe creates a new customer.
6. Determine trial eligibility: if the user's `has_used_trial` is `false` AND the selected tier is Pro, set `subscription_data.trial_period_days` to the value of the `BILLING_TRIAL_DAYS` environment variable (default: 14).
7. Create a Stripe Checkout Session with these parameters:
   - `mode`: `"subscription"`
   - `customer`: existing Stripe customer ID (if available)
   - `customer_email`: user's email (if no existing Stripe customer)
   - `line_items`: `[{ price: price_id, quantity: 1 }]`
   - `success_url`: `"{BASE_URL}/billing/success?session_id={CHECKOUT_SESSION_ID}"`
   - `cancel_url`: `"{BASE_URL}/pricing"`
   - `allow_promotion_codes`: `true`
   - `subscription_data.trial_period_days`: 14 (if eligible, as determined in step 6)
   - `subscription_data.metadata`: `{ "user_id": "{user_id}", "tier": "{tier_name}", "source": "checkout" }`
   - `tax_id_collection.enabled`: `true`
   - `billing_address_collection`: `"auto"`
8. Return the Checkout Session URL to the frontend.

**Outputs:**

Success (200 OK):
```json
{
  "checkout_url": "https://checkout.stripe.com/c/pay/cs_xxx..."
}
```

**Error Handling:**

| Condition | HTTP Status | Response Body |
|---|---|---|
| User already has active paid subscription | 409 Conflict | `{ "error": "active_subscription_exists", "message": "You already have an active subscription. Use the billing portal to change plans." }` |
| Invalid `price_id` | 400 Bad Request | `{ "error": "invalid_price_id", "message": "The selected plan is not available. Please choose a valid plan." }` |
| Invalid `billing_interval` | 400 Bad Request | `{ "error": "invalid_billing_interval", "message": "Billing interval must be 'monthly' or 'annual'." }` |
| Mismatched `price_id` and `billing_interval` | 400 Bad Request | `{ "error": "price_interval_mismatch", "message": "The selected price does not match the specified billing interval." }` |
| Stripe API unavailable or error | 503 Service Unavailable | `{ "error": "payment_service_unavailable", "message": "Payment processing is temporarily unavailable. Please try again in a few minutes." }` |
| User not authenticated | 401 Unauthorized | `{ "error": "authentication_required", "message": "You must be logged in to subscribe." }` |

**Edge Cases:**
- If the user navigates away from Stripe Checkout without completing payment, no subscription is created. The user's tier remains unchanged. The abandoned Checkout Session expires after 24 hours automatically (Stripe default).
- If the user has a `cancelled` subscription status, they are treated as eligible for a new checkout (not blocked by the active-subscription check).
- If the user has a `paused` subscription, they should resume via the reactivation flow (BL-FR-010), not create a new checkout. The 409 check covers this since `paused` is an active subscription state.
- If the Stripe Checkout Session creation succeeds but the user never completes checkout, the webhook for `checkout.session.completed` never fires, and no local state changes occur.

---

### 3.3 BL-FR-003: Stripe Customer Portal

**Source:** PRD-009 Section 3.1, BL-FR-003

**Description:** The system integrates the Stripe Customer Portal for self-service billing management. Users can update payment methods, view invoices, change plans, switch billing intervals, cancel subscriptions, and update billing addresses.

**API Endpoint:** `POST /api/billing/portal`

**Authentication:** Required. User must be authenticated and have a `stripe_customer_id`.

**Inputs:** None (the authenticated user's Stripe customer ID is derived from session).

**Processing Logic:**

1. Retrieve the authenticated user's `stripe_customer_id` from the `subscriptions` table.
2. If `stripe_customer_id` is null (Free tier user who has never initiated billing), return 400.
3. Create a Stripe Billing Portal Session with:
   - `customer`: the user's `stripe_customer_id`
   - `return_url`: `"{BASE_URL}/settings/billing"`
   - `configuration`: `STRIPE_PORTAL_CONFIG_ID` environment variable
4. Return the portal session URL.

**Portal Configuration (via Stripe Dashboard):**
- `subscription_update`: enabled, proration behavior `create_prorations`
- `subscription_cancel`: enabled, mode `at_period_end`
- `payment_method_update`: enabled
- `invoice_history`: enabled

**Outputs:**

Success (200 OK):
```json
{
  "portal_url": "https://billing.stripe.com/p/session/xxx..."
}
```

**Error Handling:**

| Condition | HTTP Status | Response Body |
|---|---|---|
| User has no `stripe_customer_id` | 400 Bad Request | `{ "error": "no_billing_account", "message": "You don't have a billing account yet. Subscribe to a paid plan to access billing management." }` |
| Stripe API error | 503 Service Unavailable | `{ "error": "payment_service_unavailable", "message": "Billing portal is temporarily unavailable. Please try again in a few minutes." }` |
| User not authenticated | 401 Unauthorized | `{ "error": "authentication_required", "message": "You must be logged in to access billing." }` |

**Edge Cases:**
- Portal session URLs are single-use and expire after 24 hours.
- If the user performs actions in the portal (e.g., cancels subscription), those actions are communicated back to TrendEdge exclusively via Stripe webhooks. The portal return URL (`/settings/billing`) will show the updated state once the webhook is processed.
- A user cannot access another user's portal session because the session is scoped to their `stripe_customer_id`.

---

### 3.4 BL-FR-004: Payment Method Management

**Source:** PRD-009 Section 3.1, BL-FR-004

**Description:** Payment methods are managed entirely through the Stripe Customer Portal. TrendEdge stores only display-safe metadata (last 4 digits and card brand) for showing in the billing settings UI.

**Inputs:** No direct user input to TrendEdge for payment method operations. All card data flows through Stripe.

**Processing Logic:**

1. When the `payment_method.attached` webhook fires:
   - Extract the payment method's `card.last4` and `card.brand` from the webhook payload.
   - Look up the user by `stripe_customer_id` from the webhook's `customer` field.
   - Update the user record: `payment_method_last4 = last4`, `payment_method_brand = brand`.

2. When the `payment_method.detached` webhook fires:
   - Look up the user by `stripe_customer_id`.
   - If the detached payment method was the user's default (matching stored last4/brand), clear both fields to null.

**Stored Fields (on `users` table or `subscriptions` table):**

| Field | Type | Description |
|---|---|---|
| `stripe_customer_id` | varchar(255), nullable, unique | Stripe customer identifier |
| `payment_method_last4` | varchar(4), nullable | Last 4 digits of default card |
| `payment_method_brand` | varchar(20), nullable | Card brand (visa, mastercard, amex, etc.) |

**Outputs:** Updated local cache of payment method display info.

**Business Rules:**
- No raw card data (full card number, CVV, full expiration) ever touches TrendEdge servers. This is a PCI compliance requirement.
- The billing settings page displays: card brand icon, last 4 digits, and a "Manage" button that redirects to the Stripe Customer Portal.

**Error Handling:**
- If the `payment_method.attached` webhook contains a `customer` that does not match any local user, log a WARNING: `"Received payment_method.attached for unknown customer {customer_id}. Skipping."` and return 200 OK.
- If the payment method type is not a card (e.g., bank account), log the event but do not update display fields (only card brand/last4 are supported for display).

**Edge Cases:**
- If a user has multiple payment methods, only the most recently attached one is stored for display. The Stripe Customer Portal handles selecting the default payment method.
- If a user removes their only payment method, `payment_method_last4` and `payment_method_brand` are set to null. The billing settings UI shows "No payment method on file. Add one to continue your subscription." with a link to the Customer Portal.

---

### 3.5 BL-FR-005: Free Tier (No Payment Required)

**Source:** PRD-009 Section 3.2, BL-FR-005

**Description:** New users receive full Free tier access immediately upon registration without providing any payment information.

**Inputs:** User registration event. [Cross-reference: see FSD-008 for user registration flow]

**Processing Logic:**

1. When a new user completes registration, the system creates a subscription record:
   - `user_id`: the new user's ID
   - `tier`: `"free"`
   - `status`: `"active"`
   - `billing_interval`: `"none"`
   - `stripe_subscription_id`: null
   - `stripe_customer_id`: null
   - `has_used_trial`: false
   - `payment_status`: `"current"`
   - `dunning_step`: 0

2. No Stripe customer object is created at this point. Stripe customer creation is deferred until the user initiates a paid action (checkout or trial).

3. Free tier feature limits are enforced by the feature gating engine (BL-FR-012).

**Outputs:** A subscription record with `tier: "free"` and `status: "active"`.

**Business Rules:**
- Free tier has no expiration. Users can remain on Free indefinitely.
- Free tier users see non-blocking upgrade prompts when they approach or hit tier limits (see BL-FR-014 for specific messages).
- Free tier users who hit limits are never blocked from accessing existing data — only from creating new resources beyond limits.

**Error Handling:**
- If the subscription record creation fails during registration (database error), the user registration itself must be rolled back. A user must not exist without a corresponding subscription record. Log CRITICAL: `"Failed to create subscription record for user {user_id}. Registration rolled back."`

**Edge Cases:**
- If a previously paid user's subscription is cancelled and their data retention period passes, they become a Free tier user. This uses the existing subscription record (updated by webhook), not a new record creation.
- If a user registers with an email that previously had a Stripe customer object (e.g., from a deleted account), the system does not automatically link to the old Stripe customer. A new Stripe customer is created on their first paid action.

---

### 3.6 BL-FR-006: Upgrade Flow

**Source:** PRD-009 Section 3.2, BL-FR-006

**Description:** The system supports upgrades from any lower tier to any higher tier. Upgrades from Free to Paid go through Stripe Checkout. Upgrades from Paid to Higher Paid process via the Stripe API with immediate proration.

**Inputs:**

For Free-to-Paid upgrade:
- Same as BL-FR-002 (Checkout Session Creation)

For Paid-to-Higher-Paid upgrade:
- Processed via Stripe Customer Portal (BL-FR-003) or via API endpoint.

**Valid Upgrade Paths:**
- Free -> Trader, Free -> Pro, Free -> Team
- Trader -> Pro, Trader -> Team
- Pro -> Team

**Processing Logic:**

**Path A: Free to Paid**
1. User clicks "Upgrade" on the pricing page or from a feature gate prompt.
2. System redirects to Stripe Checkout (BL-FR-002).
3. On successful payment, the `checkout.session.completed` webhook fires.
4. Webhook handler updates the subscription record: tier, status, Stripe IDs.
5. Redis tier cache is invalidated immediately.
6. Welcome email sent.

**Path B: Paid to Higher Paid**
1. User clicks "Upgrade" — system displays plan comparison showing current plan vs. target plan with highlighted new features.
2. System calls Stripe API to preview proration: `stripe.Invoice.upcoming()` with the new price.
3. System displays prorated cost to user: "You'll be charged ${prorated_amount} today for the remainder of this billing period."
4. User confirms upgrade.
5. System updates the Stripe subscription via `stripe.Subscription.modify()` with:
   - `items`: new price ID replacing the current price
   - `proration_behavior`: `"create_prorations"`
   - `payment_behavior`: `"pending_if_incomplete"`
6. Stripe charges the prorated amount immediately.
7. The `customer.subscription.updated` webhook fires with the new tier.
8. Webhook handler updates the local subscription record immediately.
9. Redis tier cache is invalidated.
10. User gains immediate access to new tier features.

**Billing interval preservation:** If a user is on Trader Monthly and upgrades to Pro, they remain on monthly billing unless they explicitly choose to switch. The upgrade only changes the tier, not the interval.

**Outputs:**

Proration preview (for Paid-to-Paid):
```json
{
  "current_plan": "Trader Monthly",
  "target_plan": "Pro Monthly",
  "prorated_charge": 2500,
  "prorated_charge_display": "$25.00",
  "explanation": "You'll be charged $25.00 today for the remainder of this billing period. Your next full charge of $99.00 will be on 2026-04-01.",
  "new_features": [
    "Unlimited instruments with real-time detection",
    "Up to 3 broker connections and 5 accounts",
    "AI-powered trade reviews",
    "Advanced analytics with Monte Carlo simulations",
    "Priority support (24h response)"
  ]
}
```

**Business Rules:**
- Upgrades are never deferred — tier access is granted immediately upon successful payment.
- If the proration charge fails (e.g., card declined), the upgrade is NOT applied. The user remains on their current tier. The system displays: "Your upgrade could not be processed. Please update your payment method and try again."
- The upgrade confirmation UI shows a brief confetti animation (2 seconds) followed by: "Welcome to {tier_name}! You now have access to all {tier_name} features."

**Error Handling:**

| Condition | Response |
|---|---|
| Target tier is same or lower than current tier | `400 Bad Request`: `"You can only upgrade to a higher tier. To change to a lower plan, use the downgrade option."` |
| Proration charge fails (card declined) | `402 Payment Required`: `"Your upgrade could not be processed. Please update your payment method and try again."` |
| Stripe API error during subscription update | `503 Service Unavailable`: `"We couldn't process your upgrade right now. Please try again in a few minutes."` |

**Edge Cases:**
- If a user upgrades and then immediately upgrades again within the same billing period (e.g., Trader -> Pro -> Team), both prorations are calculated correctly by Stripe based on the remaining time and price difference at each transition.
- If a user has a pending downgrade and then upgrades instead, the pending downgrade is cancelled automatically by the Stripe subscription update.
- If a user upgrades during a trial, the trial ends immediately and they are charged the prorated amount for the new tier.

---

### 3.7 BL-FR-007: Downgrade Flow with Grace Period

**Source:** PRD-009 Section 3.2, BL-FR-007

**Description:** The system supports downgrades from any paid tier to any lower tier. Downgrades take effect at the end of the current billing period. Users retain full access until then.

**Inputs:**

| Field | Type | Required | Validation |
|---|---|---|---|
| `target_tier` | string | Yes | Must be a tier lower than the current tier |

**Valid Downgrade Paths:**
- Team -> Pro, Team -> Trader, Team -> Free
- Pro -> Trader, Pro -> Free
- Trader -> Free

**Processing Logic:**

1. User clicks "Change Plan" in billing settings.
2. System validates that the target tier is lower than the current tier (using `tier_level` comparison: team=3 > pro=2 > trader=1 > free=0).
3. System displays an impact analysis showing exactly what features and limits will change.
4. User confirms the downgrade.
5. For Paid-to-Lower-Paid downgrades:
   - System updates the Stripe subscription to schedule the plan change at period end via `stripe.Subscription.modify()` with `proration_behavior: "none"` and scheduling the price change for the next billing cycle.
   - Or, system uses `schedule` parameter to set the new price at the end of the current period.
6. For Paid-to-Free downgrades:
   - System sets `cancel_at_period_end: true` on the Stripe subscription (cancelling reverts to Free).
7. System updates the local subscription record:
   - `pending_downgrade_tier`: target tier name
   - The `tier` field does NOT change yet (user retains current tier access).
8. System displays banner: "Your plan will change to {target_tier} on {period_end_date}. You have full access until then."
9. At period end, the `customer.subscription.updated` or `customer.subscription.deleted` webhook fires, and the webhook handler updates the local tier.

**Impact Analysis Display:**

```json
{
  "current_tier": "Pro",
  "target_tier": "Trader",
  "effective_date": "2026-04-01",
  "features_losing": [
    "AI-powered trade reviews",
    "Advanced analytics and Monte Carlo simulations",
    "Priority support (24h → 48h response)",
    "Broker connections reduced from 3 to 1",
    "Accounts reduced from 5 to 1"
  ],
  "features_keeping": [
    "Real-time trendline detection (10 instruments)",
    "Unlimited journal entries",
    "Up to 5 custom playbooks",
    "Full analytics dashboard",
    "Email and Telegram notifications"
  ],
  "data_impact": "Your historical data (trades, journal entries, analytics) will be preserved. Features exceeding the new tier limits will become read-only."
}
```

**Data Handling on Downgrade (at effective date):**

| Data Type | Behavior |
|---|---|
| Historical trade data | Never deleted. Fully accessible read-only. |
| Journal entries | Never deleted. Existing entries remain readable. New entries subject to new tier limits. |
| Analytics history | Never deleted. Historical analytics remain viewable. New analytics limited to new tier capabilities. |
| Excess playbooks (e.g., user has 8, new limit is 5) | All 8 remain visible and functional. User cannot create new playbooks until count is at or below 5. |
| Excess broker connections (e.g., user has 3, new limit is 1) | All 3 connections preserved. User cannot add new connections. Orders from connections beyond the limit (connections 2 and 3) are rejected with: "This broker connection exceeds your Trader plan limit. Upgrade to Pro to use additional broker connections." |
| Excess instruments (e.g., user has unlimited, new limit is 10) | The 10 most recently active instruments continue monitoring. All others are paused with the message: "Instrument monitoring paused — you are at your plan limit of 10 instruments." |
| AI-generated trade reviews | Previously generated reviews remain accessible in the journal. New AI review requests are gated with: "AI Trade Review is available on Pro and above." |

**Business Rules:**
- No refund is issued for the remaining billing period on downgrade. The user has paid and retains access until the period ends.
- A pending downgrade can be cancelled at any time before the effective date. Cancelling a pending downgrade removes the `pending_downgrade_tier` value and the scheduled Stripe subscription change.
- If the user's billing period ends and they have a pending downgrade, the downgrade is applied automatically via webhook.

**Error Handling:**

| Condition | Response |
|---|---|
| Target tier is same or higher than current | `400 Bad Request`: `"You can only downgrade to a lower tier. To upgrade, use the upgrade option."` |
| User is already on Free tier | `400 Bad Request`: `"You are already on the Free plan."` |
| User already has a pending downgrade | `409 Conflict`: `"You already have a pending plan change to {pending_tier} on {date}. Cancel it first to choose a different plan."` |
| Stripe API error | `503 Service Unavailable`: `"We couldn't process your plan change right now. Please try again in a few minutes."` |

**Edge Cases:**
- If a user downgrades and then upgrades before the downgrade takes effect, the upgrade cancels the pending downgrade. The user is on the new (higher) tier immediately.
- If a user requests a downgrade on the last day of their billing period, the downgrade takes effect at the next renewal (which is imminent). The system processes this normally.
- Downgrade from Team to Free skips intermediate tiers — the user goes directly to Free at period end, not through Pro or Trader.

---

### 3.8 BL-FR-008: Cancellation Flow with Retention Offers

**Source:** PRD-009 Section 3.2, BL-FR-008

**Description:** The system implements a multi-step cancellation flow designed to reduce churn through targeted retention offers while respecting the user's intent to cancel.

**Inputs:**

Step 1 — Reason selection:
| Field | Type | Required | Valid Values |
|---|---|---|---|
| `cancellation_reason` | string | Yes | `"too_expensive"`, `"not_using"`, `"missing_features"`, `"competitor"`, `"technical_issues"`, `"temporary_pause"`, `"other"` |
| `cancellation_reason_text` | string | No (required if reason is `"other"`) | Free text, max 500 characters |

Step 3 — Confirmation:
| Field | Type | Required |
|---|---|---|
| `confirm_cancellation` | boolean | Yes, must be `true` |

**Processing Logic:**

**Step 1 — Reason Survey:**
1. User clicks "Cancel Subscription" in billing settings.
2. System displays a modal with the cancellation reason options (listed above).
3. User selects a reason. If "Other" is selected, a text input appears for details.
4. System records the reason and proceeds to Step 2.

**Step 2 — Retention Offer (conditional on reason):**

| Reason | Retention Offer Displayed | Action if Accepted |
|---|---|---|
| `too_expensive` | "Would a 25% discount for 3 months help? That's {tier_name} for ${discounted_price}/mo." | Apply coupon `retention_25pct_3mo` via Stripe API. Cancel the cancellation flow. Display: "Great! Your discount has been applied. You'll pay ${discounted_price}/mo for the next 3 months." |
| `not_using` | "Would switching to a lower plan work better? [comparison table of lower tiers]" | Redirect to downgrade flow (BL-FR-007). Cancel the cancellation flow. |
| `missing_features` | "Tell us what you need — we prioritize features based on user feedback." with a link to a feature request form. | Open feature request form in new tab. User can still proceed to cancel. |
| `competitor` | "We're sorry to see you go. Your data will be preserved for 90 days if you'd like to return." | No special action. Proceed to Step 3. |
| `technical_issues` | "We're sorry you've had issues. Would you like to speak with our support team before cancelling?" with a link to support. | Open support contact. User can still proceed to cancel. |
| `temporary_pause` | "Would you prefer to pause your subscription for up to 3 months instead? You can resume anytime." | Redirect to pause flow (BL-FR-009). Cancel the cancellation flow. |
| `other` | "We're sorry to see you go. Your data will be preserved for 90 days if you'd like to return." | No special action. Proceed to Step 3. |

Discounted price calculations for the `too_expensive` retention offer:
- Trader: $49 * 0.75 = $36.75/mo
- Pro: $99 * 0.75 = $74.25/mo
- Team: $199 * 0.75 = $149.25/mo

**Step 3 — Confirmation (if user declines retention offer or clicks "Continue Cancellation"):**
1. System displays: "Are you sure you want to cancel? Your {tier_name} access will continue until {period_end_date}. After that, your account will revert to the Free plan. Your data will be preserved for 90 days."
2. User clicks "Cancel My Subscription" to confirm.
3. System sets `cancel_at_period_end: true` on the Stripe subscription.
4. System updates local subscription record:
   - `status`: `"cancelling"`
   - `cancel_at_period_end`: `true`
   - `cancelled_at`: current timestamp
   - `cancellation_reason`: selected reason
5. System sends cancellation confirmation email containing: cancellation effective date, data retention period (90 days), reactivation instructions.
6. System displays banner on dashboard: "Your {tier_name} plan will end on {date}. You have full access until then. Changed your mind? [Reactivate]"

**Post-Cancellation (at period end):**
1. Stripe fires `customer.subscription.deleted` webhook.
2. Webhook handler updates local subscription record:
   - `status`: `"cancelled"`
   - `tier`: `"free"`
   - `cancel_at_period_end`: `false`
   - `stripe_subscription_id`: retained for reference
3. User reverts to Free tier limits immediately.
4. Data retention countdown begins (90 days from cancellation effective date).
5. At 90 days post-cancellation: send "final reminder" email: "Your TrendEdge data will be permanently deleted in 30 days. Reactivate your subscription to keep your data."
6. At 120 days post-cancellation: permanent data deletion per privacy policy.

**Cancellation can be reversed at any time before the period ends** — see BL-FR-010 Reactivation Flow.

**Outputs:**

Cancellation confirmation (200 OK):
```json
{
  "status": "cancelling",
  "effective_date": "2026-04-01T00:00:00Z",
  "message": "Your Pro plan will end on April 1, 2026. You have full access until then.",
  "data_retention_days": 90,
  "reactivation_available": true
}
```

**Metrics Tracking:**
- Log every cancellation attempt: `user_id`, `reason`, `retention_offer_shown` (boolean), `retention_offer_type`, `retention_offer_accepted` (boolean), `cancellation_completed` (boolean), `timestamp`.
- Store in a `cancellation_events` table for analytics:
  | Column | Type |
  |---|---|
  | id | bigint |
  | user_id | uuid |
  | reason | varchar(50) |
  | reason_text | text (nullable) |
  | retention_offer_shown | boolean |
  | retention_offer_type | varchar(50) (nullable) |
  | retention_offer_accepted | boolean |
  | cancellation_completed | boolean |
  | created_at | timestamptz |

**Error Handling:**

| Condition | Response |
|---|---|
| User is on Free tier | `400 Bad Request`: `"You don't have an active paid subscription to cancel."` |
| User already has a pending cancellation | `409 Conflict`: `"Your subscription is already scheduled for cancellation on {date}."` |
| Stripe API error | `503 Service Unavailable`: `"We couldn't process your cancellation right now. Please try again in a few minutes."` |
| Retention coupon application fails | Log error, proceed with cancellation. Do not block cancellation due to coupon failure. Display: "We couldn't apply the discount, but you can contact support for assistance. Would you still like to cancel?" |

**Edge Cases:**
- If a user cancels during a trial period, the trial continues until the trial end date. No charge is made. After the trial end date, the user reverts to Free.
- If a user cancels and then the retention coupon `retention_25pct_3mo` has already been used by this user (repeat cancellation attempt), the "too expensive" retention offer is still shown, but with a note: "This discount can only be applied once per account." The user can only proceed to cancel or choose a different option.
- If a user cancels with an annual subscription, they retain access for the remainder of the annual period (which could be months away).

---

### 3.9 BL-FR-009: Subscription Pause

**Source:** PRD-009 Section 3.2, BL-FR-009

**Description:** The system supports pausing subscriptions for up to 3 months (90 days). During the pause, no invoices are generated and the user reverts to Free tier limits.

**Inputs:**

| Field | Type | Required | Validation |
|---|---|---|---|
| `pause_duration_days` | integer | Yes | Minimum 1, maximum 90 |

**API Endpoint:** `POST /api/billing/pause`

**Processing Logic:**

1. Validate that the user has an active paid subscription (status `active`). If not, return 400.
2. Validate that `pause_duration_days` is between 1 and 90. If not, return 400.
3. Calculate `pause_resumes_at` = current timestamp + `pause_duration_days`.
4. Call Stripe API: `stripe.Subscription.modify()` with `pause_collection` set to `{ "behavior": "void" }` (no invoices generated during pause).
5. Update local subscription record:
   - `status`: `"paused"`
   - `pause_starts_at`: current timestamp
   - `pause_resumes_at`: calculated resume date
6. Invalidate Redis tier cache for this user.
7. User access immediately reverts to Free tier limits.
8. Send pause confirmation email: "Your {tier_name} subscription has been paused until {resume_date}. You'll have Free plan access during this time. You can resume anytime."

**Resume behavior:**
- User can resume at any time by calling `POST /api/billing/resume`.
- On resume: system calls `stripe.Subscription.modify()` to remove `pause_collection`, updates `status` to `"active"`, restores tier, invalidates Redis cache.
- The billing cycle restarts from the resume date (the user is charged for a new period starting from resume).
- If the pause expires without manual resume, the subscription automatically resumes and billing restarts.

**Outputs:**

Pause confirmation (200 OK):
```json
{
  "status": "paused",
  "pause_starts_at": "2026-03-15T00:00:00Z",
  "pause_resumes_at": "2026-06-13T00:00:00Z",
  "message": "Your Pro subscription has been paused until June 13, 2026. You have Free plan access during this time. Resume anytime from your billing settings."
}
```

**Business Rules:**
- Pause counts toward the subscription period for annual plans. Pausing does not extend the annual term. For example, if a user on an annual plan pauses for 3 months, they lose 3 months of their annual term.
- Maximum one active pause at a time. A paused subscription cannot be paused again.
- A paused subscription cannot be upgraded or downgraded. The user must resume first.

**Error Handling:**

| Condition | Response |
|---|---|
| User is on Free tier | `400 Bad Request`: `"You don't have an active paid subscription to pause."` |
| User is already paused | `409 Conflict`: `"Your subscription is already paused. It will resume on {resume_date}."` |
| User is in cancelling state | `400 Bad Request`: `"You cannot pause a subscription that is scheduled for cancellation. Cancel the cancellation first, then pause."` |
| `pause_duration_days` < 1 or > 90 | `400 Bad Request`: `"Pause duration must be between 1 and 90 days."` |
| Stripe API error | `503 Service Unavailable`: `"We couldn't pause your subscription right now. Please try again in a few minutes."` |

---

### 3.10 BL-FR-010: Reactivation Flow

**Source:** PRD-009 Section 3.2, BL-FR-010

**Description:** The system allows cancelled users to reactivate their subscription, with different behaviors depending on how long ago they cancelled.

**API Endpoint:** `POST /api/billing/reactivate`

**Inputs:** None (system determines the reactivation path based on subscription state).

**Processing Logic:**

| Scenario | Detection | Behavior |
|---|---|---|
| **Cancel pending** (before period end) | `status == "cancelling"` AND `cancel_at_period_end == true` | Reverse cancellation via `stripe.Subscription.modify()` with `cancel_at_period_end: false`. Subscription continues uninterrupted. No new charge. Update local: `status = "active"`, `cancel_at_period_end = false`, `cancelled_at = null`, `cancellation_reason = null`. Display: "Your subscription has been reactivated! You'll continue with {tier_name} as usual." |
| **Recently cancelled** (< 90 days) | `status == "cancelled"` AND `cancelled_at` is within 90 days | Redirect to Checkout with previous tier pre-selected. On successful checkout, restore previous tier immediately. Historical data intact. Display: "Welcome back! Your {tier_name} subscription is active and all your data has been restored." |
| **Long-cancelled** (> 90 days) | `status == "cancelled"` AND `cancelled_at` is more than 90 days ago | Standard new subscription flow via Checkout. Data may have been deleted per retention policy. Display: "Welcome back to TrendEdge! Note: some of your previous data may no longer be available due to our data retention policy." |

**Outputs:**

For cancel-pending reactivation (200 OK):
```json
{
  "status": "active",
  "tier": "pro",
  "message": "Your subscription has been reactivated! You'll continue with Pro as usual.",
  "next_billing_date": "2026-04-01T00:00:00Z"
}
```

For recently-cancelled or long-cancelled (200 OK):
```json
{
  "checkout_url": "https://checkout.stripe.com/c/pay/cs_xxx...",
  "pre_selected_tier": "pro",
  "message": "Complete checkout to reactivate your Pro subscription."
}
```

**Post-reactivation:** Send reactivation confirmation email with plan details, next billing date, and restored access summary.

**Error Handling:**

| Condition | Response |
|---|---|
| User has an active subscription (not cancelled or cancelling) | `400 Bad Request`: `"Your subscription is already active."` |
| User is on Free tier and has never had a paid subscription | `400 Bad Request`: `"You don't have a previous subscription to reactivate. Visit our pricing page to subscribe."` |
| Stripe API error during reactivation | `503 Service Unavailable`: `"We couldn't reactivate your subscription right now. Please try again in a few minutes."` |

---

### 3.11 BL-FR-011: Annual vs. Monthly Billing Toggle

**Source:** PRD-009 Section 3.2, BL-FR-011

**Description:** The system supports switching between monthly and annual billing intervals for active subscriptions.

**Processing Logic:**

**Monthly to Annual:**
1. User selects "Switch to Annual" in billing settings.
2. System calls `stripe.Invoice.upcoming()` to preview the proration.
3. System displays net charge: "You'll be charged ${annual_price - credit} today (annual price of ${annual_price} minus ${credit} credit for {remaining_days} remaining days on your monthly plan). Save {savings_percent}% with annual billing!"
4. User confirms.
5. System updates Stripe subscription with new annual price ID and `proration_behavior: "create_prorations"`.
6. Switch takes effect immediately. User is charged the net amount.
7. New annual billing cycle starts from today.

**Annual to Monthly:**
1. User selects "Switch to Monthly" in billing settings.
2. System displays: "Your billing will switch to monthly (${monthly_price}/mo) at the end of your current annual period on {annual_period_end_date}. You retain full access until then. No partial refund is issued for the remaining annual term."
3. User confirms.
4. System schedules the price change on the Stripe subscription for the end of the current period with `proration_behavior: "none"`.
5. At period end, Stripe switches to monthly billing and the `customer.subscription.updated` webhook fires.
6. Local subscription record updated: `billing_interval = "monthly"`.

**Outputs:**

Monthly-to-Annual preview:
```json
{
  "switch_type": "monthly_to_annual",
  "current_plan": "Pro Monthly ($99/mo)",
  "new_plan": "Pro Annual ($799/yr)",
  "credit_amount": 4950,
  "credit_display": "$49.50",
  "charge_amount": 74950,
  "charge_display": "$749.50",
  "savings_percent": 33,
  "effective": "immediate"
}
```

Annual-to-Monthly preview:
```json
{
  "switch_type": "annual_to_monthly",
  "current_plan": "Pro Annual ($799/yr)",
  "new_plan": "Pro Monthly ($99/mo)",
  "effective_date": "2027-02-11T00:00:00Z",
  "message": "Your billing will switch to monthly on February 11, 2027. No changes until then."
}
```

**Error Handling:**
- If user is already on the target billing interval: `400 Bad Request`: `"You are already on {interval} billing."`
- If proration charge fails: `402 Payment Required`: `"Your billing switch could not be processed. Please update your payment method and try again."`

---

### 3.12 BL-FR-012: Real-Time Tier Checking Middleware

**Source:** PRD-009 Section 3.3, BL-FR-012

**Description:** FastAPI middleware on all protected endpoints checks the user's subscription tier and enforces feature access in real time.

**Processing Logic:**

1. On every request to a protected endpoint, the middleware executes:
   a. Extract `user_id` from the authenticated session.
   b. Attempt to read tier data from Redis cache key `user:{user_id}:tier_features` (TTL: 60 seconds).
   c. If cache hit: parse the cached tier data.
   d. If cache miss: query PostgreSQL `subscriptions` table for `tier` and `status`, then query the feature flag registry for the tier's limits. Cache the result in Redis with 60-second TTL.
   e. If Redis is unavailable: fall back to PostgreSQL directly (acceptable latency increase to ~100ms).
   f. Attach `request.state.tier` (string: `"free"`, `"trader"`, `"pro"`, `"team"`) and `request.state.tier_limits` (dict of feature limits) to the request context.

2. Endpoints use decorators for tier enforcement:
   - `@requires_tier(minimum="trader")`: blocks the endpoint if user's tier is below the specified minimum. Returns 403.
   - `@check_limit("instruments_count")`: checks if the user has reached their tier limit for the specified metric. Returns 429 if at or over limit.

**Tier Hierarchy (for comparison):**
```
free (0) < trader (1) < pro (2) < team (3)
```

**Access Denial Response (403 Forbidden):**
```json
{
  "error": "tier_limit_exceeded",
  "message": "This feature requires the Pro plan or higher.",
  "current_tier": "trader",
  "required_tier": "pro",
  "upgrade_url": "/pricing?highlight=pro",
  "limit_detail": null
}
```

**Usage Limit Response (429 Too Many Requests):**
```json
{
  "error": "usage_limit_exceeded",
  "message": "You're monitoring 10 of 10 instruments. Upgrade to Pro for unlimited.",
  "current_tier": "trader",
  "current_usage": 10,
  "tier_limit": 10,
  "upgrade_url": "/pricing?highlight=pro",
  "limit_detail": "instruments_count"
}
```

**Cache Invalidation:**
- On any tier change (via webhook handler), the Redis key `user:{user_id}:tier_features` is deleted immediately using `redis.delete()`.
- The next request from that user triggers a cache miss, reads fresh data from PostgreSQL, and re-caches.
- Cache is also warmed on user login (proactive cache population).

**Business Rules:**
- No external API calls (e.g., to Stripe) are made during feature gate checks. All data comes from local cache or database.
- Feature gate checks must complete in under 50ms (p99).
- If both Redis and PostgreSQL are unavailable, the middleware logs a CRITICAL error and returns `503 Service Unavailable`: `"Service temporarily unavailable. Please try again shortly."` The system does NOT default to granting or denying access.

---

### 3.13 BL-FR-013: Feature Flag Registry

**Source:** PRD-009 Section 3.3, BL-FR-013

**Description:** The system maintains a feature flag registry that maps every gated feature to its tier requirements and limits.

**Feature Flag Registry:**

| Feature Key | Free | Trader | Pro | Team | Limit Type |
|---|---|---|---|---|---|
| `trendline.detection` | yes | yes | yes | yes | instrument_count |
| `trendline.realtime` | no | yes | yes | yes | boolean |
| `trendline.custom_params` | no | no | no | yes | boolean |
| `execution.live` | no | yes | yes | yes | boolean |
| `execution.paper` | yes | yes | yes | yes | boolean |
| `execution.broker_count` | 0 | 1 | 3 | unlimited | numeric |
| `execution.account_count` | 0 | 1 | 5 | unlimited | numeric |
| `journal.monthly_limit` | 10 | unlimited | unlimited | unlimited | numeric |
| `journal.ai_review` | no | no | yes | yes | boolean |
| `journal.sharing` | no | no | no | yes | boolean |
| `playbook.custom_count` | 0 | 5 | unlimited | unlimited | numeric |
| `playbook.templates` | no | no | no | yes | boolean |
| `analytics.basic` | yes | yes | yes | yes | boolean |
| `analytics.full_dashboard` | no | yes | yes | yes | boolean |
| `analytics.advanced` | no | no | yes | yes | boolean |
| `analytics.monte_carlo` | no | no | yes | yes | boolean |
| `analytics.team` | no | no | no | yes | boolean |
| `notifications.email` | yes | yes | yes | yes | boolean |
| `notifications.telegram` | no | yes | yes | yes | boolean |
| `notifications.all_channels` | no | no | yes | yes | boolean |
| `notifications.custom_hooks` | no | no | no | yes | boolean |
| `ai.conversational` | no | no | yes | yes | boolean |
| `ai.trade_review` | no | no | yes | yes | boolean |
| `support.priority` | no | no | yes | yes | boolean |
| `support.dedicated` | no | no | no | yes | boolean |

**Storage:** YAML configuration file loaded into Redis on application startup. The configuration is NOT runtime-editable; changes require a deployment.

**Lookup Functions:**
- `has_feature(user_id: str, feature_key: str) -> bool`: Returns `true` if the user's tier grants access to the boolean feature. For numeric features, returns `true` if the limit is greater than 0 or unlimited.
- `get_limit(user_id: str, feature_key: str) -> int | None`: Returns the numeric limit for the user's tier, or `None` for unlimited. Returns 0 for features the tier does not have access to.

**Business Rules:**
- "unlimited" is represented internally as `None` (null) and means no enforcement of that limit.
- The registry is the single source of truth for feature access. No endpoint should hardcode tier checks.
- Configuration changes require a deployment to prevent accidental tier changes in production.

---

### 3.14 BL-FR-014: Graceful Degradation on Limit Exceeded

**Source:** PRD-009 Section 3.3, BL-FR-014

**Description:** When users hit tier limits, the system degrades gracefully with soft blocks and clear messaging rather than hard errors.

**Degradation Behaviors:**

| Feature | At-Limit Behavior | Exact User Message |
|---|---|---|
| Instruments (Free: 3) | Cannot add new instrument. Existing instruments continue monitoring. Inline upgrade prompt. | "You're monitoring 3 of 3 instruments. Upgrade to Trader for up to 10." |
| Instruments (Trader: 10) | Same pattern. | "You're monitoring 10 of 10 instruments. Upgrade to Pro for unlimited." |
| Journal trades (Free: 10/mo) | Trade still executes (paper mode). Journal entry is created but marked as `"over_limit": true`. Entry is visible but read-only until upgrade or next month. | "You've reached 10 journal entries this month. Upgrade to Trader for unlimited journaling, or wait until {first_day_next_month}." |
| Playbooks (Trader: 5) | Cannot create new playbook. Existing playbooks continue to function. | "You have 5 of 5 custom playbooks. Upgrade to Pro for unlimited playbooks." |
| Broker connections (Trader: 1) | Cannot add new broker. Existing connection continues working. | "You're using 1 of 1 broker connection. Upgrade to Pro to connect up to 3 brokers." |
| AI features (Free/Trader) | Feature button/section visible but disabled with lock icon and upgrade CTA. | "AI Trade Review is available on Pro and above. Upgrade to unlock AI-powered insights." |
| AI budget exhausted (Pro/Team) | AI features disabled for remainder of month. | "You've used your AI budget for this month. Resets on {first_day_next_month}." |

**Design Principles:**
- NEVER interrupt an active trade due to a tier limit. If a trade is in progress, it completes regardless of tier status.
- NEVER silently fail. Every limit-reached scenario shows a clear, specific message.
- Upgrade CTAs link to `/pricing?highlight={recommended_tier}` with the recommended tier pre-highlighted.
- Usage counters are visible in the UI wherever limits apply: "3/10 instruments used", "8/10 journal entries this month".

---

### 3.15 BL-FR-015: Usage Tracking

**Source:** PRD-009 Section 3.3, BL-FR-015

**Description:** The system tracks feature usage for enforcement of tier limits and analytics.

**`usage_tracking` Table Schema:**

| Column | Type | Constraints | Description |
|---|---|---|---|
| id | bigint | PK, AUTO_INCREMENT | Primary key |
| user_id | uuid | FK to users, NOT NULL | User identifier |
| metric_key | varchar(50) | NOT NULL | e.g., `journal_entries`, `ai_invocations` |
| period_start | date | NOT NULL | First day of the tracking period |
| period_end | date | NOT NULL | Last day of the tracking period |
| current_value | integer | NOT NULL, DEFAULT 0 | Current count for this period |
| limit_value | integer | NULLABLE | Tier limit for this metric (null = unlimited) |
| created_at | timestamptz | NOT NULL, DEFAULT now() | Record creation |
| updated_at | timestamptz | NOT NULL, DEFAULT now() | Last update |

**Unique constraint:** `(user_id, metric_key, period_start)`

**Tracked Metrics:**

| Metric Key | Tracked Per | Reset Cycle | Notes |
|---|---|---|---|
| `journal_entries` | user, month | Monthly (calendar month) | Count of journal entries created |
| `active_instruments` | user | None (running count) | Currently monitored instruments |
| `active_broker_connections` | user | None (running count) | Currently connected brokers |
| `active_accounts` | user, broker | None (running count) | Accounts per broker connection |
| `custom_playbooks` | user | None (running count) | Custom playbooks created |
| `ai_invocations` | user, month | Monthly | AI feature calls |
| `ai_tokens_consumed` | user, month | Monthly | Claude API tokens used |

**Processing Logic:**

1. **Increment:** Usage increments are atomic SQL operations: `UPDATE usage_tracking SET current_value = current_value + 1, updated_at = now() WHERE user_id = :uid AND metric_key = :key AND period_start = :period`.
2. **Check before action:** Before allowing a gated action, the system reads the current usage from Redis cache (populated on first check per period, invalidated on increment). If the `current_value >= limit_value` (and `limit_value` is not null), the action is denied with the appropriate degradation message.
3. **Monthly reset:** A scheduled Celery job runs on the 1st of each month at 00:00 UTC. It creates new `usage_tracking` records for the new period for all active users. Previous period records are retained for analytics.
4. **Cache:** Usage data is cached in Redis key `user:{user_id}:usage:{metric_key}:{period}` with 60-second TTL. Invalidated on every increment.

**Data Retention:** Usage records are retained for 12 months for analytics. After 12 months, records are aggregated into monthly summaries and the raw records are deleted.

---

### 3.16 BL-FR-016: Stripe Webhook Receiver

**Source:** PRD-009 Section 3.4, BL-FR-016

**Description:** The system receives and processes Stripe webhook events for subscription and payment lifecycle management.

**Endpoint:** `POST /api/webhooks/stripe`
**Authentication:** None (public endpoint). Protected by signature verification (BL-FR-017).

**Processing Logic:**

1. Receive raw request body and `Stripe-Signature` header.
2. Verify signature (BL-FR-017). If invalid, return `400 Bad Request` immediately.
3. Parse the event. Check idempotency (BL-FR-018). If already processed, return `200 OK`.
4. Acknowledge receipt by returning `200 OK` to Stripe.
5. Dispatch event to background Celery task queue for asynchronous processing.
6. Background worker processes the event based on type (see table below).

**Handled Events and Actions:**

| Stripe Event | Background Processing Actions |
|---|---|
| `checkout.session.completed` | 1. Extract `customer` and `subscription` from the session. 2. Look up user by `user_id` in session metadata. 3. Update subscriptions table: set `stripe_customer_id`, `stripe_subscription_id`, `tier` (from metadata), `status = "active"` or `"trialing"`, `billing_interval`, `current_period_start/end`. 4. Set `has_used_trial = true` if trial was included. 5. Invalidate Redis tier cache. 6. Send `welcome_paid` or `welcome_trial` email. |
| `customer.subscription.created` | 1. Update subscription status to `active`. 2. Update tier. 3. Log event in audit trail. |
| `customer.subscription.updated` | 1. Compare previous and current subscription attributes. 2. If tier changed: update local tier, invalidate Redis cache. 3. If billing interval changed: update local `billing_interval`. 4. If status changed (e.g., `past_due`): update local status. 5. If `cancel_at_period_end` changed: update local field. 6. If pending downgrade completed (new tier is lower): update tier, clear `pending_downgrade_tier`. |
| `customer.subscription.deleted` | 1. Set `tier = "free"`. 2. Set `status = "cancelled"`. 3. Clear `pending_downgrade_tier`. 4. Invalidate Redis cache. 5. Send `cancellation_effective` email. |
| `customer.subscription.paused` | 1. Set `status = "paused"`. 2. Revert tier enforcement to Free limits (but do NOT change `tier` field — preserve the "real" tier for resume). 3. Invalidate Redis cache. |
| `customer.subscription.resumed` | 1. Restore tier from subscription record. 2. Set `status = "active"`. 3. Invalidate Redis cache. |
| `customer.subscription.trial_will_end` | 1. Send `trial_ending` email: "Your Pro trial ends in 3 days. Your card ending in {last4} will be charged $99/mo. Cancel anytime before {trial_end_date}." |
| `invoice.payment_succeeded` | 1. Update `last_payment_date` on subscription. 2. Reset dunning state: `payment_status = "current"`, `dunning_step = 0`, `dunning_started_at = null`. 3. Store invoice metadata in `invoices` table. 4. Send `invoice_receipt` email. |
| `invoice.payment_failed` | 1. Extract `attempt_count` from invoice. 2. Update `payment_status = "past_due"`. 3. Trigger dunning sequence (BL-FR-020): increment `dunning_step`, send appropriate dunning email. 4. If 7 days since first failure: restrict to Free tier limits. |
| `invoice.finalized` | 1. Store invoice ID and PDF URL in `invoices` table. |
| `payment_method.attached` | 1. Update `payment_method_last4` and `payment_method_brand` on user record (see BL-FR-004). |
| `payment_method.detached` | 1. Clear `payment_method_last4` and `payment_method_brand` if it was the default (see BL-FR-004). |
| `customer.updated` | 1. Sync billing email, name, or address changes if applicable. |

**Unhandled events:** Log to monitoring system with event type and ID at INFO level. Return `200 OK`. Do not error on unknown event types.

---

### 3.17 BL-FR-017: Webhook Signature Verification

**Source:** PRD-009 Section 3.4, BL-FR-017

**Description:** All incoming Stripe webhooks are verified for authenticity using HMAC-SHA256 signature verification before any processing occurs.

**Processing Logic:**

1. Read the raw request body (do NOT parse JSON first — signature is computed on the raw bytes).
2. Read the `Stripe-Signature` header.
3. Call `stripe.Webhook.construct_event(payload=raw_body, sig_header=signature_header, secret=STRIPE_WEBHOOK_SECRET)`.
4. If verification succeeds: proceed with event processing.
5. If verification fails: return `400 Bad Request` with no additional details. Log a WARNING: `"Webhook signature verification failed. IP: {ip_address}."` Do NOT reveal the reason for rejection in the response body.

**Business Rules:**
- `STRIPE_WEBHOOK_SECRET` is stored in environment variables, never in source code or configuration files committed to version control.
- Separate webhook secrets for test mode and live mode.
- Stripe's timestamp tolerance is 5 minutes. Events with timestamps older than 5 minutes are rejected.
- Webhook signing secret should be rotated annually or immediately upon suspected compromise.

**Rate Limiting:** The webhook endpoint is rate-limited to 100 requests/second to prevent DoS attacks. Requests exceeding this limit receive `429 Too Many Requests`.

---

### 3.18 BL-FR-018: Idempotent Event Processing

**Source:** PRD-009 Section 3.4, BL-FR-018

**Description:** Each webhook event is processed exactly once, even if Stripe delivers it multiple times due to retries or network issues.

**`stripe_events` Table Schema:**

| Column | Type | Constraints | Description |
|---|---|---|---|
| event_id | varchar(255) | PK | Stripe event ID (e.g., `evt_xxx`) |
| event_type | varchar(100) | NOT NULL | e.g., `invoice.payment_succeeded` |
| processed_at | timestamptz | NULLABLE | When processing completed |
| status | varchar(20) | NOT NULL, DEFAULT 'processing' | `processing`, `processed`, `failed`, `skipped` |
| error_message | text | NULLABLE | Error details if processing failed |
| raw_payload | jsonb | NOT NULL | Full event payload for debugging |

**Processing Logic:**

1. Before processing any event, check the `stripe_events` table for the `event_id`:
   - If found with `status = "processed"`: return `200 OK` immediately. Do not process again. Log: `"Skipping duplicate event {event_id} (already processed)."`
   - If found with `status = "failed"`: re-attempt processing. Update `status` to `"processing"`.
   - If found with `status = "processing"`: another worker is currently processing this event. Return `200 OK`. (Handles concurrent webhook deliveries.)
   - If not found: insert a new record with `status = "processing"`.
2. Process the event within a database transaction:
   - If processing succeeds: update `status = "processed"`, set `processed_at`.
   - If processing fails: update `status = "failed"`, set `error_message` with the exception details.
3. For failed events, retry logic: failed events are retried up to 3 times with exponential backoff (1 minute, 5 minutes, 30 minutes). After 3 retries, the event remains as `"failed"` and triggers a CRITICAL alert for manual investigation.

**Data Retention:** Processed events are retained for 90 days, then archived/deleted. Failed events are retained until manually resolved.

---

### 3.19 BL-FR-019 & BL-FR-020: Failed Payment and Dunning Management

**Source:** PRD-009 Section 3.4, BL-FR-019 and BL-FR-020

**Description:** The system handles failed payment retries (managed by Stripe Smart Retries) and implements a dunning email sequence to maximize payment recovery.

**Stripe Retry Configuration:**
- Smart Retries enabled (Stripe's ML-optimized retry timing).
- Maximum retry attempts: 4 over 3 weeks.
- After all retries exhausted: Stripe cancels the subscription.

**Local Dunning State Machine:**

| Dunning Step | Trigger | Timing | Email Template | Access Impact |
|---|---|---|---|---|
| 0 | No failure | N/A | N/A | Full tier access |
| 1 | First `invoice.payment_failed` | Immediately | `payment_failed_1`: "Your payment of ${amount} failed. Please update your payment method to avoid service interruption." CTA: "Update Payment Method" -> Customer Portal | Full tier access (grace period) |
| 2 | Second failure (Stripe retry) | ~3 days after first | `payment_failed_2`: "We're still unable to process your payment. Your access will be limited on {grace_end_date}." CTA: "Update Payment Method" | Full tier access (grace period) |
| 3 | Grace period ending | 6 days after first failure | `payment_grace_ending`: "Action required: Update your payment method by tomorrow to maintain your {tier} access." Urgent tone. CTA: "Update Payment Method" | Full tier access (last day of grace) |
| 4 | Access restricted | 7 days after first failure | `access_restricted`: "Your account has been restricted to Free tier access. Update your payment method to restore full access immediately." CTA: "Restore Access" | **Restricted to Free tier limits** (data preserved) |
| 5 | Final warning | 3 days before Stripe cancellation | `payment_final_warning`: "Your subscription will be cancelled on {cancel_date}. All {tier} features will be permanently removed. Your data will be preserved for 90 days." CTA: "Keep My Subscription" | Free tier limits |
| (cancelled) | Stripe cancels subscription | After all retries exhausted | `cancellation_effective`: "Your subscription has been cancelled. Your data will be preserved for 90 days. You can reactivate anytime." CTA: "Reactivate" | Free tier (subscription ended) |

**Processing Logic:**

1. On `invoice.payment_failed` webhook:
   a. Look up user by `stripe_customer_id`.
   b. If `dunning_step == 0`: set `dunning_started_at = now()`, `payment_status = "past_due"`.
   c. Increment `dunning_step`.
   d. Send the email for the current dunning step.
   e. Each email is tracked (stored in `stripe_events` or a separate `dunning_emails` log) to prevent duplicates.

2. Scheduled job (runs hourly): check all subscriptions with `payment_status = "past_due"`:
   a. If `dunning_started_at` + 6 days <= now AND `dunning_step < 3`: send step 3 email, set `dunning_step = 3`.
   b. If `dunning_started_at` + 7 days <= now AND `dunning_step < 4`: restrict access to Free tier limits, send step 4 email, set `dunning_step = 4`.
   c. If subscription has an upcoming Stripe cancellation date AND cancellation_date - 3 days <= now AND `dunning_step < 5`: send step 5 email, set `dunning_step = 5`.

3. On `invoice.payment_succeeded` webhook (recovery):
   a. Reset: `payment_status = "current"`, `dunning_step = 0`, `dunning_started_at = null`.
   b. If access was restricted: restore full tier access immediately.
   c. Invalidate Redis tier cache.
   d. Send `payment_recovered` email: "Great news! Your payment has been processed successfully. Your {tier} access has been fully restored."

**Business Rules:**
- During the 7-day grace period, the user retains FULL access to their current tier. Access is NOT degraded during grace.
- After 7 days, access is restricted to Free tier limits, but ALL user data is preserved and accessible (read-only for features beyond Free limits).
- The `payment_status` field drives access restriction, separate from the `tier` field. The `tier` remains the user's paid tier until Stripe cancels the subscription.

---

### 3.20 BL-FR-021: Invoice Access

**Source:** PRD-009 Section 3.5, BL-FR-021

**Description:** Users can view and download their billing history, invoices, and receipts.

**API Endpoint:** `GET /api/billing/invoices`
**Authentication:** Required.

**`invoices` Table Schema:**

| Column | Type | Constraints | Description |
|---|---|---|---|
| id | bigint | PK, AUTO_INCREMENT | Primary key |
| user_id | uuid | FK to users, NOT NULL | User identifier |
| stripe_invoice_id | varchar(255) | UNIQUE, NOT NULL | Stripe invoice ID |
| amount_paid | integer | NOT NULL | Amount in cents |
| currency | varchar(3) | NOT NULL, DEFAULT 'usd' | Always `usd` |
| status | varchar(20) | NOT NULL | `paid`, `open`, `void`, `uncollectible` |
| invoice_pdf_url | text | NULLABLE | URL to Stripe-hosted PDF |
| period_start | timestamptz | NOT NULL | Billing period start |
| period_end | timestamptz | NOT NULL | Billing period end |
| created_at | timestamptz | NOT NULL, DEFAULT now() | Invoice creation date |

**Processing Logic:**
1. Invoices are synced from Stripe via webhooks (`invoice.finalized` stores the record, `invoice.payment_succeeded` updates status to `paid`).
2. `GET /api/billing/invoices` returns all invoices for the authenticated user, ordered by `created_at` descending.
3. Each invoice includes a download link to the Stripe-hosted PDF.

**Response (200 OK):**
```json
{
  "invoices": [
    {
      "id": "inv_xxx",
      "date": "2026-03-01",
      "description": "TrendEdge Pro - Monthly",
      "amount": "$99.00",
      "amount_cents": 9900,
      "status": "paid",
      "pdf_url": "https://pay.stripe.com/invoice/xxx/pdf",
      "period": "Mar 1 - Mar 31, 2026"
    }
  ],
  "total_count": 12
}
```

---

### 3.21 BL-FR-022: Claude API Cost Tracking

**Source:** PRD-009 Section 3.6, BL-FR-022

**Description:** The system tracks and meters Claude API usage per user to manage costs and enforce fair use soft caps.

**`ai_usage_log` Table Schema:**

| Column | Type | Constraints | Description |
|---|---|---|---|
| id | bigint | PK, AUTO_INCREMENT | Primary key |
| user_id | uuid | FK to users, NOT NULL | User identifier |
| feature_key | varchar(50) | NOT NULL | `conversational_analytics`, `trade_review`, `journal_review` |
| model | varchar(50) | NOT NULL | e.g., `claude-sonnet-4-20250514` |
| input_tokens | integer | NOT NULL | Tokens in the prompt |
| output_tokens | integer | NOT NULL | Tokens in the response |
| estimated_cost_usd | decimal(10,6) | NOT NULL | Estimated cost |
| created_at | timestamptz | NOT NULL, DEFAULT now() | Timestamp |

**Fair Use Limits (soft caps):**

| Tier | Monthly AI Calls | Monthly Token Budget |
|---|---|---|
| Free | 0 | 0 |
| Trader | 0 | 0 |
| Pro | 100 | 500,000 |
| Team | 500 | 2,500,000 |

**Processing Logic:**
1. Before every Claude API call, check the user's monthly AI usage (calls and tokens) against their tier limit.
2. If at 80% of budget: show UI warning (non-blocking): "You've used 80% of your AI budget for this month ({used}/{limit} calls). Resets on {first_day_next_month}."
3. If at 100% of budget: block the AI call with message: "You've used your AI budget for this month. Resets on {first_day_next_month}." No overage charges at launch.
4. After every Claude API call, log the usage in `ai_usage_log`.
5. Increment the `ai_invocations` and `ai_tokens_consumed` metrics in `usage_tracking`.

---

### 3.22 BL-FR-023: 14-Day Pro Trial

**Source:** PRD-009 Section 3.7, BL-FR-023

**Description:** New users can try the Pro tier free for 14 days. The trial requires a payment method on file and automatically converts to a paid subscription unless cancelled.

**Trial Eligibility:**
- User's `has_used_trial` must be `false`.
- User must not have ever had a paid subscription.
- One trial per account, enforced by the `has_used_trial` boolean.

**Processing Logic:**

1. User selects "Start Free Trial" on the Pro plan.
2. System checks `has_used_trial`. If `true`: return `400 Bad Request` with message: "You've already used your free trial. Subscribe to Pro for $99/month."
3. System creates a Stripe Checkout Session with `subscription_data.trial_period_days: 14` (see BL-FR-002).
4. User enters payment method on Stripe Checkout (required for trial).
5. On `checkout.session.completed` webhook:
   - Set `status = "trialing"`, `tier = "pro"`.
   - Set `trial_start` and `trial_end` dates.
   - Set `has_used_trial = true`.
   - Send `welcome_trial` email.
6. During trial: full Pro tier access.
7. Day 7: send `trial_midpoint` email with usage summary.
8. Day 11 (3 days before end): `customer.subscription.trial_will_end` webhook fires. Send `trial_ending` email.
9. Day 14 — trial ends:
   - If payment method valid: Stripe charges $99.00. `customer.subscription.updated` webhook fires with status `active`. Send `trial_converted` email.
   - If payment fails: subscription enters dunning flow (BL-FR-020).
10. If user cancels during trial:
    - Access remains Pro until trial end date.
    - No charge is made.
    - After trial end: `customer.subscription.deleted` webhook fires. User reverts to Free. Send `trial_expired` email.

**Trial Notification Schedule:**

| Timing | Template | Key Content |
|---|---|---|
| Trial start | `welcome_trial` | "Welcome to your 14-day Pro trial! Here's what you can do: [feature list]. Your trial ends on {trial_end_date}." |
| Day 7 | `trial_midpoint` | "You're halfway through your Pro trial. Here's what you've accomplished: {usage_summary}." |
| Day 11 | `trial_ending` | "Your Pro trial ends in 3 days on {trial_end_date}. Your card ending in {last4} will be charged $99/mo. Cancel anytime before {trial_end_date}." |
| Trial auto-converts | `trial_converted` | "Your trial has ended. Welcome to TrendEdge Pro! You've been charged $99.00." |
| Trial cancelled/expired | `trial_expired` | "Your Pro trial has ended. You're now on the Free plan. Upgrade anytime to get Pro features back." |

---

### 3.23 BL-FR-024: Coupon and Promotion Code Support

**Source:** PRD-009 Section 3.8, BL-FR-024

**Description:** The system supports Stripe coupons and promotion codes for discounts during checkout and post-checkout.

**Coupon Types:**

| Type | Example | Stripe Configuration |
|---|---|---|
| Percentage off (duration) | 25% off for 3 months | `percent_off: 25`, `duration: "repeating"`, `duration_in_months: 3` |
| Fixed amount off (once) | $20 off first month | `amount_off: 2000`, `currency: "usd"`, `duration: "once"` |
| Percentage off (forever) | 15% off forever | `percent_off: 15`, `duration: "forever"` |

**System-Generated Coupons:**
- `retention_25pct_3mo`: 25% off for 3 months. Used in cancellation retention flow (BL-FR-008).
- `annual_switch_10pct`: 10% off first year. Used to incentivize monthly-to-annual switches.
- `referral_1mo_free`: 1 month free (100% off, once). Reserved for future referral program.

**Promotion Code Features:**
- Human-readable strings (e.g., `LAUNCH25`, `TRADERLIFE`, `RETENTION25`).
- Configurable restrictions: minimum tier, maximum redemptions, expiration date, first-time customers only.
- Applied during Stripe Checkout (`allow_promotion_codes: true`) or via Customer Portal post-checkout.
- Created via admin dashboard (`/admin/promotions`) or Stripe Dashboard.

**Admin Management (at `/admin/promotions`):**
- List all active coupons and promotion codes with: code, discount details, redemption count, max redemptions, expiration, status (active/expired/archived).
- Create new promotion codes with configurable rules.
- Deactivate existing codes.
- View redemption history per code.

---

### 3.24 BL-FR-025: Revenue Analytics Dashboard

**Source:** PRD-009 Section 3.9, BL-FR-025

**Description:** Admin-only dashboard at `/admin/revenue` displaying key revenue and subscription metrics.

**Access Control:** Requires `admin` role. [Cross-reference: see FSD-008 for role-based access control] Non-admin users receive `403 Forbidden`.

**Metrics Displayed:**

| Category | Specific Metrics |
|---|---|
| Revenue | MRR, ARR, total revenue (MTD, QTD, YTD), revenue by tier, revenue by billing interval |
| Subscriptions | Total active, count by tier, new this period, churned this period |
| Churn | Monthly churn rate (%), by tier, by cancellation reason, net revenue churn |
| Growth | Net new MRR, expansion MRR (upgrades), contraction MRR (downgrades), churned MRR |
| Trials | Active trials, trial-to-paid conversion rate, trial cancellation rate |
| Payments | Successful count/$, failed count/$, recovery rate, ARPU |
| AI Costs | Total Claude API costs, cost per user, cost by feature, margin impact |
| Coupons | Active promotions, total discount given, redemption counts |

**Visualizations:**
- MRR trend chart (line, 12-month rolling)
- Subscription distribution (stacked bar by tier)
- Churn cohort analysis (heatmap)
- Revenue waterfall (new + expansion - contraction - churn)
- Trial funnel (started -> converted -> churned)

**Data Source:** Pre-computed metrics from `revenue_metrics_daily` table, refreshed every 15 minutes by a background Celery job. Dashboard page load target: under 3 seconds for up to 10,000 subscriptions.

---

### 3.25 BL-FR-026: Refund Processing

**Source:** PRD-009 Section 3.10, BL-FR-026

**Description:** Admin-only refund processing through the admin interface.

**Refund Policy:**
- Full refund within 7 days of initial subscription purchase (no questions asked).
- Pro-rated refund at admin discretion for annual subscribers within 30 days.
- No automatic refunds; all require admin approval.
- Refunds for current billing period only; past periods not refundable.

**Admin Refund Flow:**
1. Admin navigates to user's billing page in admin panel.
2. Admin selects the invoice to refund.
3. Admin chooses: full refund or partial refund (specifies amount in dollars).
4. Admin enters a reason (required, min 10 characters).
5. System validates: refund amount must not exceed the invoice's `amount_paid`.
6. System calls `stripe.Refund.create(charge=charge_id, amount=amount_in_cents)`.
7. On success: update local invoice status to `"refunded"`, log refund in `refunds` table, send `refund_issued` email to user: "You've been issued a refund of ${amount}. It may take 5-10 business days to appear on your statement."
8. Refund does NOT automatically cancel the subscription. Admin must separately cancel if needed.

**`refunds` Table Schema:**

| Column | Type | Constraints | Description |
|---|---|---|---|
| id | bigint | PK, AUTO_INCREMENT | Primary key |
| user_id | uuid | FK to users, NOT NULL | Refunded user |
| stripe_refund_id | varchar(255) | UNIQUE, NOT NULL | Stripe refund ID |
| stripe_invoice_id | varchar(255) | NOT NULL | Original invoice ID |
| amount | integer | NOT NULL | Refund amount in cents |
| reason | text | NOT NULL | Admin-provided reason |
| processed_by | uuid | FK to users, NOT NULL | Admin user ID |
| created_at | timestamptz | NOT NULL, DEFAULT now() | Refund timestamp |

**Error Handling:**

| Condition | Response |
|---|---|
| Refund amount exceeds invoice amount | `400 Bad Request`: `"Refund amount cannot exceed the original invoice amount of ${invoice_amount}."` |
| Invoice already refunded | `409 Conflict`: `"This invoice has already been refunded."` |
| Reason too short | `400 Bad Request`: `"Please provide a refund reason (minimum 10 characters)."` |
| Stripe refund API fails | `502 Bad Gateway`: `"Refund could not be processed by our payment provider. Please try again."` |
| Non-admin user attempts refund | `403 Forbidden` |

---

### 3.26 BL-FR-027 & BL-FR-028: Subscription Data Model and State Machine

**Source:** PRD-009 Sections 3.11 and 3.12

**Description:** The local `subscriptions` table is the primary local record of subscription state, synchronized with Stripe via webhooks. The state machine enforces valid state transitions.

**`subscriptions` Table Schema:**

| Column | Type | Constraints | Description |
|---|---|---|---|
| id | bigint | PK, AUTO_INCREMENT | Primary key |
| user_id | uuid | FK to users, UNIQUE, NOT NULL | One subscription per user |
| stripe_subscription_id | varchar(255) | UNIQUE, NULLABLE | Null for Free tier |
| stripe_customer_id | varchar(255) | NULLABLE | Null for Free tier before first paid action |
| tier | varchar(20) | NOT NULL, DEFAULT 'free' | `free`, `trader`, `pro`, `team` |
| status | varchar(20) | NOT NULL, DEFAULT 'active' | `active`, `trialing`, `past_due`, `paused`, `cancelling`, `cancelled` |
| billing_interval | varchar(10) | NOT NULL, DEFAULT 'none' | `monthly`, `annual`, `none` |
| current_period_start | timestamptz | NULLABLE | Start of current billing period |
| current_period_end | timestamptz | NULLABLE | End of current billing period |
| trial_start | timestamptz | NULLABLE | Trial start date |
| trial_end | timestamptz | NULLABLE | Trial end date |
| cancel_at_period_end | boolean | NOT NULL, DEFAULT false | Cancellation pending |
| cancelled_at | timestamptz | NULLABLE | When cancellation was requested |
| cancellation_reason | varchar(50) | NULLABLE | From cancellation survey |
| pending_downgrade_tier | varchar(20) | NULLABLE | Tier to downgrade to at period end |
| payment_status | varchar(20) | NOT NULL, DEFAULT 'current' | `current`, `past_due`, `unpaid` |
| dunning_step | integer | NOT NULL, DEFAULT 0 | Current dunning step (0-5) |
| dunning_started_at | timestamptz | NULLABLE | When dunning began |
| has_used_trial | boolean | NOT NULL, DEFAULT false | Trial usage flag |
| pause_starts_at | timestamptz | NULLABLE | Pause start date |
| pause_resumes_at | timestamptz | NULLABLE | Pause auto-resume date |
| payment_method_last4 | varchar(4) | NULLABLE | Display only |
| payment_method_brand | varchar(20) | NULLABLE | Display only |
| created_at | timestamptz | NOT NULL, DEFAULT now() | Record creation |
| updated_at | timestamptz | NOT NULL, DEFAULT now() | Last update |

**Indexes:**
- `idx_subscriptions_user_id` (unique)
- `idx_subscriptions_stripe_subscription_id` (unique, partial: WHERE stripe_subscription_id IS NOT NULL)
- `idx_subscriptions_stripe_customer_id`
- `idx_subscriptions_status`
- `idx_subscriptions_tier`

**State Machine — Valid Transitions:**

| From State | Event | To State | Actions |
|---|---|---|---|
| (none) | user_registers | active (free) | Create subscription record: `tier="free"`, `status="active"`. |
| active (free) | checkout_completed | active (paid) | Update tier, set Stripe IDs, send welcome email. |
| active (free) | trial_started | trialing | Set `tier="pro"`, set trial dates, send trial welcome. |
| trialing | trial_ended_payment_success | active (paid) | `status="active"`, send conversion email. |
| trialing | trial_ended_payment_failed | past_due | Begin dunning sequence. |
| trialing | user_cancels | cancelling | `cancel_at_period_end=true`, retain access until trial end. |
| active (paid) | upgrade_completed | active (paid) | Update tier, proration charged, send upgrade confirmation. |
| active (paid) | downgrade_requested | active (paid) | Set `pending_downgrade_tier`. No immediate tier change. |
| active (paid) | billing_interval_changed | active (paid) | Update interval, process proration if applicable. |
| active (paid) | payment_failed | past_due | `payment_status="past_due"`, begin dunning. |
| active (paid) | user_cancels | cancelling | `cancel_at_period_end=true`, retention offer shown. |
| active (paid) | pause_requested | paused | Set pause dates, revert to Free limits, void invoices. |
| past_due | payment_succeeded | active (paid) | Reset dunning, restore full access. |
| past_due | all_retries_exhausted | cancelled | Cancel subscription, revert to Free, send email. |
| past_due | user_updates_payment | active (paid) | Retry charge; if successful, reset dunning. |
| paused | resume_requested | active (paid) | Resume billing, restore tier. |
| paused | pause_expired | active (paid) | Auto-resume, restart billing cycle. |
| cancelling | period_ends | cancelled | Revert to Free, begin data retention countdown. |
| cancelling | user_reactivates | active (paid) | Remove `cancel_at_period_end`, continue subscription. |
| cancelled | user_resubscribes | active (paid) | New Checkout, create new subscription, restore data if within retention. |

**Invalid transitions** are rejected with a logged ERROR and a user-facing message: "This action cannot be performed on your current subscription status. Current status: {status}." HTTP status: `409 Conflict`.

---

## 4. Data Specifications

### 4.1 Database Tables Summary

| Table | Purpose | Primary Key | Key Foreign Keys |
|---|---|---|---|
| `subscriptions` | Subscription lifecycle, tier, billing state | `id` (bigint) | `user_id` -> users |
| `invoices` | Invoice metadata and PDF URLs | `id` (bigint) | `user_id` -> users |
| `usage_tracking` | Feature usage counters per period | `id` (bigint) | `user_id` -> users |
| `ai_usage_log` | Claude API call logs per user | `id` (bigint) | `user_id` -> users |
| `stripe_events` | Idempotent webhook event tracking | `event_id` (varchar) | None |
| `refunds` | Refund records | `id` (bigint) | `user_id` -> users, `processed_by` -> users |
| `cancellation_events` | Cancellation reason and retention analytics | `id` (bigint) | `user_id` -> users |
| `revenue_metrics_daily` | Pre-computed revenue metrics for dashboard | `id` (bigint) | None |

### 4.2 `revenue_metrics_daily` Table Schema

| Column | Type | Constraints | Description |
|---|---|---|---|
| id | bigint | PK, AUTO_INCREMENT | Primary key |
| date | date | NOT NULL, UNIQUE | Metrics date |
| mrr | integer | NOT NULL | MRR in cents |
| arr | integer | NOT NULL | ARR in cents |
| total_active_subscriptions | integer | NOT NULL | Total active subscribers |
| free_count | integer | NOT NULL | Free tier count |
| trader_count | integer | NOT NULL | Trader tier count |
| pro_count | integer | NOT NULL | Pro tier count |
| team_count | integer | NOT NULL | Team tier count |
| new_subscriptions | integer | NOT NULL | New subscriptions today |
| churned_subscriptions | integer | NOT NULL | Churned today |
| monthly_churn_rate | decimal(5,2) | NOT NULL | Monthly churn % |
| expansion_mrr | integer | NOT NULL | MRR from upgrades (cents) |
| contraction_mrr | integer | NOT NULL | MRR from downgrades (cents) |
| churned_mrr | integer | NOT NULL | MRR lost to churn (cents) |
| trial_active | integer | NOT NULL | Active trials |
| trial_converted | integer | NOT NULL | Trials converted today |
| total_ai_cost_usd | decimal(10,2) | NOT NULL | Aggregate AI cost |
| created_at | timestamptz | NOT NULL, DEFAULT now() | Record creation |

### 4.3 Redis Cache Keys

| Key Pattern | Value | TTL | Invalidation |
|---|---|---|---|
| `user:{user_id}:tier_features` | JSON: `{ "tier": "pro", "status": "active", "limits": { ... } }` | 60 seconds | On webhook tier change; on user login (warmed) |
| `user:{user_id}:usage:{metric_key}:{period}` | Integer: current usage count | 60 seconds | On every usage increment |

---

## 5. API Specifications

### 5.1 Billing API Endpoints

| Method | Path | Auth | Rate Limit | Description |
|---|---|---|---|---|
| POST | `/api/billing/checkout` | Required | 10/min/user | Create Stripe Checkout Session |
| POST | `/api/billing/portal` | Required | 10/min/user | Create Stripe Customer Portal Session |
| POST | `/api/billing/pause` | Required | 10/min/user | Pause subscription |
| POST | `/api/billing/resume` | Required | 10/min/user | Resume paused subscription |
| POST | `/api/billing/reactivate` | Required | 10/min/user | Reactivate cancelled subscription |
| GET | `/api/billing/invoices` | Required | 60/min/user | List user's invoices |
| GET | `/api/billing/subscription` | Required | 60/min/user | Get current subscription details |
| GET | `/api/billing/usage` | Required | 60/min/user | Get current usage metrics |
| POST | `/api/webhooks/stripe` | None (signature verified) | 100/sec | Stripe webhook receiver |

### 5.2 Admin Billing API Endpoints

| Method | Path | Auth | Rate Limit | Description |
|---|---|---|---|---|
| GET | `/api/admin/revenue/metrics` | Admin role | 60/min | Revenue analytics data |
| GET | `/api/admin/revenue/subscriptions` | Admin role | 60/min | Subscription list with filters |
| POST | `/api/admin/billing/refund` | Admin role | 10/min | Process a refund |
| GET | `/api/admin/promotions` | Admin role | 60/min | List promotion codes |
| POST | `/api/admin/promotions` | Admin role | 10/min | Create promotion code |
| PATCH | `/api/admin/promotions/{id}` | Admin role | 10/min | Update/deactivate promotion |
| GET | `/api/admin/billing/user/{user_id}` | Admin role | 60/min | View user's billing details |
| GET | `/api/admin/ai-usage` | Admin role | 60/min | AI usage cost report |

### 5.3 Key API Response Formats

**GET `/api/billing/subscription` Response (200 OK):**
```json
{
  "tier": "pro",
  "status": "active",
  "billing_interval": "monthly",
  "current_period_start": "2026-03-01T00:00:00Z",
  "current_period_end": "2026-03-31T23:59:59Z",
  "cancel_at_period_end": false,
  "pending_downgrade_tier": null,
  "payment_status": "current",
  "payment_method": {
    "brand": "visa",
    "last4": "4242"
  },
  "trial": null,
  "next_invoice_amount": "$99.00",
  "next_invoice_date": "2026-04-01"
}
```

**GET `/api/billing/usage` Response (200 OK):**
```json
{
  "period": "2026-03",
  "metrics": {
    "journal_entries": { "used": 42, "limit": null, "display": "42 (unlimited)" },
    "active_instruments": { "used": 8, "limit": null, "display": "8 (unlimited)" },
    "ai_invocations": { "used": 67, "limit": 100, "display": "67 / 100" },
    "ai_tokens_consumed": { "used": 312000, "limit": 500000, "display": "312K / 500K" }
  }
}
```

---

## 6. UI/UX Specifications

### 6.1 Pricing Page (`/pricing`)

**Layout:** Side-by-side comparison of all four tiers with monthly/annual toggle.

**Monthly/Annual Toggle:**
- Default: Monthly selected.
- When Annual is selected, prices update to annual amounts with savings badge: "Save 32%", "Save 33%", "Save 21%".
- Toggle animates prices smoothly (200ms transition).

**Tier Cards:**
- Each card shows: tier name, price, billing interval, feature list with checkmarks/x-marks.
- Current plan card is highlighted with "Current Plan" badge and the CTA button reads "Current Plan" (disabled).
- Higher plans show "Upgrade" button (primary action color).
- Lower plans show "Downgrade" link (secondary, less prominent).
- Free tier shows "Get Started" for unauthenticated users, "Current Plan" for Free users.
- If `highlight` query param is present (e.g., `/pricing?highlight=pro`), that tier card has a visual emphasis (border glow, "Recommended" badge).

**Trial CTA:** If user is eligible for trial (`has_used_trial == false`), the Pro card shows "Start 14-Day Free Trial" instead of "Upgrade".

### 6.2 Billing Settings Page (`/settings/billing`)

**Sections:**
1. **Current Plan:** Tier name, status, next billing date, amount. "Change Plan" and "Cancel Subscription" links.
2. **Payment Method:** Card brand icon, last 4 digits. "Manage" button -> Customer Portal.
3. **Billing History:** Link to `/settings/billing/history`.
4. **Usage:** Current period usage metrics (journal entries, instruments, AI calls) with visual progress bars.

**Banners (conditional):**
- Pending cancellation: "Your {tier} plan will end on {date}. You have full access until then. [Reactivate]"
- Pending downgrade: "Your plan will change to {tier} on {date}. [Cancel Downgrade]"
- Paused: "Your subscription is paused until {date}. [Resume Now]"
- Past due: "Your payment is past due. [Update Payment Method] to avoid service interruption."
- Access restricted (7+ days past due): "Your account has been restricted to Free tier access. [Restore Access]"

### 6.3 Feature Gate UI Patterns

**Lock Icon Pattern:** For features the user does not have access to:
- Feature is visible in the UI navigation/menu.
- A small lock icon appears next to the feature name.
- Clicking the feature shows a modal: "{Feature Name} is available on {required_tier} and above. [View Plans]"

**Usage Counter Pattern:** For features with numeric limits:
- Progress bar showing usage: "3/10 instruments used" with bar at 30%.
- At 80%+ usage: bar turns yellow/warning color.
- At 100% usage: bar turns red, "Upgrade" link appears inline.

**Inline Upgrade Prompt Pattern:** When a user hits a limit during a workflow:
- Non-blocking toast/banner at the top of the relevant section.
- Message includes the specific limit, what the user needs, and a CTA.
- Example: "You've reached your instrument limit. [Upgrade to Pro] for unlimited instruments."

---

## 7. Integration Specifications

### 7.1 Stripe Integration

**Provider:** Stripe
**API Version:** 2023-10-16 or later
**SDK:** `stripe` Python package (latest stable version)

**Stripe Resources Used:**

| Resource | Operations | Purpose |
|---|---|---|
| Products | Create, Retrieve | Tier product definitions |
| Prices | Create, Retrieve, List | Monthly and annual price configurations |
| Customers | Create, Retrieve, Update | One-to-one mapping with TrendEdge users |
| Subscriptions | Create, Retrieve, Update, Cancel | Subscription lifecycle management |
| Checkout Sessions | Create | New subscription checkout |
| Billing Portal Sessions | Create | Self-service billing management |
| Invoices | Retrieve, List, Upcoming | Invoice history, PDF access, proration preview |
| Refunds | Create | Admin-initiated refunds |
| Coupons | Create, Retrieve, Update, Delete | Discount management |
| Promotion Codes | Create, Retrieve, Update | User-facing discount codes |
| Webhooks | Receive | Event-driven subscription management |
| Payment Methods | Retrieve | Display card info (last4, brand) |

**Error Handling for Stripe API Calls:**

| Error Type | HTTP Status from Stripe | TrendEdge Response |
|---|---|---|
| `CardError` | 402 | Forward decline message to user: "Your card was declined: {decline_message}" |
| `RateLimitError` | 429 | Retry with exponential backoff: 1s, 2s, 4s. Max 3 retries. If still failing: `503 Service Unavailable` |
| `InvalidRequestError` | 400 | Log ERROR with full details. Return `400 Bad Request` with generic message. |
| `AuthenticationError` | 401 | Log CRITICAL: "Stripe API key invalid." Alert ops. Return `503 Service Unavailable`. |
| `APIConnectionError` | N/A (network) | Retry once after 2s. If still failing: `503 Service Unavailable`. |
| `StripeError` (generic) | 500 | Log ERROR. Return `503 Service Unavailable`: "Payment processing is temporarily unavailable." |

**Fallback Behavior:**
- If Stripe is unavailable for > 5 minutes: feature gating continues from cached data. New subscriptions and changes are blocked. Health check endpoint `/api/health/billing` reports Stripe as degraded.
- Queued webhook events (from Stripe retries) are processed when connectivity is restored.

### 7.2 SendGrid Integration

**Provider:** SendGrid
**Purpose:** Transactional email delivery for all billing-related communications.

**Email Templates Required:**

| Template ID | Trigger | Key Variables |
|---|---|---|
| `welcome_paid` | Subscription created | `tier_name`, `features_list`, `next_billing_date` |
| `welcome_trial` | Trial started | `tier_name`, `trial_end_date`, `cancel_instructions` |
| `trial_midpoint` | Day 7 of trial | `usage_summary`, `days_remaining` |
| `trial_ending` | 3 days before trial end | `trial_end_date`, `charge_amount`, `last4`, `cancel_url` |
| `trial_converted` | Trial auto-converts | `tier_name`, `charge_amount`, `next_billing_date` |
| `trial_expired` | Trial cancelled/expired | `upgrade_url` |
| `upgrade_confirmation` | Upgrade processed | `new_tier`, `prorated_charge`, `new_features` |
| `downgrade_scheduled` | Downgrade requested | `effective_date`, `lost_features`, `cancel_downgrade_url` |
| `downgrade_effective` | Downgrade takes effect | `new_tier`, `feature_changes`, `upgrade_url` |
| `cancellation_confirmation` | Cancellation requested | `access_end_date`, `data_retention_days`, `reactivate_url` |
| `cancellation_effective` | Subscription cancelled | `reactivate_url`, `data_retention_timeline` |
| `payment_failed_1` | First payment failure | `amount`, `update_payment_url` |
| `payment_failed_2` | Second failure | `amount`, `grace_end_date`, `update_payment_url` |
| `payment_grace_ending` | 6 days after first failure | `tier_name`, `update_payment_url` |
| `access_restricted` | 7 days after first failure | `restore_access_url` |
| `payment_final_warning` | 3 days before cancellation | `cancel_date`, `tier_name`, `keep_subscription_url` |
| `payment_recovered` | Successful retry | `tier_name`, `amount` |
| `invoice_receipt` | Payment succeeded | `amount`, `invoice_url`, `next_billing_date` |
| `refund_issued` | Refund processed | `refund_amount`, `timeline` |
| `reactivation_confirmation` | Subscription reactivated | `tier_name`, `next_billing_date`, `features_restored` |
| `pause_confirmation` | Subscription paused | `resume_date`, `free_access_note` |
| `pause_resuming` | 3 days before auto-resume | `resume_date`, `billing_restart_note` |

**Error Handling:**
- If SendGrid returns 429 (rate limited): exponential backoff (1s, 2s, 4s), max 3 retries.
- If SendGrid returns 500: queue email for retry in 5 minutes, alert after 3 consecutive failures.
- If SendGrid is unavailable for > 15 minutes: queue all emails locally, process when recovered. Show user "Email will arrive shortly" instead of immediate confirmation.
- Email delivery failures NEVER block subscription state changes. A failed dunning email does not prevent access restriction.

### 7.3 Environment Variables

| Variable | Description | Required | Default |
|---|---|---|---|
| `STRIPE_SECRET_KEY` | Stripe API secret key (live or test) | Yes | None |
| `STRIPE_PUBLISHABLE_KEY` | Stripe publishable key for client-side | Yes | None |
| `STRIPE_WEBHOOK_SECRET` | Webhook endpoint signing secret | Yes | None |
| `STRIPE_PRICE_TRADER_MONTHLY` | Price ID for Trader monthly | Yes | None |
| `STRIPE_PRICE_TRADER_ANNUAL` | Price ID for Trader annual | Yes | None |
| `STRIPE_PRICE_PRO_MONTHLY` | Price ID for Pro monthly | Yes | None |
| `STRIPE_PRICE_PRO_ANNUAL` | Price ID for Pro annual | Yes | None |
| `STRIPE_PRICE_TEAM_MONTHLY` | Price ID for Team monthly | Yes | None |
| `STRIPE_PRICE_TEAM_ANNUAL` | Price ID for Team annual | Yes | None |
| `STRIPE_PORTAL_CONFIG_ID` | Customer portal configuration ID | Yes | None |
| `BILLING_TRIAL_DAYS` | Trial period in days | No | 14 |
| `BILLING_DUNNING_GRACE_DAYS` | Grace period before access restriction | No | 7 |
| `BILLING_DATA_RETENTION_DAYS` | Days to retain cancelled user data | No | 90 |
| `BASE_URL` | Application base URL for Stripe redirect URLs | Yes | None |

---

## 8. Security Specifications

### 8.1 PCI DSS Compliance

TrendEdge is classified as **PCI SAQ-A** (Self-Assessment Questionnaire A), the simplest PCI compliance level. All cardholder data is handled exclusively by Stripe.

**Mandatory requirements:**
- No credit card numbers, CVVs, or full card data SHALL be transmitted to, processed by, or stored on TrendEdge servers at any time, in any form (database, log, cache, file, memory dump).
- All payment forms use Stripe Checkout (hosted pages). Card data never transits TrendEdge servers.
- Stripe.js is loaded directly from `js.stripe.com` -- it MUST NOT be self-hosted or bundled.
- TrendEdge servers communicate with Stripe only via server-side API using the `STRIPE_SECRET_KEY` over HTTPS.
- The system stores only: Stripe customer ID, last 4 digits of card, card brand, and expiration month/year (for display purposes only).
- Annual PCI SAQ-A self-assessment must be completed and documented.

**Prohibited actions (hard requirements):**
- NEVER log raw card numbers, even partially (beyond last 4).
- NEVER store CVV/CVC values in any form.
- NEVER transmit card data through TrendEdge API endpoints.
- NEVER render card input fields on TrendEdge-hosted pages (use Stripe Checkout or Stripe Elements only).

### 8.2 Stripe API Key Security

| Key Type | Storage | Access |
|---|---|---|
| `STRIPE_SECRET_KEY` | Environment variable only | Server-side code only. Never exposed to client. |
| `STRIPE_PUBLISHABLE_KEY` | Environment variable, exposed to frontend | Client-side JavaScript only. Safe to expose. |
| `STRIPE_WEBHOOK_SECRET` | Environment variable only | Webhook handler only. |

**Key management rules:**
- Stripe API keys MUST NOT appear in source code, configuration files committed to version control, client-side JavaScript (secret key), log output at any level (including DEBUG), error messages or stack traces returned to users, or database records.
- Separate keys for test mode and live mode environments.
- Key rotation: immediately upon suspected compromise. Proactively at least annually.
- If a `STRIPE_SECRET_KEY` is detected in source code or logs, treat as a security incident: rotate immediately, audit access logs, notify security team.

### 8.3 Webhook Security

**Signature verification:**
- All webhook requests are verified using Stripe's HMAC-SHA256 signature scheme before any processing occurs (BL-FR-017).
- Invalid signatures result in `400 Bad Request` with no additional details. The response body MUST NOT indicate why the request was rejected.
- Webhook signing secret is rotated annually or immediately upon suspected compromise.
- Separate webhook signing secrets for test and live modes.

**Rate limiting:**
- Webhook endpoint is rate-limited to 100 requests/second to mitigate DoS attacks.
- Requests exceeding this limit receive `429 Too Many Requests`.

**Timestamp validation:**
- Events with timestamps older than 5 minutes (300 seconds) are rejected per Stripe's tolerance window.

### 8.4 API Endpoint Security

**Authentication:**
- All billing API endpoints (except the webhook receiver) require a valid JWT token. [Cross-reference: see FSD-008 for JWT authentication details]
- Admin billing endpoints additionally require the `admin` role claim in the JWT.

**Authorization:**
- Users can only access their own billing data. The `user_id` is extracted from the JWT, not from request parameters.
- Admin endpoints validate the `admin` role before processing any request.
- A non-admin user attempting to access admin endpoints receives `403 Forbidden` with no additional information about what the endpoint does.

**Rate limiting:**
- Mutation endpoints (checkout, cancel, upgrade, pause, resume, reactivate): 10 requests/minute per user.
- Read endpoints (subscription, invoices, usage): 60 requests/minute per user.
- Admin endpoints: 60 requests/minute per admin user (read), 10 requests/minute (write).
- Rate limit exceeded: `429 Too Many Requests` with `Retry-After` header.

### 8.5 Audit Trail

All billing-related actions are logged in an audit trail with the following fields:

| Field | Type | Description |
|---|---|---|
| id | bigint | Primary key |
| user_id | uuid | User who performed or was affected by the action |
| action | varchar(50) | e.g., `subscription_created`, `upgrade_completed`, `refund_issued`, `cancellation_requested` |
| actor_id | uuid | User who initiated the action (same as user_id for self-service, admin_id for admin actions) |
| details | jsonb | Action-specific details (tier change, amount, reason, etc.) |
| ip_address | inet | IP address of the requester |
| timestamp | timestamptz | When the action occurred |

**Audit events logged:**
- Subscription created, updated, cancelled, paused, resumed, reactivated
- Upgrade and downgrade requests and completions
- Payment succeeded, failed, recovered
- Refund issued (including admin ID and reason)
- Promotion code applied
- Admin dashboard accessed
- Billing portal session created
- Webhook events processed (event type and outcome)

**Retention:** Audit logs are retained for 7 years (consistent with financial record retention requirements).

### 8.6 Sensitive Data Handling

**Webhook payload logging:**
- Webhook payloads are logged for debugging purposes but with PII redaction.
- Redacted fields: `customer.email`, `customer.name`, `customer.address`, `payment_method.billing_details`.
- Retained fields: `event.type`, `event.id`, `subscription.id`, `subscription.status`, `invoice.id`, `invoice.amount_paid`.

**Database access:**
- Access to billing tables (`subscriptions`, `invoices`, `refunds`, `stripe_events`) is restricted to the billing service and admin roles at the application level.
- Billing data is excluded from general database exports and development database seeds.
- Production billing data MUST NOT be copied to staging or development environments. Use Stripe test mode data for non-production environments.

---

## 9. Performance Specifications

### 9.1 Feature Gate Check Latency

| Metric | Target | Measurement |
|---|---|---|
| p50 latency | < 5ms | Redis cache hit path |
| p95 latency | < 20ms | Redis cache hit path |
| p99 latency | < 50ms | Including cache miss + PostgreSQL fallback |
| Fallback p99 (Redis unavailable) | < 100ms | PostgreSQL direct query |

**Implementation constraints:**
- Feature gate checks MUST NOT make external API calls (e.g., to Stripe).
- Cache TTL: 60 seconds. Cache invalidated immediately on tier change.
- Redis connection pooling with minimum 10 connections.

### 9.2 Webhook Processing

| Metric | Target |
|---|---|
| Acknowledgment time (HTTP 200) | < 5 seconds from receipt |
| Background processing completion (p99) | < 30 seconds from acknowledgment |
| Burst capacity | 100 events/second with zero drops |
| Event queue backlog tolerance | Up to 10,000 events queued without degradation |

**Implementation constraints:**
- Webhook handler performs only signature verification and idempotency check synchronously.
- All business logic (tier updates, email sending, database writes) is dispatched to the Celery task queue.
- Celery workers auto-scale based on queue depth: minimum 2 workers, maximum 10 workers.

### 9.3 Checkout Session Creation

| Metric | Target |
|---|---|
| API response time (p99) | < 2 seconds |
| Concurrent session creation | 50 simultaneous sessions |

### 9.4 Revenue Dashboard

| Metric | Target |
|---|---|
| Page load time | < 3 seconds for up to 10,000 subscriptions |
| Data freshness | Metrics no more than 15 minutes old |
| Background metrics computation | < 60 seconds per refresh cycle |

### 9.5 Database Query Performance

| Query | Target | Index Used |
|---|---|---|
| Look up subscription by user_id | < 1ms | `idx_subscriptions_user_id` (unique) |
| Look up subscription by stripe_subscription_id | < 1ms | `idx_subscriptions_stripe_subscription_id` |
| List invoices by user_id | < 5ms | FK index on `invoices.user_id` |
| Count usage by user_id + metric_key + period | < 1ms | Unique constraint index |
| Revenue metrics daily aggregation | < 30 seconds | Date index on `revenue_metrics_daily` |

### 9.6 Scalability Targets

The billing system SHALL support up to 10,000 concurrent subscribers without performance degradation.

| Component | Capacity |
|---|---|
| Redis | 100,000+ ops/sec (single-digit ms latency) |
| PostgreSQL | 10,000 subscription records with indexed queries < 5ms |
| Celery workers | Auto-scaling 2-10 workers based on queue depth |
| Webhook processing | 100 events/second sustained |

---

## 10. Testing Specifications

### 10.1 Stripe Test Mode End-to-End Testing (BL-TEST-001)

All development and staging environments SHALL use Stripe test mode with test API keys.

**Test card scenarios:**

| Test Case | Stripe Test Card | Expected Result |
|---|---|---|
| Successful checkout | `4242 4242 4242 4242` | Subscription created, tier updated to selected tier within 10 seconds, welcome email sent, subscription status `active`. |
| Card declined | `4000 0000 0000 0002` | Checkout fails, user shown "Your payment could not be processed. Please try a different payment method.", no subscription created, tier remains `free`. |
| Insufficient funds | `4000 0000 0000 9995` | Payment fails, dunning sequence initiated, `payment_status` set to `past_due`, dunning email 1 sent. |
| 3D Secure required | `4000 0025 0000 3155` | 3DS challenge presented in Stripe Checkout, subscription created on successful 3DS completion. |
| Card expires during subscription | `4000 0000 0000 0341` | Renewal fails, dunning email sent, 7-day grace period starts, `payment_status` set to `past_due`. |
| Disputed payment | `4000 0000 0000 0259` | Dispute webhook received, admin alerted via monitoring, event logged. |

**Test automation:**
- Integration tests use Stripe test mode API directly (not mocks) for checkout, subscription changes, and webhook delivery.
- Webhook tests use Stripe CLI (`stripe trigger {event_type}`) or construct test events programmatically with `stripe.Webhook.construct_event()`.
- CI/CD pipeline runs billing integration tests on every PR that touches files in the billing module.

### 10.2 Webhook Security Testing (BL-TEST-002)

| Test Case | Input | Expected Result |
|---|---|---|
| Valid signature, valid payload | Properly signed event | Event processed successfully, `200 OK`, event recorded in `stripe_events` with status `processed`. |
| Invalid signature | Tampered `Stripe-Signature` header | `400 Bad Request`, event NOT processed, WARNING log entry. |
| Missing signature header | No `Stripe-Signature` header | `400 Bad Request`, event NOT processed. |
| Expired timestamp (> 5 min old) | Valid signature but old timestamp | `400 Bad Request`, event NOT processed. |
| Valid signature, malformed JSON payload | Corrupted body after signing | `400 Bad Request`, error logged. |
| Replay attack (duplicate event ID) | Same valid event delivered twice | Second delivery returns `200 OK`, no duplicate processing, no duplicate emails, no duplicate tier changes. |

### 10.3 Subscription State Machine Testing (BL-TEST-003)

Every valid state transition in the state machine (Section 3.26) SHALL have at least one automated test.

**Required test coverage:**

| Transition | Test Verifies |
|---|---|
| (none) -> active (free) | Registration creates subscription with `tier="free"`, `status="active"` |
| active (free) -> active (paid) | Checkout completion updates tier, sets Stripe IDs, sends email |
| active (free) -> trialing | Trial checkout sets `status="trialing"`, `tier="pro"`, `has_used_trial=true` |
| trialing -> active (paid) | Payment success changes status to `active`, sends conversion email |
| trialing -> past_due | Payment failure starts dunning |
| trialing -> cancelling | Cancel sets `cancel_at_period_end=true` |
| active (paid) -> active (paid) [upgrade] | Tier changes immediately, proration charged |
| active (paid) -> active (paid) [downgrade requested] | `pending_downgrade_tier` set, tier unchanged |
| active (paid) -> past_due | Payment failure updates `payment_status` |
| active (paid) -> cancelling | `cancel_at_period_end=true`, retention offer tracked |
| active (paid) -> paused | Pause dates set, access reverts to Free limits |
| past_due -> active (paid) | Payment recovery resets dunning, restores access |
| past_due -> cancelled | All retries exhausted, tier reverts to Free |
| paused -> active (paid) | Resume restores tier and billing |
| cancelling -> cancelled | Period end reverts to Free |
| cancelling -> active (paid) | Reactivation removes cancel flag |
| cancelled -> active (paid) | New checkout creates new subscription |

**Additional state machine tests:**
- Invalid transition attempt (e.g., `paused` -> `cancelling`) returns `409 Conflict`.
- Concurrent state change attempts (e.g., user cancels while payment is processing) handled correctly without data corruption.
- Upgrade and downgrade within the same billing period calculates prorations correctly.
- Cancel and reactivate multiple times does not corrupt subscription state.
- Subscription expires exactly at billing period boundary (midnight UTC edge case).

### 10.4 Feature Gating Testing (BL-TEST-004)

For each of the 25+ feature keys in the feature flag registry, verify correct access for every tier.

**Test matrix (parameterized):**

For each `(feature_key, tier)` combination:
1. Set user's subscription tier to the test tier.
2. Call `has_feature(user_id, feature_key)`.
3. Assert the result matches the expected value from the registry.
4. For numeric limits: call `get_limit(user_id, feature_key)` and assert the correct limit value.

**Total test cases:** approximately 100 (25 features x 4 tiers).

**Additional feature gating tests:**
- Feature access changes immediately on upgrade (within 5 seconds of webhook processing).
- Feature access changes at period end on downgrade (not before).
- Redis cache invalidation: feature access updates within 60 seconds of tier change even without explicit cache flush.
- Redis unavailable: fallback to PostgreSQL provides correct feature access (with acceptable latency increase).
- Graceful degradation messages contain correct tier names and limits.

### 10.5 Proration Verification (BL-TEST-005)

| Scenario | Expected Proration (approximate) | Tolerance |
|---|---|---|
| Trader Monthly -> Pro Monthly at mid-cycle (day 15 of 30) | Credit: ~$24.50, Charge: ~$49.50, Net: ~$25.00 | +/- $0.01 |
| Pro Monthly -> Team Monthly at day 1 of 30 | Credit: ~$99.00, Charge: ~$199.00, Net: ~$100.00 | +/- $0.01 |
| Pro Monthly -> Team Monthly at day 29 of 30 | Credit: ~$3.30, Charge: ~$6.63, Net: ~$3.33 | +/- $0.01 |
| Monthly -> Annual switch at mid-cycle | Credit remaining monthly, charge full annual | Stripe calculates exact |

Tests verify that Stripe's proration preview (`Invoice.upcoming()`) matches expected values within the specified tolerance.

### 10.6 Dunning Sequence Testing (BL-TEST-006)

| Step | Test Verification |
|---|---|
| First failure | Dunning email 1 sent, `payment_status = "past_due"`, `dunning_step = 1`, user retains full tier access. |
| Second failure (retry) | Dunning email 2 sent, `dunning_step = 2`, user retains full tier access. |
| 6 days after first failure | Dunning email 3 (grace ending) sent, `dunning_step = 3`. |
| 7 days after first failure | Access restricted to Free tier limits, dunning email 4 sent, `dunning_step = 4`. Verify user cannot access Pro/Team features. |
| Payment recovery at day 5 | Card updated, retry succeeds, full access restored within 10 seconds, `dunning_step = 0`, `payment_status = "current"`, recovery email sent. |
| Payment recovery at day 10 (after restriction) | Card updated, retry succeeds, full tier access restored, dunning reset. |
| All retries exhausted | Subscription cancelled by Stripe, tier reverts to `free`, cancellation email sent, data preserved for 90 days. |

### 10.7 Idempotency Testing (BL-TEST-007)

| Test Case | Expected Result |
|---|---|
| Same event delivered twice within 1 second | Second delivery returns `200 OK`, exactly one processing occurs. No duplicate tier changes, no duplicate emails. |
| Same event delivered 10 times rapidly | All return `200 OK`, exactly one processing. `stripe_events` table has one record with `status = "processed"`. |
| Event processing fails on first attempt, delivered again | Second attempt processes successfully, final state is correct. |
| Two different events for same subscription delivered simultaneously | Both processed without conflict, final state reflects both changes in correct order. |

### 10.8 Load Testing (BL-TEST-008)

| Scenario | Target | Pass Criteria |
|---|---|---|
| Feature gate checks under load | 1,000 concurrent authenticated users | p99 latency < 50ms, zero errors |
| Webhook burst processing | 100 events/second sustained for 60 seconds | All events acknowledged within 5s, all processed within 30s, zero drops |
| Concurrent checkout sessions | 50 simultaneous session creations | All sessions created within 2s, no Stripe API errors |
| Revenue dashboard under load | 10,000 subscription records, 10 concurrent admin users | Page load < 3s for all users |
| Usage tracking under contention | 100 users incrementing usage counters simultaneously | All increments recorded correctly (no lost updates), p99 < 10ms |

---

## 11. Migration & Deployment

### 11.1 Phase Mapping

**Phase 1 (Weeks 1-8): Personal Trading System**
- Billing: NOT required.
- All features unlocked (equivalent to Team tier).
- No Stripe integration, no feature gating, no billing database tables.
- **Preparation:** Implement a `can_access(feature)` abstraction that returns `True` for all features. Use dependency injection so the billing integration is a drop-in replacement in Phase 3.

**Phase 2 (Weeks 9-14): Analytics & Journaling**
- Billing: NOT required.
- All features remain unlocked.
- **Preparation:**
  - Implement usage tracking counters (BL-FR-015) — start recording journal entry counts, instrument counts, AI usage even without enforcement.
  - Ensure all AI feature calls include token counting and cost estimation.
  - Finalize the feature flag registry (BL-FR-013) as a configuration document.

**Phase 3 (Weeks 15-22): Multi-Tenant SaaS Launch (Full billing implementation)**

| Week | Deliverables |
|---|---|
| 15 | Stripe product/price setup (BL-FR-001). Create `subscriptions`, `stripe_events`, `invoices`, `usage_tracking`, `ai_usage_log`, `refunds`, `cancellation_events`, `revenue_metrics_daily` tables. Stripe customer creation on user registration. |
| 15-16 | Checkout flow (BL-FR-002). Webhook receiver with signature verification and idempotency (BL-FR-016, BL-FR-017, BL-FR-018). Free tier enforcement (BL-FR-005). |
| 16-17 | Feature gating engine: middleware, feature flag registry, tier checking (BL-FR-012, BL-FR-013, BL-FR-014). Redis caching for tier data. |
| 17-18 | Upgrade and downgrade flows (BL-FR-006, BL-FR-007). Proration handling (BL-FR-011). Customer Portal integration (BL-FR-003). |
| 18-19 | Cancellation flow with retention offers (BL-FR-008). Dunning management (BL-FR-020). Failed payment handling (BL-FR-019). Subscription pause (BL-FR-009). |
| 19-20 | Trial period support (BL-FR-023). Coupon/promotion codes (BL-FR-024). Invoice management (BL-FR-021). Reactivation flow (BL-FR-010). |
| 20-21 | Revenue analytics dashboard (BL-FR-025). AI usage metering (BL-FR-022). Refund processing (BL-FR-026). Admin promotions panel. |
| 21-22 | End-to-end testing (all BL-TEST-xxx). Daily reconciliation jobs (BL-NFR-003). Load testing (BL-TEST-008). Bug fixes and polish. |

**Phase 4 (Months 6-12): Growth & Advanced Features**
- Future billing enhancements (not in this FSD): marketplace revenue sharing (Stripe Connect), seat-based Team pricing, multi-currency, gift subscriptions, affiliate/referral program, custom enterprise tier.

### 11.2 Database Migration Plan

**Migration order (Phase 3, Week 15):**

1. `001_create_subscriptions_table.sql` — Create `subscriptions` table with all columns and indexes.
2. `002_create_stripe_events_table.sql` — Create `stripe_events` table.
3. `003_create_invoices_table.sql` — Create `invoices` table.
4. `004_create_usage_tracking_table.sql` — Create `usage_tracking` table with unique constraint.
5. `005_create_ai_usage_log_table.sql` — Create `ai_usage_log` table.
6. `006_create_refunds_table.sql` — Create `refunds` table.
7. `007_create_cancellation_events_table.sql` — Create `cancellation_events` table.
8. `008_create_revenue_metrics_daily_table.sql` — Create `revenue_metrics_daily` table.
9. `009_seed_free_subscriptions.sql` — For all existing users (from Phase 2), create subscription records with `tier="free"`, `status="active"`.

**Rollback plan:** Each migration has a corresponding down migration that drops the table. Since these are new tables (not modifications to existing tables), rollback is safe and non-destructive.

### 11.3 Stripe Setup Checklist

Before deploying the billing system to any environment:

1. Create Stripe account (or verify existing account).
2. Enable test mode for development/staging.
3. Create 4 products with `tier_level` metadata (via Dashboard or seed script).
4. Create 6 prices (via Dashboard or seed script).
5. Configure Customer Portal with allowed actions (subscription update, cancel, payment method update, invoice history).
6. Configure webhook endpoint URL pointing to `{BASE_URL}/api/webhooks/stripe`.
7. Subscribe to required webhook events (all events listed in BL-FR-016).
8. Retrieve and store webhook signing secret in `STRIPE_WEBHOOK_SECRET`.
9. Create system-generated coupons: `retention_25pct_3mo`, `annual_switch_10pct`, `referral_1mo_free`.
10. Configure Stripe Smart Retries: enable ML-optimized retries, max 4 attempts over 3 weeks, cancel on final failure.
11. Configure Stripe Tax (basic, default settings).
12. Store all environment variables (Section 7.3).
13. Verify end-to-end flow with test card `4242 4242 4242 4242`.

### 11.4 Health Check Endpoint

**Endpoint:** `GET /api/health/billing`

**Response (200 OK when healthy):**
```json
{
  "status": "healthy",
  "components": {
    "database": { "status": "ok", "latency_ms": 2 },
    "redis": { "status": "ok", "latency_ms": 1 },
    "stripe_api": { "status": "ok", "latency_ms": 150 }
  },
  "timestamp": "2026-03-15T10:30:00Z"
}
```

**Response (503 when degraded):**
```json
{
  "status": "degraded",
  "components": {
    "database": { "status": "ok", "latency_ms": 3 },
    "redis": { "status": "ok", "latency_ms": 1 },
    "stripe_api": { "status": "error", "error": "Connection timeout" }
  },
  "timestamp": "2026-03-15T10:30:00Z"
}
```

**Health check logic:**
- Database: execute `SELECT 1` and measure latency.
- Redis: execute `PING` and measure latency.
- Stripe: execute `stripe.Account.retrieve()` (lightweight API call) and measure latency.
- If any component fails: report `"degraded"` with 503 status. Include which component failed.

### 11.5 Scheduled Jobs

| Job | Schedule | Purpose | Failure Behavior |
|---|---|---|---|
| Monthly usage reset | 1st of month, 00:00 UTC | Create new `usage_tracking` records for the new period | Retry 3 times at 5-minute intervals. Alert on failure. |
| Revenue metrics computation | Every 15 minutes | Update `revenue_metrics_daily` table | Retry on next cycle. Dashboard shows stale data (acceptable). |
| Dunning check | Every hour | Send grace-ending and access-restricted emails for past-due subscriptions | Retry on next cycle. Critical alert if missed for > 3 hours. |
| Daily reconciliation | Daily at 03:00 UTC | Compare local subscription state with Stripe API | CRITICAL alert on any discrepancy. Auto-correct local state to match Stripe. |
| Stripe events cleanup | Weekly, Sunday 02:00 UTC | Delete processed events older than 90 days | Retry next week. Non-critical. |
| Usage data archival | Monthly, 1st at 01:00 UTC | Aggregate and archive usage records older than 12 months | Retry next month. Non-critical. |
| Data retention enforcement | Daily at 04:00 UTC | Delete data for cancelled users past 120-day retention window | CRITICAL alert on failure. Manual intervention required. |
| Pause expiration check | Daily at 00:30 UTC | Auto-resume paused subscriptions past their `pause_resumes_at` date | Retry on next cycle. Alert if subscriptions remain paused past expiry for > 24 hours. |

---

## 12. Open Questions & Assumptions

### 12.1 Open Questions

| # | Question | Impact | Status |
|---|---|---|---|
| OQ-1 | Should the retention discount coupon (`retention_25pct_3mo`) be limited to once per user, or can it be offered on subsequent cancellation attempts? | Affects revenue and churn metrics. Current assumption: once per user. | Open |
| OQ-2 | For Team plan downgrades, should we allow the user to choose which broker connections to keep, or automatically keep the most recently used ones? | Affects downgrade UX. Current assumption: automatically keep most recently active. | Open |
| OQ-3 | Should paused subscriptions count toward the annual term (reducing effective subscription duration) or extend the annual term by the pause duration? | Financial impact on annual subscribers. Current assumption per PRD: pause counts toward annual term (no extension). | Closed (per PRD) |
| OQ-4 | What is the exact behavior when a user in dunning (access restricted) attempts to upgrade? Should they be required to resolve the failed payment first? | Edge case in upgrade flow. Current assumption: user must resolve payment before any plan changes. | Open |
| OQ-5 | Should the admin revenue dashboard include real-time metrics or only the pre-computed 15-minute refresh? | Performance vs. freshness tradeoff. Current assumption: 15-minute refresh per PRD. | Closed (per PRD) |
| OQ-6 | How should the system handle a Stripe webhook that references a `customer` ID not found in our database (e.g., manually created in Stripe Dashboard)? | Data integrity. Current assumption: log WARNING and skip processing. | Open |
| OQ-7 | Should the 14-day Pro trial be offered only for Pro, or should there be a trial option for Trader and Team tiers as well? | Marketing strategy. Current assumption per PRD: Pro only. | Closed (per PRD) |

### 12.2 Assumptions

| # | Assumption | Rationale |
|---|---|---|
| A-1 | Stripe is the sole payment processor. No other payment methods (PayPal, crypto, bank transfer) are supported at launch. | Per PRD scope. Simplifies implementation and PCI compliance. |
| A-2 | All prices are in USD. No multi-currency support at launch. | Per PRD scope. Reduces pricing complexity. |
| A-3 | One subscription per user. Users cannot have multiple active subscriptions simultaneously. | Simplifies the data model and feature gating logic. |
| A-4 | Free tier users do not have a Stripe customer object until they initiate a paid action. | Reduces Stripe API calls and customer object clutter. |
| A-5 | The feature flag registry is static (requires deployment to change). It is not editable at runtime. | Prevents accidental tier permission changes. Acceptable for the initial launch. |
| A-6 | Stripe Smart Retries handles payment retry timing. TrendEdge does not implement custom retry logic for failed payments. | Stripe's ML-optimized retries are more effective than custom schedules. |
| A-7 | The daily reconciliation job corrects local state to match Stripe. Stripe is the source of truth for billing state; TrendEdge is the source of truth for feature access. | Clear ownership model prevents conflicting states. |
| A-8 | Email delivery failures do not block subscription state changes. A failed dunning email does not prevent access restriction at the 7-day mark. | Subscription state must be reliable regardless of email delivery. |
| A-9 | The `payment_method_last4` and `payment_method_brand` fields on the subscription record are for display purposes only and may be slightly stale (up to 60 seconds). | Acceptable UX tradeoff for cache simplicity. |
| A-10 | Data deletion at 120 days post-cancellation is a hard delete from the database, not a soft delete. | Per PRD privacy policy. Simplifies data management. |

---

## 13. Appendices

### Appendix A: Stripe API Endpoints Reference

| Stripe Resource | Operations Used | TrendEdge Context |
|---|---|---|
| `stripe.Product.create()` | Seed script only | Create tier product definitions |
| `stripe.Price.create()` | Seed script only | Create monthly/annual price objects |
| `stripe.Customer.create()` | On first paid action | Link TrendEdge user to Stripe customer |
| `stripe.Customer.retrieve()` | Health check, admin lookup | Verify customer exists |
| `stripe.checkout.Session.create()` | Checkout flow | New subscription and trial checkout |
| `stripe.billing_portal.Session.create()` | Portal flow | Self-service billing management |
| `stripe.Subscription.retrieve()` | Reconciliation job | Verify subscription state |
| `stripe.Subscription.modify()` | Upgrade, downgrade, pause, resume, cancel | Subscription lifecycle changes |
| `stripe.Invoice.upcoming()` | Proration preview | Show prorated cost before upgrade |
| `stripe.Invoice.list()` | Invoice history | Retrieve user's invoice list |
| `stripe.Refund.create()` | Admin refund | Process refund for invoice |
| `stripe.Coupon.create()` | Seed script, admin panel | Create discount coupons |
| `stripe.PromotionCode.create()` | Admin panel | Create user-facing promo codes |
| `stripe.Webhook.construct_event()` | Webhook handler | Verify webhook signature |
| `stripe.Account.retrieve()` | Health check | Verify Stripe connectivity |

### Appendix B: Subscription Status Lifecycle Diagram

```
                                    +------------------+
                                    |    (new user)    |
                                    +--------+---------+
                                             |
                                      user_registers
                                             |
                                             v
                                    +------------------+
                          +-------->|  active (free)   |<---------+
                          |         +--------+---------+          |
                          |                  |                    |
                    period_ends      checkout_completed    all_retries_exhausted
                    (from cancelling)  OR trial_started    (from past_due)
                          |                  |                    |
                          |         +--------v---------+          |
                          |         | active (paid) /  |          |
                          |         |    trialing      |          |
                          |         +--+----+----+--+--+          |
                          |            |    |    |  |             |
                          |   payment_ |    | user_ | pause_     |
                          |   failed   |    | cancels| requested |
                          |            v    |    v  |  v          |
                          |     +------+--+ | +--+------+  +-----+----+
                          |     | past_due| | |cancelling|  |  paused  |
                          |     +----+----+ | +----+-----+  +----+-----+
                          |          |      |      |             |
                          |  payment_|      | period_ends   resume/expire
                          |  succeeded      |      |             |
                          |          |      |      v             |
                          |          +------+ +----+------+      |
                          |                   | cancelled |      |
                          |                   +-----+-----+      |
                          |                         |             |
                          +--- user_resubscribes ---+             |
                          +--- user_reactivates (from cancelling)-+
                          +--- resume_requested (from paused) ----+
```

### Appendix C: Glossary

| Term | Definition |
|---|---|
| MRR | Monthly Recurring Revenue. Sum of all active subscription monthly-equivalent fees. Annual subscriptions divided by 12. |
| ARR | Annual Recurring Revenue. MRR multiplied by 12. |
| Churn Rate | Percentage of subscribers who cancel in a given month, relative to total subscribers at the start of that month. |
| Dunning | The process of communicating with customers about failed payments to recover revenue. |
| Proration | Adjusting a charge to account for a partial billing period when a plan changes mid-cycle. |
| Feature Gate | A programmatic check that determines whether a user has access to a specific feature based on their subscription tier. |
| Grace Period | The time between a payment failure and access restriction (default: 7 days), during which the user retains full tier access. |
| SAQ-A | PCI Self-Assessment Questionnaire A, the simplest PCI compliance level for merchants who fully outsource payment processing to a PCI-compliant provider (Stripe). |
| LTV | Lifetime Value. Total revenue expected from a customer over their entire relationship with TrendEdge. |
| CAC | Customer Acquisition Cost. Total marketing and sales spend divided by new customers acquired in the same period. |
| ARPU | Average Revenue Per User. Total monthly revenue divided by total active paid subscribers. |
| Smart Retries | Stripe's ML-optimized payment retry system that determines the optimal time to retry failed payments based on historical success patterns. |
| Tier Level | Integer representation of subscription tiers for programmatic comparison: Free=0, Trader=1, Pro=2, Team=3. |
| Webhook | An HTTP callback sent by Stripe to TrendEdge when a billing event occurs (e.g., payment succeeded, subscription cancelled). |
| Idempotency | The property that processing the same webhook event multiple times produces the same result as processing it once. |

### Appendix D: Changelog

| Date | Version | Author | Changes |
|---|---|---|---|
| 2026-02-11 | 1.0 | Generated by Claude | Initial FSD created from PRD-009 |
