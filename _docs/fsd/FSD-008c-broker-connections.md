# FSD-008c: Broker Connection Management

**TrendEdge -- AI-Powered Futures Trading Platform**

| Field | Value |
|---|---|
| FSD ID | FSD-008c |
| Source | FSD-008 (Authentication & User Management) |
| Title | Broker Connection Management |
| Version | 1.0 |
| Status | Draft |
| Author | Generated by Claude |
| Created | 2026-02-12 |

---

## 1. Introduction

### 1.1 Purpose

This sub-FSD specifies the Broker Connection Management subsystem for TrendEdge. It covers the full lifecycle of broker connections: adding and removing connections, secure credential storage with AES-256-GCM encryption, connection health monitoring, automatic credential refresh, tier-based connection limits, and the broker-specific integration details for IBKR, Tradovate, and Webull.

Broker connections are the bridge between user intent and live/paper market execution. A failure in credential handling or health monitoring can result in missed trades, stale positions, or direct financial loss. Every specification in this document prioritizes security-by-default for credential handling and reliability for connection monitoring.

### 1.2 Scope

This document covers:

- **Broker Connection Data Model**: The `broker_connections` table schema, RLS policies, and indexes.
- **Tier-Based Connection Limits**: Enforcement of subscription-tier limits on the number of broker connections and accounts.
- **Secure Credential Storage (AES-256-GCM)**: Encryption, decryption, and key rotation for broker API credentials using per-connection key derivation.
- **Connection Health Monitoring**: Celery-based periodic health checks, state transitions, and dashboard status display.
- **Add Broker Connection Flow**: Step-by-step user flow for connecting IBKR, Tradovate, or Webull with test-before-save semantics.
- **Broker Credential Refresh/Rotation**: Automatic token refresh for Tradovate, manual re-authorization for Webull, persistent socket handling for IBKR.
- **Broker API Integration Details**: Connection types, health check endpoints, error patterns, and credential formats per broker.
- **API Endpoints**: REST API for broker connection CRUD and testing.
- **UI Specification**: Broker connection settings page layout and interaction patterns.
- **Audit Logging**: Events logged for broker connection add/remove.

### 1.3 Out of Scope

- User registration, login, JWT handling, session management, and password flows. [Cross-reference: FSD-008a Authentication]
- User profile CRUD, trading preferences, notification preferences, and paper trading mode toggle. [Cross-reference: FSD-008b User Profiles & Settings]
- Row Level Security policies (beyond `broker_connections`), RBAC role definitions, team/organization management, and account lifecycle. [Cross-reference: FSD-008d Authorization & Multi-Tenancy]
- Order construction, bracket orders, and order state machine. [Cross-reference: FSD-003d Order Construction & Lifecycle]
- Broker adapter implementations for order execution. [Cross-reference: FSD-003c Broker Adapters]
- Subscription tier definitions, billing, and payment processing. [Cross-reference: FSD-009 Billing & Subscriptions]

### 1.4 Glossary

| Term | Definition |
|---|---|
| DEK | Data Encryption Key: a per-connection key derived from the master key via HKDF-SHA256. |
| HKDF | HMAC-based Key Derivation Function: used to derive unique DEKs from a single master key. |
| AES-256-GCM | Advanced Encryption Standard with 256-bit key in Galois/Counter Mode: provides authenticated encryption. |
| IV | Initialization Vector: a random value used to ensure identical plaintexts encrypt to different ciphertexts. |
| GCM Authentication Tag | A 128-bit tag produced by GCM mode that verifies both confidentiality and integrity of ciphertext. |
| IB Gateway | Interactive Brokers' local gateway application that provides API access to IBKR accounts. |
| Master Key | The `BROKER_ENCRYPTION_MASTER_KEY` stored as an environment variable; never in the database or source code. |
| Key Rotation | The process of re-encrypting all credentials with a new master key version. |
| Health Check | A periodic lightweight API call to verify a broker connection is alive and credentials are valid. |

### 1.5 Dependencies

| Dependency | Type | Description |
|---|---|---|
| PostgreSQL (Supabase) | Hard | Primary data store for `broker_connections` table with RLS. [Cross-reference: FSD-001] |
| Redis (Upstash) | Hard | Rate limiting for broker connection API endpoints. [Cross-reference: FSD-001] |
| Celery Workers | Hard | Background tasks for health checks (every 5 min), token auto-refresh (Tradovate), and encryption key rotation. |
| FastAPI Backend | Hard | Broker credential encryption/decryption, API endpoint handling, tier enforcement. |
| Supabase Auth / JWT | Hard | User identity (JWT Bearer token) required for all broker connection operations. [Cross-reference: FSD-008a] |
| Subscription Tier | Soft | Tier limits enforced at the application layer; tier data from user profile. [Cross-reference: FSD-009] |
| IBKR IB Gateway | External | User-managed local gateway application for IBKR connectivity. |
| Tradovate API | External | REST API with OAuth tokens for Tradovate connectivity. |
| Webull API | External | REST API with OAuth tokens for Webull connectivity. |

### 1.6 Phased Delivery

| Phase | Scope |
|---|---|
| Phase 1 (Weeks 1-2) | IBKR and Tradovate broker connections with encrypted credentials, health monitoring (basic), add/remove flows, tier enforcement. |
| Phase 2 (Weeks 9-14) | Webull support, automatic token refresh (Tradovate), full health monitoring with all state transitions, multi-broker support. |

---

## 2. Functional Specifications

### 2.1 FR-040: Broker Connection Data Model and Tier Limits

**Source:** PRD AU-FR-040 | **Phase:** 1 | **Priority:** P0

#### Description

Broker connections are stored in a dedicated table with encrypted credentials. The number of connections and accounts is limited by the user's subscription tier.

#### Tier Enforcement

| Tier | Max Broker Connections | Max Accounts | Enforced At |
|---|---|---|---|
| Free | 0 (paper only, no broker) | 1 (internal paper) | Application layer (API endpoint) |
| Trader | 1 | 1 | Application layer |
| Pro | 3 | 5 | Application layer |
| Team | Unlimited | 20+ | Application layer |

#### Processing Logic

When a user attempts to add a broker connection:

1. Backend queries `SELECT COUNT(*) FROM broker_connections WHERE user_id = auth.uid() AND status != 'disconnected'`.
2. Backend retrieves the user's `subscription_tier` from the `users` table.
3. If count >= tier limit, return HTTP 403 with the tier-specific rejection message (see below).
4. The response includes an `upgrade_url` field pointing to the billing page.

#### Error Messages by Tier

| Tier | Rejection Message |
|---|---|
| Free | "Your Free plan does not include broker connections. Upgrade to Trader ($49/mo) to connect a broker. [Upgrade] [Cancel]" |
| Trader (at 1) | "Your Trader plan supports up to 1 broker connection. Upgrade to Pro ($99/mo) for up to 3 connections. [Upgrade] [Cancel]" |
| Pro (at 3) | "Your Pro plan supports up to 3 broker connections. Upgrade to Team ($199/mo) for unlimited connections. [Upgrade] [Cancel]" |

#### Business Rules

- BR-040: Tier limits are enforced at the application layer, not via database constraints, to allow for upgrade prompts with specific messaging.
- BR-041: Connections with `status = 'disconnected'` do NOT count against the tier limit. Only `active`, `expired`, and `error` status connections count.
- BR-042: Free-tier users cannot add any broker connections. They are limited to the internal paper trading simulator.

---

### 2.2 FR-041: Secure Credential Storage (AES-256-GCM)

**Source:** PRD AU-FR-041 | **Phase:** 1 | **Priority:** P0

#### Description

All broker API credentials are encrypted at rest using AES-256-GCM with per-connection key derivation. This is the core security mechanism that protects user financial credentials.

#### Processing Logic -- Encryption

1. A 256-bit master encryption key is stored in the `BROKER_ENCRYPTION_MASTER_KEY` environment variable (Railway/Vercel encrypted env vars). This key is NEVER stored in the database or source code.
2. When a user saves a broker connection, the system:
   a. Serializes the broker-specific credentials to a JSON string (UTF-8 encoded).
   b. Derives a unique Data Encryption Key (DEK) using HKDF-SHA256: `DEK = HKDF(master_key, salt=None, info=connection_id.encode(), length=32)`.
   c. Generates a cryptographically random 96-bit (12-byte) IV: `iv = os.urandom(12)`.
   d. Encrypts the JSON plaintext with AES-256-GCM using the DEK and IV. The 128-bit GCM authentication tag is appended to the ciphertext automatically.
   e. Stores in the database: `credentials_encrypted` (ciphertext + tag), `credentials_iv` (IV), `credentials_key_id` (version identifier of the master key, e.g., "v1").
3. Decrypted credentials are NEVER logged, NEVER returned in API responses, and NEVER cached (disk or Redis).

#### Processing Logic -- Decryption

1. When the system needs broker credentials (e.g., for trade execution or health check):
   a. Read `credentials_encrypted`, `credentials_iv`, and `credentials_key_id` from the database.
   b. Look up the master key version from `credentials_key_id`.
   c. Re-derive the DEK using HKDF with the same parameters (connection_id as info).
   d. Decrypt using AES-256-GCM. If the authentication tag does not match (tampering detected), raise `InvalidTag` exception.
   e. Parse the JSON plaintext into a Python dictionary.
   f. Use the credentials for the broker API call.
   g. Securely overwrite the plaintext in memory after use (where supported by the runtime).

#### Processing Logic -- Key Rotation

1. When the master key is rotated (new `BROKER_ENCRYPTION_MASTER_KEY` value deployed):
   a. Both the old key (identified by `credentials_key_id = "v1"`) and new key (`"v2"`) are available during the rotation window.
   b. A Celery background task iterates through all `broker_connections` rows (using service role to bypass RLS).
   c. For each row: decrypt with the old key, re-encrypt with the new key, update `credentials_key_id` to the new version.
   d. Rotation window maximum: 24 hours.
   e. After all rows are re-encrypted, the old key is removed from environment variables.

#### Credential Formats Per Broker

**IBKR:**
```json
{
  "host": "127.0.0.1",
  "port": 4002,
  "client_id": 1,
  "account": "DU1234567",
  "gateway_type": "paper|live"
}
```

**Tradovate:**
```json
{
  "username": "...",
  "password": "...",
  "app_id": "...",
  "app_version": "...",
  "cid": "...",
  "sec": "...",
  "environment": "demo|live"
}
```

**Webull:**
```json
{
  "app_key": "...",
  "app_secret": "...",
  "access_token": "...",
  "refresh_token": "...",
  "device_id": "...",
  "account_id": "..."
}
```

#### Credential Lifecycle Security

| Stage | Security Measure |
|---|---|
| Input | Credentials entered over HTTPS. TLS 1.3 enforced. Password fields use `type="password"`. |
| Transit | Encrypted via HTTPS. NEVER transmitted in query parameters, only in POST request body. |
| Processing | Decrypted in memory only when needed for broker API calls. |
| Storage | AES-256-GCM encrypted in PostgreSQL `bytea` column. |
| Display | NEVER displayed in API responses, UI, or logs. Masked format only: `****...a1b2`. |
| Deletion | Database record hard-deleted on account deletion. |
| Logging | Credentials are NEVER logged at any log level. Log sanitization middleware strips detected credential patterns. |

#### Encryption Specification Summary

| Property | Specification |
|---|---|
| Algorithm | AES-256-GCM (Galois/Counter Mode) |
| Key size | 256 bits (32 bytes) |
| IV size | 96 bits (12 bytes), cryptographically random per encryption |
| Authentication tag | 128 bits (16 bytes), appended to ciphertext by GCM |
| Master key storage | `BROKER_ENCRYPTION_MASTER_KEY` environment variable (Railway/Vercel encrypted) |
| Key derivation | HKDF-SHA256 with `connection_id` as info parameter; no salt |
| Key rotation window | Maximum 24 hours; both old and new keys valid during rotation |

#### Error Handling

| Error Condition | System Action |
|---|---|
| GCM authentication tag mismatch (tampered data) | Log critical security event, do NOT return credentials, notify admin, mark connection as `error` with `last_error = "Credential integrity check failed"` |
| Master key not found in environment | Application fails to start. Log: "CRITICAL: BROKER_ENCRYPTION_MASTER_KEY not set." |
| Key version mismatch (`credentials_key_id` not found) | Attempt all known key versions. If none decrypt successfully, mark connection as `error`, notify user: "Your broker connection credentials need to be re-entered." |

---

### 2.3 FR-042: Connection Status Monitoring

**Source:** PRD AU-FR-042 | **Phase:** 1 (basic) / 2 (full) | **Priority:** P1

#### Description

The system monitors broker connection health continuously via background tasks and displays status with color-coded indicators.

#### Processing Logic

1. A Celery periodic task runs every 5 minutes for each broker connection where `status IN ('active', 'expired')`.
2. The health check decrypts the broker credentials (FR-041) and attempts a lightweight API call:
   - **IBKR:** Request account summary via IB Gateway API.
   - **Tradovate:** `GET /account/list` endpoint.
   - **Webull:** `GET /account/profile` endpoint.
3. State transitions:

| Current State | Event | New State | System Action |
|---|---|---|---|
| active | Health check succeeds | active | Update `last_connected_at = NOW()` |
| active | Health check fails (1st failure) | active | Log warning, schedule retry in 1 minute |
| active | Health check fails (3 consecutive) | error | Set `last_error` with error details, send notification to user: "Your [broker] connection has encountered an error: [error]. Please check your connection." |
| active | Token expired (Tradovate/Webull) | expired | Attempt automatic token refresh (FR-044) |
| expired | Auto-refresh succeeds | active | Update encrypted credentials with new token, clear `last_error`, update `last_connected_at` |
| expired | Auto-refresh fails (3 attempts) | expired | Notify user: "Your [broker] connection requires re-authorization. Please update your credentials." |
| error | User re-authorizes (submits new credentials) | active | Re-encrypt new credentials, clear `last_error`, update `last_connected_at` |
| any | User clicks "Disconnect" | disconnected | Credentials retained but connection marked inactive. No health checks run. |
| disconnected | User clicks "Reconnect" | active | Resume health checks. |

#### Dashboard Status Display

| Status | Visual Indicator | Text |
|---|---|---|
| active | Green circle (pulsing) | "Connected" |
| expired | Yellow circle | "Token expired -- re-authorize" (with "Re-authorize" button) |
| error | Red circle | "Connection error: [last_error]" (with "Retry" and "Edit" buttons) |
| disconnected | Gray circle | "Disconnected" (with "Reconnect" button) |

#### Edge Cases

- **All health checks fail simultaneously:** Celery processes health checks in parallel per connection. If the Redis broker itself is down, Celery retries the task. Health check failures are per-connection, not global.
- **Health check runs during key rotation:** The decryption step in the health check attempts the `credentials_key_id` version first, then falls back to other known versions. This ensures health checks continue during the rotation window.
- **Connection in `error` state receives health check:** Connections in `error` state are NOT health-checked. Only `active` and `expired` connections are checked. The user must manually re-authorize to exit `error` state.
- **User disconnects during active health check:** The disconnect sets status to `disconnected`. If a health check is mid-flight, its result is discarded (status check before writing prevents overwriting `disconnected`).

---

### 2.4 FR-043: Add Broker Connection Flow

**Source:** PRD AU-FR-043 | **Phase:** 1 | **Priority:** P0

#### Description

Users can add new broker connections by selecting a broker type, entering credentials, testing the connection, and saving.

#### Prerequisites

- User must be authenticated (valid JWT). [Cross-reference: FSD-008a]
- User must have a verified email. Unverified users receive: "Please verify your email first." [Cross-reference: FSD-008a]
- User must not be at their tier connection limit (FR-040).

#### Processing Logic

1. User navigates to `/settings/brokers` and clicks "Add Broker Connection."
2. System checks tier limits (FR-040). If at limit, display the tier-specific upgrade prompt and stop.
3. User selects broker type from a card-based selection: Interactive Brokers, Tradovate, Webull.
4. System displays the broker-specific connection form:

**IBKR Form:**

| Field | Type | Validation | Default | Help Text |
|---|---|---|---|---|
| Display name | string | 3-50 chars | "My IBKR Account" | "A friendly name for this connection" |
| Gateway host | string | Valid IP or hostname | "127.0.0.1" | "IP address of your IB Gateway instance" |
| Gateway port | integer | 1024-65535 | 4002 (paper) / 4001 (live) | "Port configured in IB Gateway" |
| Client ID | integer | 1-999 | 1 | "Must be unique per Gateway connection" |
| Account number | string | Matches `^[A-Z]{1,2}\d{5,10}$` | "" | "Your IBKR account number (e.g., DU1234567)" |
| Account type | radio | "Paper" or "Live" | "Paper" | Sets `is_paper` flag |

**Tradovate Form:**

| Field | Type | Validation | Default | Help Text |
|---|---|---|---|---|
| Display name | string | 3-50 chars | "My Tradovate Account" | "A friendly name for this connection" |
| Username | string | Non-empty | "" | "Your Tradovate username" |
| Password | password | Non-empty | "" | "Your Tradovate password" |
| App ID | string | Non-empty | "" | "From Tradovate API dashboard" |
| App Version | string | Non-empty | "" | "From Tradovate API dashboard" |
| CID | string | Non-empty | "" | "Customer ID from Tradovate" |
| Secret | password | Non-empty | "" | "API secret from Tradovate" |
| Environment | radio | "Demo" or "Live" | "Demo" | Sets `is_paper` flag |

**Webull Form:**

| Field | Type | Validation | Default | Help Text |
|---|---|---|---|---|
| Display name | string | 3-50 chars | "My Webull Account" | "A friendly name for this connection" |
| App Key | string | Non-empty | "" | "From Webull developer portal" |
| App Secret | password | Non-empty | "" | "From Webull developer portal" |
| Device ID | string | Auto-generated UUID | generated | "Auto-generated unique device identifier" |

5. User fills in the form and clicks "Test Connection."
6. Backend receives the credentials, does NOT encrypt yet. It attempts a test API call to the broker:
   - **IBKR:** Connect to Gateway at `host:port`, request account info.
   - **Tradovate:** Authenticate with username/password/app credentials, request account list.
   - **Webull:** Authenticate with app key/secret, request account profile.
7. **Test success:** Display: "Connection successful! Account: [account_id], Balance: $[balance]." The "Save" button becomes enabled.
8. **Test failure:** Display broker-specific error:
   - IBKR: "IB Gateway is not running or not reachable at [host]:[port]."
   - Tradovate: "Invalid username or password."
   - Webull: "App secret has expired. Generate a new one in the Webull developer portal."
9. On "Save," backend encrypts credentials (FR-041) and stores the connection record.
10. User can optionally edit the display name.

#### Business Rules

- BR-036: A connection MUST be tested successfully before it can be saved.
- BR-037: Credentials are NOT persisted until the user explicitly clicks "Save" after a successful test.
- BR-038: The test connection attempt has a 30-second timeout.
- BR-039: Display name must be unique per user (case-insensitive). Error: "You already have a connection named '[name]'. Please choose a different name."

#### Error Handling

| Error Condition | User-Facing Message | System Action |
|---|---|---|
| Tier limit reached | Tier-specific upgrade message (see FR-040) | HTTP 403 returned; no connection created |
| Email not verified | "Please verify your email first." | HTTP 403 returned |
| Test connection timeout (>30s) | "Connection test timed out. Please check your broker is running and try again." | Log timeout event |
| IBKR Gateway not reachable | "IB Gateway is not running or not reachable at [host]:[port]." | Log connection error |
| IBKR Client ID conflict | "Client ID [X] is already in use. Choose a different client ID." | Log conflict |
| Tradovate invalid credentials | "Invalid username or password." | Log failed auth (no credentials logged) |
| Tradovate API rate limit | "Tradovate API is temporarily unavailable. Please try again in a few minutes." | Exponential backoff, max 3 retries |
| Webull app secret expired | "App secret has expired. Generate a new one in the Webull developer portal." | Log expired secret |
| Webull invalid app key | "Invalid app key. Please verify your Webull API credentials." | Log invalid key |
| Duplicate display name | "You already have a connection named '[name]'. Please choose a different name." | HTTP 409 returned |
| Network error during test | "Unable to connect to [broker]. Please check your network and try again." | Log network error |

#### Edge Cases

- **User closes browser during test:** The test request is abandoned. No credentials are persisted (BR-037).
- **Test succeeds but save fails (DB error):** Credentials are not stored. User sees "Something went wrong. Please try again." and can retry.
- **Concurrent add requests from same user:** The tier limit check uses a database query, so a race condition is possible but unlikely. If both pass the check, the second insert succeeds only if total count remains within limit (application-layer post-insert check).
- **IBKR Gateway restarts between test and save:** The save stores the last-tested credentials. The first health check (within 5 minutes) detects the issue and updates status accordingly.

---

### 2.5 FR-044: Broker Credential Refresh/Rotation

**Source:** PRD AU-FR-044 | **Phase:** 2 | **Priority:** P0

#### Description

The system handles broker credential expiry and rotation automatically where the broker API supports it.

#### Processing Logic

**Tradovate Token Refresh:**
1. Tradovate access tokens expire every 60 minutes.
2. A Celery task checks all active Tradovate connections every 55 minutes (5 minutes before expected expiry).
3. The task decrypts the stored credentials, uses the refresh token to request a new access token from Tradovate API.
4. On success: re-encrypt the updated credentials (with new access token) and update `last_connected_at`.
5. On failure: retry 2 more times at 1-minute intervals.
6. After 3 failures: set status to `expired`, notify user: "Your Tradovate connection requires re-authorization."

**Webull Token Refresh:**
1. Webull app secrets expire every 24 hours to 7 days (configurable in Webull portal).
2. The system CANNOT auto-refresh Webull app secrets.
3. When a Webull health check detects an expired secret (API returns 401), status transitions to `expired`.
4. User notification: "Your Webull connection has expired. Please generate a new app secret in the Webull developer portal and update your connection."

**IBKR:**
1. IBKR uses a persistent socket connection via IB Gateway. No token rotation is required.
2. If IB Gateway restarts or the socket disconnects, the system automatically reconnects on the next health check cycle (within 5 minutes).

#### Edge Cases

- **Tradovate refresh token also expired:** If the refresh token itself is expired (rare, typically valid for 7+ days), the system cannot auto-refresh. Status transitions to `expired` and the user must re-authorize.
- **Concurrent refresh attempts:** The Celery task uses a per-connection lock (Redis) to prevent duplicate refresh attempts.
- **Refresh succeeds but re-encryption fails:** The new token is in memory but not persisted. The system retries the encryption/storage step. If it fails 3 times, status transitions to `expired` (the old encrypted credentials remain in the database; the fresh token is lost).

---

## 3. Data Specifications

### 3.1 Broker Connections Table

**Table:** `public.broker_connections`

| Column | Type | Constraints | Default | Description |
|---|---|---|---|---|
| id | UUID | PK | gen_random_uuid() | Connection identifier |
| user_id | UUID | NOT NULL, FK -> users(id) ON DELETE CASCADE, INDEX | N/A | Owner |
| broker_type | TEXT | NOT NULL, CHECK IN ('ibkr','tradovate','webull','rithmic') | N/A | Broker type |
| display_name | TEXT | NOT NULL | N/A | User-defined name |
| credentials_encrypted | BYTEA | NOT NULL | N/A | AES-256-GCM encrypted credentials |
| credentials_iv | BYTEA | NOT NULL | N/A | Initialization vector |
| credentials_key_id | TEXT | NOT NULL | N/A | Master key version reference |
| status | TEXT | NOT NULL, CHECK IN ('active','expired','error','disconnected') | 'disconnected' | Connection health status |
| last_connected_at | TIMESTAMPTZ | nullable | null | Last successful health check |
| last_error | TEXT | nullable | null | Most recent error message |
| account_id | TEXT | nullable | null | Broker-specific account identifier |
| is_paper | BOOLEAN | NOT NULL | true | Paper vs. live account |
| created_at | TIMESTAMPTZ | NOT NULL | NOW() | Creation timestamp |
| updated_at | TIMESTAMPTZ | NOT NULL | NOW() | Last update timestamp |

### 3.2 Row Level Security

RLS is enabled and forced on `broker_connections`. Every operation is scoped to the authenticated user.

| Operation | Policy |
|---|---|
| SELECT | `user_id = auth.uid()` |
| INSERT | `user_id = auth.uid()` |
| UPDATE | `user_id = auth.uid()` (both USING and WITH CHECK) |
| DELETE | `user_id = auth.uid()` |

```sql
ALTER TABLE public.broker_connections ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.broker_connections FORCE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own broker_connections"
  ON public.broker_connections FOR SELECT
  USING (user_id = auth.uid());

CREATE POLICY "Users can insert own broker_connections"
  ON public.broker_connections FOR INSERT
  WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own broker_connections"
  ON public.broker_connections FOR UPDATE
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can delete own broker_connections"
  ON public.broker_connections FOR DELETE
  USING (user_id = auth.uid());
```

**Service role bypass:** Celery workers use the Supabase service role key to perform cross-user operations (health checks, key rotation). Service role usage is restricted to: broker health checks across all connections, encryption key rotation, and data export generation. [Cross-reference: FSD-008d for full service role restrictions]

### 3.3 Database Indexes

```sql
CREATE INDEX idx_broker_connections_user_id ON public.broker_connections(user_id);
CREATE INDEX idx_broker_connections_status ON public.broker_connections(status);
```

### 3.4 Audit Log Events

The following broker-related events are logged in the `audit_logs` table (append-only, insert via service role):

| Event Type | Data Captured |
|---|---|
| `broker_connection_added` | user_id, broker_type, is_paper, timestamp |
| `broker_connection_removed` | user_id, broker_type, connection_id, timestamp |

---

## 4. API Endpoints

All broker connection endpoints require authentication via Bearer JWT in the Authorization header.

### 4.1 GET /api/broker-connections

**Phase:** 1 | **Auth:** Bearer JWT

Lists all broker connections for the authenticated user.

**Response 200:**
```json
{
  "connections": [
    {
      "id": "uuid",
      "broker_type": "ibkr",
      "display_name": "My IBKR Paper",
      "status": "active",
      "last_connected_at": "2026-02-11T12:00:00Z",
      "last_error": null,
      "account_id": "DU1234567",
      "is_paper": true,
      "created_at": "2026-02-01T10:00:00Z"
    }
  ]
}
```

**Security:** `credentials_encrypted`, `credentials_iv`, and `credentials_key_id` are NEVER included in API responses.

### 4.2 POST /api/broker-connections

**Phase:** 1 | **Auth:** Bearer JWT

Creates a new broker connection. Tier limit and email verification are checked before creation.

**Request:**
```json
{
  "broker_type": "ibkr",
  "display_name": "My IBKR Paper",
  "credentials": {
    "host": "127.0.0.1",
    "port": 4002,
    "client_id": 1,
    "account": "DU1234567",
    "gateway_type": "paper"
  },
  "is_paper": true
}
```

**Response 201:** Connection object (without credentials).

**Response 403:** Tier limit reached (see FR-040 for messages).

**Response 403 (unverified):** `{"error": "email_not_verified", "message": "Please verify your email first."}`

### 4.3 POST /api/broker-connections/:id/test

**Phase:** 1 | **Auth:** Bearer JWT

Tests an existing broker connection by decrypting credentials and making a lightweight API call.

**Response 200 (success):**
```json
{
  "success": true,
  "account_id": "DU1234567",
  "balance": 100000.00,
  "currency": "USD"
}
```

**Response 200 (failure):**
```json
{
  "success": false,
  "error": "IB Gateway is not running or not reachable at 127.0.0.1:4002."
}
```

### 4.4 PATCH /api/broker-connections/:id

**Phase:** 1 | **Auth:** Bearer JWT

Updates display_name, credentials, or status. Credentials are re-encrypted on update.

### 4.5 DELETE /api/broker-connections/:id

**Phase:** 1 | **Auth:** Bearer JWT

Removes a broker connection. The database record is hard-deleted.

**Response 200:** `{"message": "Broker connection removed."}`

---

## 5. Broker API Integration Details

### 5.1 Interactive Brokers (IBKR)

| Property | Specification |
|---|---|
| Connection type | Persistent TCP socket via IB Gateway |
| Health check | Request account summary (lightweight) |
| Credential format | Host, port, client ID, account number |
| Token management | No tokens; socket-based connection |

**Error patterns:**
- Gateway not running: "IB Gateway is not running or not reachable at [host]:[port]."
- Gateway restart: Auto-reconnect on next health check cycle (within 5 min).
- Client ID conflict: "Client ID [X] is already in use. Choose a different client ID."

**Assumptions:**
- A-003: IB Gateway is installed and running on a user-accessible server.
- A-008: Users run IB Gateway locally (127.0.0.1) rather than on a remote server. Remote IB Gateway adds network latency and firewall complexity.

### 5.2 Tradovate

| Property | Specification |
|---|---|
| Connection type | REST API with OAuth tokens |
| Health check | `GET /account/list` |
| Token refresh | Every 55 minutes (before 60-minute expiry) |

**Error patterns:**
- Invalid credentials: "Invalid username or password."
- Token expired (auto-refresh failed): Connection status -> `expired`
- API rate limit: Exponential backoff, max 3 retries

**Assumptions:**
- A-004: Tradovate API rate limits are sufficient for health checks every 5 minutes.

### 5.3 Webull

| Property | Specification |
|---|---|
| Connection type | REST API with OAuth tokens |
| Health check | `GET /account/profile` |
| Token refresh | NOT supported -- manual re-authorization required |

**Error patterns:**
- App secret expired: "App secret has expired. Generate a new one in the Webull developer portal."
- Invalid app key: "Invalid app key. Please verify your Webull API credentials."

**Assumptions:**
- A-005: Webull API requires manual re-authorization (no auto-refresh). Users must manually re-enter credentials when secrets expire.

---

## 6. UI Specification

### 6.1 Broker Connection Settings (`/settings/brokers`)

**Layout:** Card-based list of existing connections. Each card shows:
- Broker logo (IBKR, Tradovate, Webull)
- Display name
- Status indicator (colored dot + text per FR-042)
- Account ID (if connected)
- Paper/Live badge
- Action buttons: "Test", "Edit", "Disconnect"/"Reconnect"

**"Add Broker Connection" button** at top of list. Disabled if at tier limit, with upgrade tooltip.

### 6.2 Add Broker Connection Flow

1. User clicks "Add Broker Connection."
2. If at tier limit, a modal displays the tier-specific upgrade message with [Upgrade] and [Cancel] buttons.
3. If within limits, a card-based broker type selector is displayed (IBKR, Tradovate, Webull).
4. On broker selection, the broker-specific form appears (see FR-043 for field details).
5. "Test Connection" button triggers the test; a spinner displays during the test (30-second timeout).
6. On success: green success message with account details, "Save" button becomes enabled.
7. On failure: red error message with broker-specific guidance.
8. On save: success toast notification, redirect back to the connections list.

### 6.3 Onboarding Wizard -- Broker Step (Phase 3)

During the onboarding wizard, Step 3 presents broker connection:
- Header: "Connect your broker to start trading."
- Options: "Connect Interactive Brokers", "Connect Tradovate", "Connect Webull", "Start with paper trading only."
- Selecting "Paper trading only" skips to Step 4.
- Selecting a broker opens the connection flow (FR-043) inline within the wizard.

### 6.4 Paper Trading Mode Interaction

Switching from paper to live trading requires at least one active broker connection with `is_paper = false`:
- BR-031: Switching from paper to live requires at least one active broker connection with `is_paper = false`.
- BR-032: If no live broker connection exists when toggling to live, display: "You need an active live broker connection to trade live. [Connect broker] [Stay in paper]"

---

## 7. Environment Variables

| Variable | Description | Required | Phase |
|---|---|---|---|
| `BROKER_ENCRYPTION_MASTER_KEY` | AES-256 master key for broker credential encryption. Generate: `python -c "import secrets; print(secrets.token_hex(32))"` | Yes | 1 |

---

## 8. Connection State Diagram

```
    +---------------+
    | Disconnected  |<----- User disconnects
    +-------+-------+
            |
     User connects
            |
    +-------v-------+
    |    Active      |<----- Auto-refresh succeeds
    +-------+--------+      Health check OK
            |
    +-------+--------+--------+
    |                |        |
 3 failures    Token expires  User disconnects
    |                |        |
+---v---+     +------v---+   |
| Error |     | Expired  |   |
+---+---+     +------+---+   |
    |                |        |
 User re-auth   Auto-refresh  |
    |           fails 3x      |
    |                |         |
    +---> Active <---+    Disconnected
```

**State definitions:**
- **disconnected:** Initial state. Credentials may or may not be stored. No health checks run.
- **active:** Connection tested and alive. Health checks run every 5 minutes.
- **expired:** Token has expired. Auto-refresh is being attempted (Tradovate) or manual re-authorization is required (Webull).
- **error:** 3 consecutive health check failures. User must re-authorize to recover.

---

## 9. Test Scenarios

### 9.1 Credential Encryption Tests

| Test ID | Test Case | Method | Expected Outcome | Type |
|---|---|---|---|---|
| T-100 | Credentials encrypted at rest | Direct DB query on broker_connections | `credentials_encrypted` column is binary, not readable JSON | Automated |
| T-101 | Credentials decrypt correctly | Decrypt via application layer | Original credential JSON restored exactly | Automated |
| T-102 | Key rotation | Rotate master key, decrypt with new key | All credentials re-encrypted, old key no longer needed | Automated |
| T-103 | Tampered ciphertext | Modify 1 byte of encrypted data | Decryption fails with GCM authentication error (InvalidTag) | Automated |
| T-104 | Missing IV | Remove IV from record | Decryption fails gracefully with clear error | Automated |
| T-105 | API response check | GET /api/broker-connections | Response NEVER contains credentials_encrypted, credentials_iv, or decrypted credentials | Automated |

### 9.2 Broker Connection Flow Tests

| Test ID | Test Case | Setup | Expected Outcome | Type |
|---|---|---|---|---|
| T-110 | Add IBKR connection (happy path) | Valid IBKR credentials, IB Gateway running | Connection tested, saved, status = active | E2E |
| T-111 | Add Tradovate connection (happy path) | Valid Tradovate credentials | Connection tested, saved, status = active | E2E |
| T-112 | Add connection at tier limit | User at max broker connections for tier | HTTP 403 with tier-specific upgrade message | Automated |
| T-113 | Add connection (Free tier) | User on Free plan | HTTP 403 with Free tier upgrade message | Automated |
| T-114 | Add connection (unverified email) | User with unverified email | HTTP 403 with "Please verify your email first." | Automated |
| T-115 | Test connection (IBKR gateway down) | IBKR Gateway not running | Test returns failure with "IB Gateway is not running" error | Automated |
| T-116 | Test connection timeout | Broker unreachable, 30s passes | Test returns timeout error | Automated |
| T-117 | Duplicate display name | User already has connection with same name | HTTP 409 with duplicate name error | Automated |
| T-118 | Delete broker connection | Valid connection ID | Connection removed, HTTP 200 | Automated |

### 9.3 Health Monitoring Tests

| Test ID | Test Case | Setup | Expected Outcome | Type |
|---|---|---|---|---|
| T-120 | Health check succeeds | Active connection, broker responding | `last_connected_at` updated, status stays active | Automated |
| T-121 | Health check fails 3x | Active connection, broker unreachable 3 times | Status transitions to error, user notified | Automated |
| T-122 | Token auto-refresh (Tradovate) | Active Tradovate connection, token near expiry | New token encrypted and stored, status stays active | Automated |
| T-123 | Token refresh fails (Tradovate) | Active Tradovate connection, refresh token invalid | Status transitions to expired, user notified | Automated |
| T-124 | Webull secret expired | Active Webull connection, API returns 401 | Status transitions to expired, user notified | Automated |
| T-125 | User re-authorizes from error | Connection in error state, user submits new credentials | Status transitions to active, credentials re-encrypted | E2E |

### 9.4 Security Tests

| Test ID | Test Case | Method | Expected Outcome | Type |
|---|---|---|---|---|
| T-128 | Credential Exposure | Search logs, errors, API responses | No credentials, tokens, or secrets in any output | Automated |
| T-130 | IDOR on broker connections | Access connection by guessing UUID | RLS + ownership check prevents access | Automated |
| T-131 | Cross-user connection access | Authenticated as User A, request User B's connection | HTTP 404 (RLS hides the row entirely) | Automated |

### 9.5 Data Integrity Checks

| Check | Query | Expected |
|---|---|---|
| All broker credentials are encrypted | `SELECT COUNT(*) FROM broker_connections WHERE credentials_encrypted IS NULL` | 0 |

---

## 10. Migration & Deployment

### 10.1 Phase 1 Database Migration

```sql
-- Create broker_connections table
CREATE TABLE public.broker_connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  broker_type TEXT NOT NULL CHECK (broker_type IN ('ibkr','tradovate','webull','rithmic')),
  display_name TEXT NOT NULL,
  credentials_encrypted BYTEA NOT NULL,
  credentials_iv BYTEA NOT NULL,
  credentials_key_id TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'disconnected' CHECK (status IN ('active','expired','error','disconnected')),
  last_connected_at TIMESTAMPTZ,
  last_error TEXT,
  account_id TEXT,
  is_paper BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Enable and force RLS
ALTER TABLE public.broker_connections ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.broker_connections FORCE ROW LEVEL SECURITY;

-- RLS policies
CREATE POLICY "Users can view own broker_connections"
  ON public.broker_connections FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "Users can insert own broker_connections"
  ON public.broker_connections FOR INSERT WITH CHECK (user_id = auth.uid());
CREATE POLICY "Users can update own broker_connections"
  ON public.broker_connections FOR UPDATE USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());
CREATE POLICY "Users can delete own broker_connections"
  ON public.broker_connections FOR DELETE USING (user_id = auth.uid());

-- Indexes
CREATE INDEX idx_broker_connections_user_id ON public.broker_connections(user_id);
CREATE INDEX idx_broker_connections_status ON public.broker_connections(status);
```

### 10.2 Environment Variable Setup

```bash
# Generate the master encryption key (run once, store securely)
python -c "import secrets; print(secrets.token_hex(32))"
# Set as BROKER_ENCRYPTION_MASTER_KEY in Railway/Vercel encrypted env vars
```

### 10.3 Phase 1 Verification Checklist

- Add a broker connection -> verify credentials are encrypted in DB.
- Verify API responses never contain encrypted credentials.
- Verify RLS prevents cross-user access to broker connections.
- Verify tier limits are enforced (Free user cannot add connections).
- Verify health check runs and updates `last_connected_at`.

### 10.4 Rollback Procedures

| Component | Rollback Method |
|---|---|
| Database migration | `alembic downgrade -1` (drops `broker_connections` table) |
| API code deployment | Railway/Vercel instant rollback to previous deployment |
| Encryption key rotation | Old key retained during rotation window; abort rotation by keeping old key active |

---

## 11. Open Questions

| ID | Question | Impact | Decision Needed By |
|---|---|---|---|
| Q-006 | Should the Rithmic broker type be fully supported or placeholder only? | Listed in CHECK constraint but no connection flow documented. | Phase 1 planning |
| Q-009 | Should health check frequency be configurable per broker or per user? | Fixed 5-minute interval may be too frequent for some brokers (rate limits) or too infrequent for latency-sensitive users. | Phase 2 planning |
| Q-010 | Should disconnected connections retain encrypted credentials indefinitely? | Currently credentials are retained on disconnect. May want a cleanup policy for long-disconnected connections. | Phase 2 planning |

---

## 12. Cross-References

| Document | Relationship |
|---|---|
| [FSD-008a: Authentication](./FSD-008a-authentication.md) | JWT authentication required for all broker endpoints; email verification prerequisite for adding connections. |
| [FSD-008b: User Profiles & Settings](./FSD-008b-user-profiles.md) | Paper trading mode toggle depends on active broker connections; subscription tier stored in user profile. |
| [FSD-008d: Authorization & Multi-Tenancy](./FSD-008d-authorization-multitenancy.md) | RLS policies, RBAC permission matrix (broker connections CRUD by role), service role restrictions. |
| [FSD-003c: Broker Adapters](./FSD-003c-broker-adapters.md) | Broker adapter implementations for order execution consume credentials managed by this FSD. |
| [FSD-003: Trade Execution](./FSD-003-trade-execution.md) | Order routing depends on active broker connections and decrypted credentials from this FSD. |
| [FSD-009: Billing & Subscriptions](./FSD-009-billing-subscriptions.md) | Subscription tier determines broker connection limits enforced by this FSD. |

---

*This document is FSD-008c of the TrendEdge platform. It specifies the complete broker connection management subsystem including secure credential storage, connection health monitoring, and broker-specific integration details.*
