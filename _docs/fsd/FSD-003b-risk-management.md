# FSD-003b: Risk Management Engine

**TrendEdge -- AI-Powered Futures Trading Platform**

| Field | Value |
|---|---|
| FSD ID | FSD-003b |
| Source | FSD-003 (Trade Execution) |
| Title | Risk Management Engine |
| Version | 1.0 |
| Status | Draft |
| Author | Generated by Claude |
| Created | 2026-02-12 |

---

## 1. Introduction

### 1.1 Purpose

This sub-FSD specifies the Risk Management Engine for the TrendEdge execution pipeline. It covers all pre-trade risk checks, configurable risk parameters, the circuit breaker mechanism for broker resilience, manual override capabilities, and the audit infrastructure that records every risk decision.

### 1.2 Scope

This document covers:

- **Pre-Trade Risk Checks**: Maximum position size, daily loss limit, maximum concurrent positions, minimum risk-reward ratio, correlation limits, maximum single-trade risk, and trading hours enforcement.
- **Risk Check Audit Trail**: Immutable logging of every risk check result (PASS, FAIL, WARN).
- **Risk Parameter Configuration**: User-configurable risk settings with validation, defaults, and change tracking.
- **Circuit Breaker**: State machine for halting order submission after consecutive broker failures, with auto-reset and manual reset.
- **Manual Overrides**: Order cancellation, order modification, position close, and emergency flatten-all.
- **Quantity Calculation**: Risk-based position sizing using fixed-risk-per-trade divided by per-contract risk.

### 1.3 Out of Scope

- Signal ingestion, normalization, authentication, instrument validation, price validation, enrichment, and deduplication. [Cross-reference: FSD-003a Signal Ingestion & Normalization]
- Broker adapter implementations (IBKR, Tradovate), paper trading simulator, and broker connection management. [Cross-reference: FSD-003c Broker Adapters]
- Bracket order construction, order state machine, OCO group management, fill reconciliation, and position lifecycle. [Cross-reference: FSD-003d Order Construction & Lifecycle]
- Notification delivery mechanisms. [Cross-reference: FSD-008 Notifications]
- User authentication and authorization. [Cross-reference: FSD-009 Auth & Multi-Tenancy]

### 1.4 Glossary

| Term | Definition |
|---|---|
| R-Multiple | Net P&L divided by planned risk per trade; 1R = risk amount, 2R = twice the risk amount. |
| R:R Ratio | Risk-Reward Ratio: the ratio of potential reward to potential risk for a trade. |
| Circuit Breaker | A mechanism that halts order submission after consecutive broker failures. |
| MAE | Maximum Adverse Excursion: the worst unrealized loss during a trade's lifetime. |
| MFE | Maximum Favorable Excursion: the best unrealized profit during a trade's lifetime. |
| RTH | Regular Trading Hours (e.g., 9:30 AM - 4:00 PM ET for equity index futures). |
| ETH | Extended Trading Hours (outside RTH, typically overnight session). |
| Futures Day Boundary | 5:00 PM CT daily, the standard reset point for daily P&L in futures markets. |

### 1.5 Dependencies

| Dependency | Type | Description |
|---|---|---|
| PostgreSQL | Hard | Primary data store for risk settings, risk audit, and risk settings changelog. [Cross-reference: FSD-001] |
| Redis | Hard | Circuit breaker state storage. [Cross-reference: FSD-001] |
| Signal Enrichment (FSD-003a) | Hard | Provides computed fields (R:R ratio, risk per contract, account context) required for risk checks. |
| Positions Table (FSD-003d) | Hard | Risk checks query open positions for daily P&L, concurrent position count, and correlation analysis. |
| Notification Service | Soft | Delivers alerts for circuit breaker trips, daily loss limit reached, and risk warnings. [Cross-reference: FSD-008] |

---

## 2. Functional Specifications

### 2.1 Pre-Trade Risk Checks Overview

All signals that pass validation and enrichment (FSD-003a) enter the risk management engine. Risk checks execute sequentially in the order listed below. If any check returns `FAIL`, the signal is immediately rejected and subsequent checks are skipped. If a check returns `WARN`, the signal proceeds but the warning is logged and displayed to the user. Every check result is persisted to the `risk_check_audit` table (Section 2.7).

**Risk Check Execution Order**:

1. Maximum Position Size (EX-FR-016)
2. Daily Loss Limit (EX-FR-017)
3. Maximum Concurrent Positions (EX-FR-018)
4. Minimum Risk-Reward Ratio (EX-FR-019)
5. Correlation Limit (EX-FR-020)
6. Maximum Single Trade Risk (EX-RM-006)
7. Trading Hours (EX-RM-007)
8. Signal Staleness (EX-RM-008)

After all risk checks pass, quantity calculation (Section 2.9) is performed and the signal is forwarded to order construction (FSD-003d).

---

### 2.2 EX-FR-016: Maximum Position Size Check

**Source**: PRD-003 Section 3.4

**Description**: Prevents a user from accumulating more contracts in a single instrument than their configured maximum.

**Processing Logic**:

1. Retrieve the user's maximum position size for the signal's instrument from `user_risk_settings`:
   - Micro contracts (MNQ, MES, MYM, M2K, MGC, MCL, SIL): use `max_position_size_micro` (default: 2).
   - Full-size contracts (NQ, ES): use `max_position_size_full` (default: 1).
2. Query the `positions` table for OPEN positions in the same instrument for this user. Sum the quantities.
3. Determine `proposed_quantity`: from the signal if specified, otherwise 1 (final quantity is calculated later in Section 2.9, but the minimum of 1 is used for this pre-check).
4. Check: `existing_quantity + proposed_quantity <= max_position_size`.
5. If the check fails:
   - Risk check result: `FAIL`.
   - Rejection reason: `"Maximum position size exceeded for {instrument}. Current: {existing_quantity}, Proposed: {proposed_quantity}, Maximum: {max_position_size}"`.
6. Log the check in `risk_check_audit`: signal_id, check_name=`MAX_POSITION_SIZE`, result, actual_value=`existing_quantity + proposed_quantity`, threshold_value=`max_position_size`.

**Edge Cases**:
- User has an open position of 2 micro contracts and submits a signal for 1 more with max=2: `FAIL` because 2+1=3 > 2.
- User has 0 open contracts and submits for 1 with max=2: `PASS`.
- The proposed quantity may be adjusted downward during quantity calculation (Section 2.9) to fit within limits, but this check uses the signal's stated quantity (or 1) as a pre-flight validation.

---

### 2.3 EX-FR-017: Daily Loss Limit Check

**Source**: PRD-003 Section 3.4

**Description**: Prevents further trading when the user's daily losses (realized + unrealized) approach or exceed their configured daily loss limit. Uses worst-case analysis that assumes all open positions hit their stops.

**Processing Logic**:

1. Retrieve the user's daily loss limit from `user_risk_settings` (default: $500 for paper, user-defined for live).
2. Calculate current daily P&L:
   - **Realized**: sum of `realized_pnl` from `positions` table where `closed_at >= today_5pm_ct` (futures day boundary: 5:00 PM CT).
   - **Unrealized**: sum of `unrealized_pnl` from open positions.
   - **Total daily P&L** = realized + unrealized.
3. Calculate worst-case scenario -- assume the stop is hit on all open positions AND the new proposed trade:
   - `worst_case_additional_loss = sum(risk_per_contract * quantity for each open position) + proposed_risk`.
   - `worst_case_daily_pnl = total_daily_pnl - worst_case_additional_loss`.
4. If `worst_case_daily_pnl < -daily_loss_limit`:
   - Risk check result: `FAIL`.
   - Rejection reason: `"Daily loss limit would be exceeded. Current daily P&L: ${total_daily_pnl}. Worst case with new trade: ${worst_case_daily_pnl}. Daily limit: -${daily_loss_limit}"`.
5. If `total_daily_pnl <= -daily_loss_limit` (already at/past limit):
   - Risk check result: `FAIL`.
   - Rejection reason: `"Daily loss limit reached. Current daily P&L: ${total_daily_pnl}. No further trades allowed until next trading day (5:00 PM CT reset)"`.
6. The daily loss counter resets at 5:00 PM CT daily (futures day boundary).

**Business Rules**:
- The worst-case calculation is conservative: it assumes every open stop is hit simultaneously and the new trade also hits its stop. This protects against cascading losses.
- The 5:00 PM CT boundary aligns with the CME/CBOT/NYMEX daily settlement cycle.
- When the daily loss limit is reached, a `daily_loss_limit_reached` notification is emitted (Priority: High, Channels: Dashboard + Telegram). [Cross-reference: FSD-008]

**Edge Cases**:
- If an open position has no stop loss (stop_loss_price is null), the worst-case loss for that position is calculated using the user's `max_single_trade_risk` as a fallback.
- If the user changes their daily loss limit mid-day, the new limit applies immediately to the next risk check. P&L already accumulated is not affected.

---

### 2.4 EX-FR-018: Maximum Concurrent Positions Check

**Source**: PRD-003 Section 3.4

**Description**: Limits the number of simultaneously open positions.

**Processing Logic**:

1. Retrieve the user's max concurrent positions from `user_risk_settings` (default: 3).
2. Count positions in `positions` table with `status = 'OPEN'` for this user.
3. If `open_count >= max_concurrent_positions`:
   - Risk check result: `FAIL`.
   - Rejection reason: `"Maximum concurrent positions reached. Open: {open_count}, Maximum: {max_concurrent_positions}"`.

**Edge Cases**:
- A position that is in the process of closing (stop or take profit order submitted but not yet filled) still counts as OPEN until the fill is confirmed.

---

### 2.5 EX-FR-019: Minimum Risk-Reward Ratio Check

**Source**: PRD-003 Section 3.4

**Description**: Enforces a minimum risk-reward ratio to ensure trades have adequate profit potential relative to risk.

**Processing Logic**:

1. Retrieve the user's minimum R:R from `user_risk_settings` (default: 2.0).
2. Use the R:R calculated during signal enrichment (FSD-003a, EX-FR-014).
3. If `risk_reward_ratio` is null (stop or target missing):
   - If minimum R:R > 0, reject with: `"Risk-reward ratio cannot be calculated. Stop loss and take profit are required when minimum R:R is set to {min_rr}"`.
   - If minimum R:R = 0, the check passes (user has explicitly disabled R:R enforcement).
4. If `risk_reward_ratio < min_rr`:
   - Risk check result: `FAIL`.
   - Rejection reason: `"Risk-reward ratio {risk_reward_ratio} is below minimum {min_rr}. Stop distance: {stop_distance} ticks, Target distance: {target_distance} ticks"`.

**Business Rules**:
- The R:R ratio is computed as: `reward_per_contract / risk_per_contract`.
- For LONG: `reward = take_profit_price - entry_price`, `risk = entry_price - stop_loss_price`.
- For SHORT: `reward = entry_price - take_profit_price`, `risk = stop_loss_price - entry_price`.
- Manual signals (FSD-003a, EX-FR-003) that omit both stop and target proceed with a warning upstream but are ultimately rejected here if min R:R > 0.
- Setting minimum R:R to 0 effectively disables this check.

---

### 2.6 EX-FR-020: Correlation Limit Check

**Source**: PRD-003 Section 3.4

**Description**: Detects when a proposed trade would create excessive correlation exposure with existing open positions. Supports both `warn` (proceed with warning) and `block` (reject) modes.

**Processing Logic**:

1. Retrieve the user's correlation settings from `user_risk_settings`:
   - `correlation_action`: `warn` or `block` (default: `warn`).
   - `correlation_threshold`: 0.0 to 1.0 (default: 0.7).
2. Query open positions for this user.
3. For each open position, look up the correlation coefficient between the open position's instrument and the proposed signal's instrument in the `instrument_correlations` table.
4. Pre-configured correlation pairs (static matrix for MVP):

| Instrument A | Instrument B | Correlation |
|---|---|---|
| MNQ | MES | 0.95 |
| MNQ | MYM | 0.88 |
| MNQ | M2K | 0.82 |
| MES | MYM | 0.92 |
| MES | M2K | 0.85 |
| MYM | M2K | 0.80 |
| NQ | MNQ | 1.00 |
| ES | MES | 1.00 |
| MGC | SIL | 0.75 |

5. If any correlation coefficient exceeds the threshold:
   - If action is `block`: risk check result `FAIL`, rejection reason `"Correlation limit exceeded. {instrument_a} and {instrument_b} have correlation {correlation}, threshold: {threshold}"`.
   - If action is `warn`: risk check result `WARN`. Signal proceeds but a warning is logged and displayed to the user: `"Warning: {instrument_a} and {instrument_b} are highly correlated ({correlation}). Consider the combined risk exposure."`.

**Full Correlation Matrix**:

| | MNQ | MES | MYM | M2K | MGC | MCL | SIL |
|---|---|---|---|---|---|---|---|
| **MNQ** | 1.00 | 0.95 | 0.88 | 0.82 | 0.15 | 0.10 | 0.12 |
| **MES** | 0.95 | 1.00 | 0.92 | 0.85 | 0.18 | 0.12 | 0.14 |
| **MYM** | 0.88 | 0.92 | 1.00 | 0.80 | 0.20 | 0.15 | 0.16 |
| **M2K** | 0.82 | 0.85 | 0.80 | 1.00 | 0.12 | 0.08 | 0.10 |
| **MGC** | 0.15 | 0.18 | 0.20 | 0.12 | 1.00 | 0.25 | 0.75 |
| **MCL** | 0.10 | 0.12 | 0.15 | 0.08 | 0.25 | 1.00 | 0.30 |
| **SIL** | 0.12 | 0.14 | 0.16 | 0.10 | 0.75 | 0.30 | 1.00 |

Note: Full-size contracts (NQ, ES) have correlation 1.00 with their micro counterparts (MNQ, MES).

**Business Rules**:
- The correlation matrix is symmetric: `corr(A, B) == corr(B, A)`.
- If a pair is not in the matrix, correlation is assumed to be 0.0.
- MVP uses a static pre-configured matrix. Dynamic computation from recent price data is deferred. [Open question OQ-006]
- The `risk.warning` WebSocket event is emitted for WARN results: `{check_name: "CORRELATION", message: "...", actual_value: correlation, threshold: threshold}`.

---

### 2.7 EX-FR-021: Risk Check Audit Trail

**Source**: PRD-003 Section 3.4

**Description**: Every risk check is immutably logged for compliance, debugging, and trade analysis.

**Processing Logic**:

Every risk check (EX-FR-016 through EX-FR-020, plus EX-RM-006 through EX-RM-008) is logged to the `risk_check_audit` table with:

| Field | Description |
|---|---|
| signal_id | The signal being evaluated. |
| check_name | Enum: `MAX_POSITION_SIZE`, `DAILY_LOSS_LIMIT`, `MAX_CONCURRENT_POSITIONS`, `MIN_RISK_REWARD`, `CORRELATION`, `MAX_SINGLE_TRADE_RISK`, `TRADING_HOURS`, `SIGNAL_STALENESS`. |
| result | `PASS`, `FAIL`, or `WARN`. |
| actual_value | The computed value for the check (e.g., current daily P&L, current open position count). |
| threshold_value | The user's configured threshold for the check. |
| details | JSONB with additional context (e.g., list of correlated instruments, worst-case P&L breakdown). |
| checked_at | UTC timestamp of the check. |

**Business Rules**:
- Audit records are append-only. Application code never updates or deletes records.
- Even if a signal is rejected on an earlier check, the failing check is still logged.
- The audit trail is referenced by the journal service (FSD-004) for trade analysis and by the analytics service (FSD-005) for risk pattern detection.
- Audit records are available via the signal status API: `GET /api/v1/signals/{signal_id}` returns a `risk_checks` array.

---

### 2.8 EX-FR-022: Risk Parameter Configuration

**Source**: PRD-003 Section 3.4

**Description**: Users configure their risk parameters through the API. All parameters have sensible defaults and enforced ranges.

**Configuration Parameters**:

| Parameter | Field Name | Type | Default | Range |
|---|---|---|---|---|
| Max position size per instrument (micro) | max_position_size_micro | integer | 2 | 1-50 |
| Max position size per instrument (full-size) | max_position_size_full | integer | 1 | 1-10 |
| Daily loss limit | daily_loss_limit | Decimal | 500.00 | 50-100000 |
| Max concurrent positions | max_concurrent_positions | integer | 3 | 1-20 |
| Min R:R ratio | min_risk_reward_ratio | Decimal | 2.0 | 0-10.0 |
| Correlation action | correlation_action | enum | warn | warn, block |
| Correlation threshold | correlation_threshold | Decimal | 0.7 | 0.0-1.0 |
| Max single-trade risk | max_single_trade_risk | Decimal | 200.00 | 10-10000 |
| Fixed risk per trade | fixed_risk_per_trade | Decimal | 100.00 | 10-10000 |
| Trading hours | trading_hours | enum | RTH | RTH, ETH, 24H |
| Signal staleness | signal_staleness_minutes | integer | 5 | 1-30 |
| Consecutive loss cooldown | consecutive_loss_cooldown | integer | 3 | 0-10 |
| Weekly drawdown warning | weekly_drawdown_warning | Decimal | 1000.00 | 100-100000 |
| Break-even stop mode | break_even_stop_mode | enum | manual | auto, manual, off |

**Business Rules**:
- Changes take effect immediately for new signals. Changes do NOT affect orders already submitted to brokers.
- All changes are logged in `risk_settings_changelog` with `previous_value`, `new_value`, `changed_at`, and `user_id`.
- When a user account is created, a default `user_risk_settings` row is inserted with all default values.
- Validation is performed server-side: any value outside the allowed range returns HTTP 400 with the specific validation error.

**Error Handling**:

| Error | Response |
|---|---|
| Value below minimum | HTTP 400: `"daily_loss_limit must be at least 50. Provided: 25"` |
| Value above maximum | HTTP 400: `"max_concurrent_positions must be at most 20. Provided: 50"` |
| Invalid enum value | HTTP 400: `"correlation_action must be 'warn' or 'block'. Provided: 'ignore'"` |
| Non-numeric value for numeric field | HTTP 400: `"daily_loss_limit must be a number. Provided: 'abc'"` |

---

### 2.9 Order Quantity Calculation

**Source**: PRD-003 Section 3.5 (EX-FR-026)

**Description**: When a signal does not specify a quantity, the system calculates the number of contracts based on the user's fixed risk per trade and the per-contract risk of the trade.

**Processing Logic** (when signal quantity is null):

1. Retrieve user's fixed risk per trade from `user_risk_settings` (default: $100).
2. Calculate risk per contract: `stop_distance_ticks * tick_value`.
3. Calculate quantity: `floor(fixed_risk / risk_per_contract)`.
4. Clamp to maximum position size (EX-FR-016): `min(quantity, max_position_size - existing_position)`.
5. Enforce minimum quantity of 1: `max(quantity, 1)`.
6. If `risk_per_contract > fixed_risk`, quantity is 1 and a warning is logged: `"Risk per contract (${risk_per_contract}) exceeds fixed risk per trade (${fixed_risk}). Proceeding with minimum quantity of 1."`.

**Example**:
- User fixed risk: $100. MNQ stop distance: 40 ticks. MNQ tick value: $0.50.
- Risk per contract: 40 * $0.50 = $20.
- Quantity: floor(100 / 20) = 5.
- If max position size is 2: quantity = 2.

**Edge Cases**:
- Stop distance of 0 ticks: caught upstream by price validation (FSD-003a, EX-FR-013). Should never reach quantity calculation.
- Extremely tight stop (e.g., 1 tick on MNQ = $0.50 risk/contract): quantity = floor(100/0.50) = 200, then clamped to max_position_size.
- If the signal specifies a quantity explicitly, that quantity is used instead (still validated against max position size).

---

### 2.10 EX-FR-050: Circuit Breaker

**Source**: PRD-003 Section 3.10

**Description**: The circuit breaker halts order submission after consecutive broker failures to prevent cascading errors and protect users during broker outages.

**State Machine**:

```
    +--------+
    | CLOSED |  (Normal -- orders flow through)
    +---+----+
        |
  broker failure
  (counter < threshold)
        |
        v
    +---+----+
    | CLOSED |  (Counter incremented)
    +---+----+
        |
  broker failure
  (counter >= threshold)
        |
        v
    +---+------+
    | TRIPPED  |  (Orders halted, signals queued)
    +---+------+
        |         \
  auto-reset       manual reset
  (cooldown)       (user action)
        |         /
        v
    +---+----+
    | CLOSED |  (Counter reset to 0)
    +--------+
```

**States**:

| State | Behavior |
|---|---|
| CLOSED | Normal operation. Orders are submitted to the broker. The failure counter tracks consecutive failures. |
| TRIPPED | All order submission is halted. Incoming signals are queued (up to 50 signals). User is notified immediately. |

**Processing Logic**:

1. **Failure Tracking**: On each broker operation failure (connection timeout, connection refused, HTTP 5xx, unexpected error), increment the consecutive failure counter.
2. **Success Reset**: On any successful broker operation, reset the counter to 0.
3. **Trip Condition**: When the counter reaches the configurable threshold (default: 3, env var `CIRCUIT_BREAKER_THRESHOLD`):
   - Set state to TRIPPED.
   - Record `tripped_at` timestamp.
   - Emit notifications:
     - Dashboard: real-time banner via WebSocket event `circuit_breaker.tripped`.
     - Telegram: "CIRCUIT BREAKER ACTIVE -- Trading halted after {N} consecutive broker failures. Last error: {error_message}".
     - Email: same message with additional context.
   - Log: `CRITICAL: Circuit breaker tripped for user {user_id}. {consecutive_failures} consecutive failures. Last error: {error}`.
4. **Signal Queuing While Tripped**: Signals that arrive while the circuit breaker is tripped are queued in memory (max 50). If the queue is full, new signals are rejected with reason `"Circuit breaker is active. Signal queue is full."`.
5. **Auto-Reset**: After the configurable cooldown period (default: 15 minutes / 900 seconds, env var `CIRCUIT_BREAKER_COOLDOWN_SECONDS`):
   - Set state to CLOSED.
   - Reset counter to 0.
   - Emit `circuit_breaker.reset` event with `reset_type: "auto"`.
   - Process queued signals: re-evaluate each signal's price validity (market price may have moved) and process valid signals through the full pipeline.
   - Log: `INFO: Circuit breaker auto-reset for user {user_id} after {cooldown}s cooldown.`
6. **Manual Reset**: User clicks "Reset" on the dashboard (or calls the API):
   - Set state to CLOSED.
   - Reset counter to 0.
   - Emit `circuit_breaker.reset` event with `reset_type: "manual"`.
   - Process queued signals (same re-evaluation as auto-reset).
   - Log: `INFO: Circuit breaker manually reset by user {user_id}.`

**Redis State Storage**:

| Key | Type | Fields |
|---|---|---|
| `circuit_breaker:{user_id}` | Hash | `consecutive_failures` (int), `tripped_at` (ISO timestamp or null), `cooldown_seconds` (int), `state` (CLOSED/TRIPPED) |

**Business Rules**:
- The circuit breaker is per-user, not global. One user's broker issues do not affect other users.
- The circuit breaker counts failures across all broker operations (place_order, cancel_order, modify_order, get_positions).
- Broker-side rejections (e.g., IB error 110 "price out of range", IB error 201 "order rejected") do NOT increment the circuit breaker. These are expected application-level errors, not connectivity failures.
- Only connectivity failures (connection refused, timeout, HTTP 5xx, unexpected socket errors) increment the counter.
- If IB Gateway is unavailable for > 5 minutes, the circuit breaker trips. Incoming signals are queued (up to 50). When connection is restored, queued signals are re-evaluated (price validity re-checked) and processed if still valid.

**Error Handling**:

| Condition | Behavior |
|---|---|
| Redis unavailable for state read | Assume CLOSED state (fail-open). Log WARNING. |
| Redis unavailable for state write | Continue operation. Log WARNING. Counter may be inaccurate until Redis returns. |
| Queued signal has stale price after reset | Signal is re-validated. If price is now > 5% from market, signal is rejected with `"Signal price is stale after circuit breaker reset"`. |

---

### 2.11 EX-FR-052-054: Manual Overrides

**Source**: PRD-003 Section 3.11

**Description**: Users can manually intervene in the execution pipeline from the dashboard. All manual actions are validated, logged, and audited.

#### 2.11.1 Order Cancellation (EX-FR-052)

**Endpoint**: `DELETE /api/v1/orders/{order_id}`

**Processing Logic**:

1. Authenticate the user (Bearer token).
2. Look up the order. Verify it belongs to the authenticated user.
3. Validate the order is in a cancellable state: `SUBMITTED`, `PENDING`, or `PARTIAL_FILL`.
4. If order is `FILLED`, `CANCELLED`, `CLOSED`, or `REJECTED`: return HTTP 400 `{"error": "Order cannot be cancelled. Current status: {status}"}`.
5. Send cancellation request to the broker adapter: `cancel_order(broker_order_id)`.
6. On broker confirmation: update order status to `CANCELLED`, set `cancelled_at = NOW()`.
7. If the cancelled order is part of a bracket group (STOP_LOSS or TAKE_PROFIT role):
   - Do NOT automatically cancel the paired order. The position remains open with only one protective order.
   - Display a warning to the user: "Warning: Stop loss/take profit cancelled. Position {instrument} is now unprotected on one side."
8. Log to `execution_audit_log`: event_type=`manual.cancel`, event_data includes order_id, user_id, original status, timestamp.

**Error Handling**:

| HTTP Status | Condition | Response |
|---|---|---|
| 200 | Cancellation successful | `{"order_id": "uuid", "status": "CANCELLED", "cancelled_at": "timestamp"}` |
| 400 | Order not cancellable | `{"error": "Order cannot be cancelled. Current status: {status}"}` |
| 404 | Order not found or not owned by user | `{"error": "Order not found"}` |
| 502 | Broker connection failure during cancel | `{"error": "Unable to reach broker. Please try again."}` |

#### 2.11.2 Order Modification (EX-FR-053)

**Endpoint**: `PATCH /api/v1/orders/{order_id}`

**Request Body** (all fields optional):

| Field | Type | Validation |
|---|---|---|
| price | Decimal | For LIMIT orders: must be > 0. For STOP orders: must be > 0. |
| stop_price | Decimal | For STOP/STOP_LIMIT orders: must be > 0 and on correct side of entry. |
| quantity | integer | Can only be reduced (not increased). Must be >= 1. |

**Processing Logic**:

1. Authenticate the user.
2. Look up the order. Verify ownership.
3. Validate the order is in a modifiable state: `SUBMITTED` or `PENDING`.
4. Validate modifications against risk rules:
   - New stop price must maintain valid side relative to entry (LONG stop below entry, SHORT stop above entry).
   - New stop distance must be >= 1 tick.
   - If reducing quantity, new quantity must be >= 1.
   - Quantity cannot be increased (to increase, cancel and resubmit).
5. Send modification to broker adapter: `modify_order(broker_order_id, modifications)`.
6. On broker confirmation: update the order record with new values.
7. Log to `execution_audit_log`: event_type=`manual.modify`, event_data includes order_id, original_values, new_values, user_id, timestamp.

**Error Handling**:

| HTTP Status | Condition | Response |
|---|---|---|
| 200 | Modification successful | `{"order_id": "uuid", "updated_fields": {...}, "status": "PENDING"}` |
| 400 | Invalid modification | `{"error": "Stop loss must be below entry price for LONG positions"}` |
| 400 | Increase quantity attempt | `{"error": "Quantity can only be reduced, not increased"}` |
| 400 | Order not modifiable | `{"error": "Order cannot be modified. Current status: {status}"}` |
| 404 | Order not found | `{"error": "Order not found"}` |

#### 2.11.3 Position Close (EX-FR-054)

**Endpoint**: `POST /api/v1/positions/{position_id}/close`

**Processing Logic**:

1. Authenticate the user.
2. Look up the position. Verify ownership and status is `OPEN`.
3. Submit a market order to close the position:
   - Side: opposite of position direction (SELL for LONG, BUY for SHORT).
   - Quantity: full position quantity.
   - Order type: MARKET.
4. Cancel the existing stop loss and take profit orders for this position.
5. On fill confirmation: update position status to `CLOSED`, set `exit_reason = 'MANUAL_CLOSE'`.
6. Emit `trade.closed` event for journal and analytics (FSD-003d).
7. Log to `execution_audit_log`: event_type=`manual.close_position`, event_data includes position_id, user_id, instrument, direction, timestamp.

**Error Handling**:

| HTTP Status | Condition | Response |
|---|---|---|
| 200 | Close initiated | `{"position_id": "uuid", "closing_order_id": "uuid", "status": "closing"}` |
| 400 | Position already closed | `{"error": "Position is already closed"}` |
| 404 | Position not found | `{"error": "Position not found"}` |
| 502 | Broker connection failure | `{"error": "Unable to reach broker. Please try again."}` |

#### 2.11.4 Emergency Flatten All (EX-FR-055)

**Endpoint**: `POST /api/v1/positions/flatten-all`

**Request Body**: `{"confirm": true}`

**Processing Logic**:

1. Authenticate the user.
2. Verify `confirm` is `true`. If missing or false: return HTTP 400 `{"error": "Confirmation required. Send {\"confirm\": true}"}`.
3. Immediately and concurrently:
   a. Close all open positions via market orders (submit close orders for each position simultaneously).
   b. Cancel all pending orders.
   c. Disable signal processing for this user (set a flag to reject incoming signals until user explicitly re-enables).
4. Must complete within 5 seconds. If any individual operation times out, continue with remaining operations (best-effort).
5. Return results:
   ```json
   {
     "positions_closed": 3,
     "orders_cancelled": 7,
     "signal_processing": "disabled",
     "errors": []
   }
   ```
6. If any operations failed, include them in the `errors` array: `["Failed to cancel order {order_id}: broker timeout"]`.
7. Log to `execution_audit_log`: event_type=`manual.flatten_all`, event_data includes user_id, positions_closed count, orders_cancelled count, errors, timestamp.

**Business Rules**:
- Flatten-all requires only a single confirmation (`confirm: true`), not multi-step confirmation. This is a fast-path emergency action per PRD requirements.
- Signal processing remains disabled until the user explicitly re-enables it via `PUT /api/v1/settings/risk` with `signal_processing_enabled: true` or by clicking "Resume Trading" on the dashboard.
- All flatten-all operations are parallel, not sequential, to minimize total execution time.

---

## 3. Data Specifications

### 3.1 Database Tables

#### 3.1.1 `risk_check_audit` Table

```sql
CREATE TABLE risk_check_audit (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    signal_id UUID NOT NULL REFERENCES signals(id),
    check_name VARCHAR(50) NOT NULL,
    result VARCHAR(10) NOT NULL CHECK (result IN ('PASS', 'FAIL', 'WARN')),
    actual_value DECIMAL(12,4),
    threshold_value DECIMAL(12,4),
    details JSONB,
    checked_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_risk_audit_signal_id ON risk_check_audit(signal_id);
```

**Notes**:
- `check_name` values: `MAX_POSITION_SIZE`, `DAILY_LOSS_LIMIT`, `MAX_CONCURRENT_POSITIONS`, `MIN_RISK_REWARD`, `CORRELATION`, `MAX_SINGLE_TRADE_RISK`, `TRADING_HOURS`, `SIGNAL_STALENESS`.
- `details` JSONB examples:
  - Position size: `{"instrument": "MNQ", "existing_qty": 1, "proposed_qty": 1}`.
  - Daily loss: `{"realized_pnl": -200.00, "unrealized_pnl": -50.00, "worst_case": -400.00}`.
  - Correlation: `{"correlated_with": "MES", "coefficient": 0.95, "open_position_id": "uuid"}`.
- Minimum retention: 7 years. Records are never deleted by application code.

#### 3.1.2 `user_risk_settings` Table

```sql
CREATE TABLE user_risk_settings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL UNIQUE REFERENCES users(id),
    max_position_size_micro INTEGER NOT NULL DEFAULT 2,
    max_position_size_full INTEGER NOT NULL DEFAULT 1,
    daily_loss_limit DECIMAL(10,2) NOT NULL DEFAULT 500.00,
    max_concurrent_positions INTEGER NOT NULL DEFAULT 3,
    min_risk_reward_ratio DECIMAL(4,2) NOT NULL DEFAULT 2.00,
    correlation_action VARCHAR(10) NOT NULL DEFAULT 'warn'
        CHECK (correlation_action IN ('warn', 'block')),
    correlation_threshold DECIMAL(3,2) NOT NULL DEFAULT 0.70,
    max_single_trade_risk DECIMAL(10,2) NOT NULL DEFAULT 200.00,
    fixed_risk_per_trade DECIMAL(10,2) NOT NULL DEFAULT 100.00,
    trading_hours VARCHAR(5) NOT NULL DEFAULT 'RTH'
        CHECK (trading_hours IN ('RTH', 'ETH', '24H')),
    signal_staleness_minutes INTEGER NOT NULL DEFAULT 5,
    paper_slippage_ticks INTEGER NOT NULL DEFAULT 1,
    min_paper_trading_days INTEGER NOT NULL DEFAULT 60,
    dedup_window_minutes INTEGER NOT NULL DEFAULT 5,
    dedup_price_tolerance_ticks INTEGER NOT NULL DEFAULT 2,
    stop_type VARCHAR(15) NOT NULL DEFAULT 'STOP_MARKET'
        CHECK (stop_type IN ('STOP_MARKET', 'STOP_LIMIT')),
    default_time_in_force VARCHAR(5) NOT NULL DEFAULT 'GTC'
        CHECK (default_time_in_force IN ('DAY', 'GTC', 'GTD')),
    prefer_micro BOOLEAN NOT NULL DEFAULT TRUE,
    consecutive_loss_cooldown INTEGER NOT NULL DEFAULT 3,
    weekly_drawdown_warning DECIMAL(10,2) NOT NULL DEFAULT 1000.00,
    break_even_stop_mode VARCHAR(10) NOT NULL DEFAULT 'manual'
        CHECK (break_even_stop_mode IN ('auto', 'manual', 'off')),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Notes**:
- One row per user (`user_id UNIQUE`).
- Risk-specific fields (the focus of this FSD): `max_position_size_micro`, `max_position_size_full`, `daily_loss_limit`, `max_concurrent_positions`, `min_risk_reward_ratio`, `correlation_action`, `correlation_threshold`, `max_single_trade_risk`, `fixed_risk_per_trade`, `trading_hours`, `signal_staleness_minutes`, `consecutive_loss_cooldown`, `weekly_drawdown_warning`, `break_even_stop_mode`.
- Other fields (owned by sibling FSDs but co-located): `paper_slippage_ticks` (FSD-003c), `min_paper_trading_days` (FSD-003c), `dedup_window_minutes` (FSD-003a), `dedup_price_tolerance_ticks` (FSD-003a), `stop_type` (FSD-003d), `default_time_in_force` (FSD-003d), `prefer_micro` (FSD-003a).

#### 3.1.3 `risk_settings_changelog` Table

```sql
CREATE TABLE risk_settings_changelog (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    setting_name VARCHAR(50) NOT NULL,
    previous_value TEXT,
    new_value TEXT NOT NULL,
    changed_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_risk_changelog_user_id ON risk_settings_changelog(user_id);
```

**Notes**:
- Every change to `user_risk_settings` produces one row per changed field.
- `previous_value` is null for the initial default insertion.
- `setting_name` matches the column name in `user_risk_settings`.

#### 3.1.4 `instrument_correlations` Table

```sql
CREATE TABLE instrument_correlations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    instrument_a VARCHAR(10) NOT NULL,
    instrument_b VARCHAR(10) NOT NULL,
    correlation DECIMAL(4,2) NOT NULL,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (instrument_a, instrument_b)
);

CREATE INDEX idx_instrument_corr_a ON instrument_correlations(instrument_a);
CREATE INDEX idx_instrument_corr_b ON instrument_correlations(instrument_b);
```

**Seed Data**: Pre-populated with the correlation matrix values from Section 2.6.

#### 3.1.5 `execution_audit_log` Table (Shared)

```sql
CREATE TABLE execution_audit_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    event_type VARCHAR(50) NOT NULL,
    event_data JSONB NOT NULL,
    ip_address INET,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_exec_audit_user_id ON execution_audit_log(user_id);
CREATE INDEX idx_exec_audit_event_type ON execution_audit_log(event_type);
CREATE INDEX idx_exec_audit_created_at ON execution_audit_log(created_at);
```

**Risk-relevant event types**:
- `signal.risk_checked` -- All risk check results with values.
- `signal.rejected` -- Rejection reason, which check failed.
- `manual.cancel` -- User ID, order ID, timestamp.
- `manual.modify` -- User ID, order ID, original/new values.
- `manual.close_position` -- User ID, position ID, timestamp.
- `manual.flatten_all` -- User ID, positions closed count, orders cancelled count.
- `circuit_breaker.tripped` -- Consecutive failures, last error.
- `circuit_breaker.reset` -- Reset type (manual/auto).
- `risk_settings.changed` -- Setting name, old value, new value.

**Retention**: Minimum 7 years. Records are never deleted by application code. Archival to cold storage after 1 year is managed by the infrastructure layer.

### 3.2 Redis Keys

| Key Pattern | Type | TTL | Purpose |
|---|---|---|---|
| `circuit_breaker:{user_id}` | Hash | -- (persistent) | Circuit breaker state: `consecutive_failures`, `tripped_at`, `cooldown_seconds`, `state` |

---

## 4. API Specifications

### 4.1 Risk Settings Endpoints

#### `GET /api/v1/settings/risk`

**Authentication**: Bearer token (session token).

**Response 200**:
```json
{
  "max_position_size_micro": 2,
  "max_position_size_full": 1,
  "daily_loss_limit": "500.00",
  "max_concurrent_positions": 3,
  "min_risk_reward_ratio": "2.00",
  "correlation_action": "warn",
  "correlation_threshold": "0.70",
  "max_single_trade_risk": "200.00",
  "fixed_risk_per_trade": "100.00",
  "trading_hours": "RTH",
  "signal_staleness_minutes": 5,
  "consecutive_loss_cooldown": 3,
  "weekly_drawdown_warning": "1000.00",
  "break_even_stop_mode": "manual"
}
```

#### `PUT /api/v1/settings/risk`

**Authentication**: Bearer token (session token).

**Request Body** (all fields optional; only provided fields are updated):
```json
{
  "daily_loss_limit": 750.00,
  "max_concurrent_positions": 5,
  "correlation_action": "block"
}
```

**Response 200**: Returns the full updated settings object (same format as GET).

**Validation**: Each field is validated against its allowed range (see Section 2.8). Invalid values return HTTP 400 with a specific error message per field.

**Side Effects**:
- For each changed field, a row is inserted into `risk_settings_changelog`.
- A `risk_settings.changed` event is logged to `execution_audit_log`.
- Changes take effect immediately for new signals.

### 4.2 Manual Override Endpoints

#### `DELETE /api/v1/orders/{order_id}`

Cancel a pending order. See Section 2.11.1 for full specification.

#### `PATCH /api/v1/orders/{order_id}`

Modify a pending order. See Section 2.11.2 for full specification.

#### `POST /api/v1/positions/{position_id}/close`

Close a position at market. See Section 2.11.3 for full specification.

#### `POST /api/v1/positions/flatten-all`

Emergency flatten all. See Section 2.11.4 for full specification.

### 4.3 Circuit Breaker Endpoint

#### `POST /api/v1/circuit-breaker/reset`

**Authentication**: Bearer token (session token).

**Processing Logic**:
1. Check if circuit breaker is currently TRIPPED for this user.
2. If not tripped: return HTTP 400 `{"error": "Circuit breaker is not active"}`.
3. If tripped: reset to CLOSED, counter to 0, process queued signals.
4. Return HTTP 200 `{"status": "reset", "queued_signals_processing": 3}`.

### 4.4 WebSocket Events (Risk-Related)

These events are pushed to connected clients via `WS /api/v1/ws/execution`:

| Event Type | Payload | Description |
|---|---|---|
| `circuit_breaker.tripped` | `{consecutive_failures, cooldown_seconds}` | Circuit breaker activated |
| `circuit_breaker.reset` | `{reset_type: "manual"/"auto"}` | Circuit breaker reset |
| `risk.warning` | `{check_name, message, actual_value, threshold}` | Risk warning (correlation, etc.) |

---

## 5. UI/UX Specifications

### 5.1 Circuit Breaker Status

**Location**: Dashboard header bar, next to broker connection status.

**States**:
- **Normal**: Green shield icon. No text.
- **Tripped**: Red shield icon + "CIRCUIT BREAKER ACTIVE - Trading halted" banner. Shows countdown to auto-reset. Shows "Reset" button.
- **Cooldown**: Yellow shield icon + "Resetting in {seconds}s" text.

### 5.2 Emergency Flatten All

**Location**: Dashboard header bar, always visible. Red button labeled "FLATTEN ALL".

**Confirmation Dialog**: Modal with:
- Text: "This will immediately close ALL open positions and cancel ALL pending orders. This action cannot be undone."
- Single "Confirm Flatten All" button (red).
- "Cancel" button.
- No additional confirmation steps (fast path per PRD requirement).

### 5.3 Risk Settings Form

**Location**: Dashboard settings page, "Risk Management" section.

Each parameter is displayed as a labeled input with its current value, default indicated, and allowed range shown as helper text. Changes are saved via the `PUT /api/v1/settings/risk` endpoint.

### 5.4 R:R Ratio Display (Order Entry Form)

**Location**: Dashboard manual order entry form (FSD-003a).

- **R:R Ratio**: Computed and displayed in real-time as user types stop/target values. Shows as "R:R: 2.5" with color: green >= 2.0, yellow 1.5-2.0, red < 1.5.
- **Risk Display**: When stop loss is filled, shows calculated risk in dollars below the field.
- **Quantity Display**: Shows "Auto (calculated from risk)" placeholder when empty. Shows calculated quantity based on current risk settings.

---

## 6. Security Specifications

### 6.1 Audit and Compliance (EX-SEC-009)

All risk-related actions are logged to the `execution_audit_log` table (append-only):

| Event Type | Logged Data |
|---|---|
| `signal.risk_checked` | All risk check results with values |
| `signal.rejected` | Rejection reason, which check failed |
| `manual.cancel` | User ID, order ID, timestamp |
| `manual.modify` | User ID, order ID, original/new values |
| `manual.close_position` | User ID, position ID, timestamp |
| `manual.flatten_all` | User ID, positions closed count, orders cancelled count |
| `circuit_breaker.tripped` | Consecutive failures, last error |
| `circuit_breaker.reset` | Reset type (manual/auto) |
| `risk_settings.changed` | Setting name, old value, new value |

**Retention**: Minimum 7 years. Records are never deleted by application code.

### 6.2 Manual Override Authorization

- All manual override endpoints require Bearer token authentication.
- Users can only act on their own orders and positions (verified by user_id comparison).
- Order modifications are validated against risk rules (stop side, minimum distance).
- Flatten-all requires explicit confirmation in the request body.
- All manual actions are logged with user_id, IP address, and timestamp for compliance.

---

## 7. Performance Specifications

### 7.1 Risk Check Latency

| Metric | Target (p50) | Target (p95) |
|---|---|---|
| All risk checks combined (single signal) | < 50ms | < 200ms |
| Individual risk check (any) | < 10ms | < 50ms |
| Quantity calculation | < 5ms | < 20ms |
| Circuit breaker state check (Redis) | < 5ms | < 20ms |

### 7.2 Manual Override Latency

| Metric | Target (p50) | Target (p95) |
|---|---|---|
| Order cancellation (end-to-end) | < 1s | < 3s |
| Order modification (end-to-end) | < 1s | < 3s |
| Position close (end-to-end) | < 1s | < 3s |
| Flatten-all (all operations complete) | < 3s | < 5s |

### 7.3 Notification Delivery

| Event | Target Latency | Channels |
|---|---|---|
| Circuit breaker tripped | < 5s | Dashboard (real-time), Telegram, Email |
| Daily loss limit reached | < 5s | Dashboard, Telegram |
| Risk warning (correlation) | < 2s | Dashboard (real-time) |

---

## 8. Testing Specifications

### 8.1 Unit Tests: Risk Checks

| Test ID | Test Case | Input | Expected |
|---|---|---|---|
| UT-RC-001 | Position size within limit | existing=1, proposed=1, max=2 | PASS |
| UT-RC-002 | Position size exceeds limit | existing=2, proposed=1, max=2 | FAIL: "Maximum position size exceeded for MNQ. Current: 2, Proposed: 1, Maximum: 2" |
| UT-RC-003 | Daily loss within limit | daily_pnl=-$200, limit=$500 | PASS |
| UT-RC-004 | Daily loss at limit | daily_pnl=-$500, limit=$500 | FAIL: "Daily loss limit reached..." |
| UT-RC-005 | Worst case exceeds limit | daily_pnl=-$400, new_risk=$150, limit=$500 | FAIL (worst case: -$550 > -$500) |
| UT-RC-006 | Concurrent positions within limit | open=2, max=3 | PASS |
| UT-RC-007 | Concurrent positions at limit | open=3, max=3 | FAIL: "Maximum concurrent positions reached. Open: 3, Maximum: 3" |
| UT-RC-008 | R:R above minimum | rr=2.5, min=2.0 | PASS |
| UT-RC-009 | R:R below minimum | rr=1.5, min=2.0 | FAIL: "Risk-reward ratio 1.5 is below minimum 2.0..." |
| UT-RC-010 | Correlation warn mode | MNQ open, new MES signal, corr=0.95, action=warn | WARN with message |
| UT-RC-011 | Correlation block mode | MNQ open, new MES signal, corr=0.95, action=block | FAIL |
| UT-RC-012 | No correlation concern | MNQ open, new MGC signal, corr=0.15, threshold=0.7 | PASS |
| UT-RC-013 | R:R null with min_rr=0 | rr=null, min=0 | PASS (R:R enforcement disabled) |
| UT-RC-014 | R:R null with min_rr=2 | rr=null, min=2.0 | FAIL: "Risk-reward ratio cannot be calculated..." |
| UT-RC-015 | Daily loss limit reset at 5PM CT | closed -$400 trade before 5PM, new day starts | daily_pnl resets to $0, PASS |
| UT-RC-016 | Correlation with unknown pair | MNQ open, new MCL signal | correlation=0.10, below 0.7 threshold, PASS |

### 8.2 Unit Tests: Quantity Calculation

| Test ID | Test Case | Input | Expected |
|---|---|---|---|
| UT-QC-001 | Standard calculation | risk=$100, stop=40 ticks, tick_val=$0.50 | qty=5 (100/20=5) |
| UT-QC-002 | Clamped to max | risk=$100, stop=10 ticks, tick_val=$0.50, max=2 | qty=2 (floor(100/5)=20, clamped to 2) |
| UT-QC-003 | Minimum of 1 | risk=$100, stop=300 ticks, tick_val=$0.50 | qty=1 (floor(100/150)=0, min=1) + warning |
| UT-QC-004 | Exact division | risk=$100, stop=200 ticks, tick_val=$0.50 | qty=1 (floor(100/100)=1) |

### 8.3 Unit Tests: Circuit Breaker

| Test ID | Test Case | Input | Expected |
|---|---|---|---|
| UT-CB-001 | 2 failures, not tripped | 2 consecutive failures, threshold=3 | Circuit breaker NOT tripped, counter=2 |
| UT-CB-002 | 3 failures, tripped | 3 consecutive failures, threshold=3 | Circuit breaker TRIPPED, no further orders |
| UT-CB-003 | Success resets counter | 2 failures then 1 success | Counter reset to 0 |
| UT-CB-004 | Auto-reset after cooldown | Tripped, wait 15 minutes | Circuit breaker RESET, orders resume |
| UT-CB-005 | Manual reset | Tripped, user clicks reset | Circuit breaker RESET, orders resume |
| UT-CB-006 | Broker rejection does not increment | IB error 201 (order rejected) | Counter NOT incremented |
| UT-CB-007 | Connection timeout increments | Broker adapter raises BrokerConnectionError | Counter incremented |
| UT-CB-008 | Queue overflow while tripped | 51st signal arrives while tripped, queue=50 | Signal rejected: "Circuit breaker is active. Signal queue is full." |

### 8.4 Integration Tests

#### 8.4.1 Risk Check Rejection Flow (EX-TEST-012)

For each risk check:
1. Set up preconditions that will cause the check to fail (e.g., open max positions for concurrent position test).
2. Submit a signal via webhook.
3. Verify the signal is REJECTED with the correct rejection_reason.
4. Verify no order was created.
5. Verify `risk_check_audit` shows the FAIL result with actual and threshold values.

#### 8.4.2 Circuit Breaker Trip and Reset (EX-TEST-015)

1. Simulate 3 consecutive broker failures (connection timeouts).
2. Verify circuit breaker trips after the 3rd failure.
3. Submit a new signal. Verify it is queued (not rejected, but not submitted to broker).
4. Verify notification sent to user.
5. Wait for cooldown period (use fast-forward in test). Verify circuit breaker auto-resets.
6. Verify the queued signal is now processed.

#### 8.4.3 Risk Settings Change Flow

1. GET current risk settings. Record values.
2. PUT updated settings (e.g., `daily_loss_limit: 750`).
3. Verify response contains updated values.
4. Verify `risk_settings_changelog` has a new row with correct previous/new values.
5. Submit a signal that would have been rejected under old settings but passes under new settings.
6. Verify the signal passes risk checks.

#### 8.4.4 Flatten-All Flow

1. Create 3 open positions and 5 pending orders.
2. POST `/api/v1/positions/flatten-all` with `{"confirm": true}`.
3. Verify all 3 positions are closed (status=CLOSED, exit_reason=FLATTEN_ALL).
4. Verify all 5 pending orders are cancelled.
5. Verify signal processing is disabled (submit a new signal, verify it is rejected).
6. Verify execution_audit_log has a `manual.flatten_all` entry.
7. Verify the entire operation completed within 5 seconds.

### 8.5 Security Tests

| Test ID | Test Case | Expected |
|---|---|---|
| ST-RC-001 | Modify another user's order | HTTP 404 (not 403, to avoid information leakage) |
| ST-RC-002 | Cancel another user's order | HTTP 404 |
| ST-RC-003 | Close another user's position | HTTP 404 |
| ST-RC-004 | Update another user's risk settings | HTTP 401 or 403 |
| ST-RC-005 | Flatten-all without confirmation | HTTP 400: "Confirmation required" |

---

## 9. Migration & Deployment

### 9.1 Database Migrations

**Migration 007**: Create `risk_check_audit` table with indexes.

**Migration 010**: Create `user_risk_settings` table with indexes. Insert default settings for all existing users.

**Migration 011**: Create `risk_settings_changelog` table with indexes.

**Migration 013**: Create `instrument_correlations` table and seed with correlation data.

### 9.2 Environment Configuration

| Variable | Description | Default |
|---|---|---|
| `CIRCUIT_BREAKER_THRESHOLD` | Consecutive failures before trip | `3` |
| `CIRCUIT_BREAKER_COOLDOWN_SECONDS` | Auto-reset cooldown period | `900` |

---

## 10. Open Questions & Assumptions

### 10.1 Open Questions

| ID | Question | Impact | Status |
|---|---|---|---|
| OQ-006 | Should the correlation matrix be static (pre-configured) or dynamically computed from recent price data? | Affects accuracy and compute requirements. | Open -- MVP uses static matrix. Dynamic computation deferred. |

### 10.2 Assumptions

| ID | Assumption | Risk if Wrong |
|---|---|---|
| AS-003 | Redis is available and persistent for circuit breaker state. Redis data loss results in temporary loss of circuit breaker protection. | If Redis fails, circuit breaker state is lost. System assumes CLOSED state (fail-open). |
| AS-RISK-001 | The worst-case daily loss calculation (all stops hit simultaneously) is sufficiently conservative for retail futures traders. | Users trading highly correlated instruments could experience losses exceeding the worst-case estimate if correlation breaks during a crash. |
| AS-RISK-002 | The static correlation matrix provides adequate risk protection for MVP. Correlations between equity index futures remain stable over short periods. | During market dislocations, correlations may spike or break down. Dynamic correlation monitoring would provide better protection. |

---

## 11. Cross-References

| Document | Relationship |
|---|---|
| FSD-003 (Trade Execution) | Parent FSD. This sub-FSD extracts the risk management engine. |
| FSD-003a (Signal Ingestion & Normalization) | Upstream. Provides validated, enriched signals with computed R:R ratios and account context for risk checks. |
| FSD-003c (Broker Adapters) | Downstream consumer. Circuit breaker monitors broker adapter failures. Manual overrides invoke broker adapter methods. |
| FSD-003d (Order Construction & Lifecycle) | Downstream consumer. Signals that pass risk checks proceed to order construction. Position close and flatten-all create closing orders. |
| FSD-004 (Trade Journaling) | Consumer. Position close events (including manual close and flatten-all) trigger journal entry creation. |
| FSD-005 (Analytics) | Consumer. Risk check audit data is used for risk pattern analysis. |
| FSD-008 (Notifications) | Consumer. Circuit breaker trips, daily loss limit reached, and risk warnings trigger notifications. |
| FSD-009 (Auth & Multi-Tenancy) | Dependency. All API endpoints require authenticated Bearer tokens. User isolation enforced on all queries. |
